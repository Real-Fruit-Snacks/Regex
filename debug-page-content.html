<!DOCTYPE html><html lang="en" style="--token-command-bg: rgba(115, 208, 255, 0.15); --token-command-color: #73d0ff; --token-command-border: rgba(115, 208, 255, 0.3); --token-subcommand-bg: rgba(255, 204, 102, 0.15); --token-subcommand-color: #ffcc66; --token-subcommand-border: rgba(255, 204, 102, 0.3); --token-option-bg: rgba(242, 151, 142, 0.15); --token-option-color: #f29782; --token-option-border: rgba(242, 151, 142, 0.3); --token-argument-bg: rgba(191, 201, 166, 0.15); --token-argument-color: #bfcfa6; --token-argument-border: rgba(191, 201, 166, 0.3); --token-variable-bg: rgba(95, 175, 239, 0.15); --token-variable-color: #5fafef; --token-variable-border: rgba(95, 175, 239, 0.3); --token-expansion-bg: rgba(255, 204, 102, 0.15); --token-expansion-color: #ffcc66; --token-expansion-border: rgba(255, 204, 102, 0.3); --token-operator-bg: rgba(242, 151, 142, 0.15); --token-operator-color: #f29782; --token-operator-border: rgba(242, 151, 142, 0.3); --token-redirect-bg: rgba(255, 51, 102, 0.15); --token-redirect-color: #ff3366; --token-redirect-border: rgba(255, 51, 102, 0.3); --token-special-bg: rgba(204, 204, 194, 0.1); --token-special-color: #cccac2; --token-special-border: rgba(204, 204, 194, 0.2); --shortcuts-bg: #232834; --shortcuts-header-bg: #1f2430; --shortcuts-border: #2d3444; --shortcuts-title-color: #ffcc66; --shortcuts-text: #cccac2; --shortcuts-button-bg: rgba(45, 52, 68, 0.4); --shortcuts-button-border: #33415e; --shortcuts-button-hover-bg: rgba(255, 204, 102, 0.1); --shortcuts-button-hover-color: #ffcc66; --shortcuts-button-hover-border: #ffcc66; --shortcuts-scrollbar-track: #191e2a; --shortcuts-scrollbar-thumb: #33415e; --shortcuts-section-bg: rgba(31, 36, 48, 0.6); --shortcuts-section-border: #2d3444; --shortcuts-section-title: #cccac2; --shortcuts-accent: #ffcc66; --shortcuts-item-border: rgba(51, 65, 94, 0.2); --shortcuts-kbd-bg: rgba(115, 208, 255, 0.15); --shortcuts-kbd-border: #73d0ff; --shortcuts-kbd-color: #73d0ff; --shortcuts-kbd-shadow: rgba(115, 208, 255, 0.2); --shortcuts-plus-color: #607080;"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux Man Pages</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
    <link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
    <link rel="icon" type="image/png" sizes="256x256" href="favicon-256x256.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    
    <!-- Dynamic theme loading system will inject CSS here -->
    <style id="theme-styles">/* Ayu Mirage Theme */
/* A sophisticated dark theme with warm colors and excellent readability
   Part of the popular Ayu theme family, Mirage variant offers perfect balance
   Features orange accents, soft blues, and warm grays
*/

/* Ayu Mirage Color Palette:
   Background:
   bg: #1f2430 (main background)
   bg_dark: #191e2a (darker background)
   bg_highlight: #232834 (highlighted background)
   panel_bg: #232834 (panel background)
   panel_shadow: #141925 (shadow color)
   
   Foreground:
   fg: #cccac2 (main text)
   fg_idle: #607080 (idle/muted text)
   fg_accent: #ffcc66 (accent text)
   
   UI Colors:
   ui_bg: #1f2430 (ui background)
   ui_highlight: #2d3444 (ui highlight)
   ui_selection: #33415e (selection)
   ui_cursor: #ffcc66 (cursor)
   
   Syntax Colors:
   orange: #ffad66 (keywords, constants)
   yellow: #ffd173 (strings)
   green: #d5ff80 (functions)
   cyan: #73d0ff (types, classes)
   blue: #5ccfe6 (variables)
   purple: #dfbfff (interfaces)
   red: #ff6666 (errors)
   
   Special:
   accent: #ffcc66 (main accent)
   keyword: #ffad66 (keywords)
   func: #ffd173 (functions)
   entity: #73d0ff (entities)
   string: #d5ff80 (strings)
   constant: #dfbfff (constants)
   operator: #f29e74 (operators)
   error: #ff3333 (errors)
   warning: #ffcc66 (warnings)
   info: #5ccfe6 (info)
   success: #95e6cb (success)
*/

body.ayu-mirage {
    background: linear-gradient(135deg, #191e2a 0%, #1f2430 50%, #232834 100%);
    min-height: 100vh;
    color: #cccac2;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
}

/* Main containers */
body.ayu-mirage .content-wrapper,
body.ayu-mirage .section-nav,
body.ayu-mirage .man-page-container,
body.ayu-mirage .side-panel,
body.ayu-mirage .shortcuts-help {
    background: rgba(31, 36, 48, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid #2d3444;
    border-radius: 8px;
    box-shadow: 
        0 8px 32px rgba(20, 25, 37, 0.4),
        0 0 0 1px rgba(255, 204, 102, 0.05);
}

body.ayu-mirage .man-page-header {
    background: linear-gradient(90deg, #232834 0%, #2d3444 100%);
    border-bottom: 2px solid #ffcc66;
    border-radius: 8px 8px 0 0;
    box-shadow: 0 2px 20px rgba(255, 204, 102, 0.1);
}

body.ayu-mirage .side-panel-header {
    background: #232834;
    border-bottom: 2px solid #ffcc66;
    border-radius: 8px 8px 0 0;
}

/* Text colors */
body.ayu-mirage .logo {
    color: #ffcc66;
    text-shadow: 
        0 0 20px rgba(255, 204, 102, 0.4),
        0 0 40px rgba(255, 204, 102, 0.2);
    font-weight: 600;
}

body.ayu-mirage .container {
    color: #cccac2;
}

body.ayu-mirage .man-page-title,
body.ayu-mirage .section-nav h3,
body.ayu-mirage .shortcuts-help h3,
body.ayu-mirage .related-commands h4 {
    color: #73d0ff;
    text-shadow: 0 0 10px rgba(115, 208, 255, 0.3);
    font-weight: 600;
}

body.ayu-mirage .close-button,
body.ayu-mirage .action-button {
    color: #cccac2;
    background: rgba(45, 52, 68, 0.4);
    border: 1px solid #33415e;
    border-radius: 6px;
    transition: all 0.2s ease;
}

body.ayu-mirage .close-button:hover,
body.ayu-mirage .action-button:hover {
    color: #ffcc66;
    background: rgba(255, 204, 102, 0.1);
    border-color: #ffcc66;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.2);
}

body.ayu-mirage .action-button.active {
    background: rgba(115, 208, 255, 0.15);
    color: #73d0ff;
    border-color: #73d0ff;
    box-shadow: 0 0 20px rgba(115, 208, 255, 0.3);
}

/* Man page content */
body.ayu-mirage .man-page-content {
    background: rgba(25, 30, 42, 0.8);
    color: #cccac2;
    border: 1px solid #2d3444;
    border-radius: 6px;
}

body.ayu-mirage .man-page-content .section-header {
    color: #ffd173;
    font-weight: 600;
    text-shadow: 0 0 8px rgba(255, 209, 115, 0.3);
    border-bottom: 1px solid rgba(255, 209, 115, 0.2);
    margin-bottom: 12px;
    padding-bottom: 8px;
}

body.ayu-mirage .man-page-content .option {
    color: #ffad66;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(255, 173, 102, 0.2);
}

body.ayu-mirage .man-page-content .command {
    color: #5ccfe6;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(92, 207, 230, 0.2);
}

body.ayu-mirage .man-page-content .example {
    background: rgba(45, 52, 68, 0.3);
    border-left: 3px solid #95e6cb;
    border-radius: 4px;
    box-shadow: inset 0 0 20px rgba(149, 230, 203, 0.05);
}

body.ayu-mirage .man-page-content strong {
    color: #d5ff80;
    font-weight: 600;
    text-shadow: 0 0 3px rgba(213, 255, 128, 0.3);
}

body.ayu-mirage .man-page-content .cross-ref {
    color: #73d0ff;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.3);
}

body.ayu-mirage .man-page-content em {
    color: #607080;
    font-style: italic;
}

/* Suggestions */
body.ayu-mirage .suggestions {
    background: rgba(35, 40, 52, 0.95);
    border: 1px solid #33415e;
    border-radius: 8px;
    box-shadow: 
        0 8px 32px rgba(20, 25, 37, 0.6),
        0 0 0 1px rgba(255, 204, 102, 0.1);
}

body.ayu-mirage .suggestion {
    border-bottom: 1px solid rgba(51, 65, 94, 0.3);
    color: #cccac2;
}

body.ayu-mirage .suggestion:hover,
body.ayu-mirage .suggestion.selected {
    background: rgba(255, 204, 102, 0.1);
    border-left: 3px solid #ffcc66;
    box-shadow: inset 0 0 20px rgba(255, 204, 102, 0.05);
}

body.ayu-mirage .suggestion-command {
    color: #73d0ff;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .suggestion-desc {
    color: #607080;
}

body.ayu-mirage .section-badge {
    background: rgba(115, 208, 255, 0.15);
    color: #73d0ff;
    border: 1px solid rgba(115, 208, 255, 0.3);
    border-radius: 12px;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(115, 208, 255, 0.3);
}

/* Navigation */
body.ayu-mirage .section-nav {
    background: rgba(31, 36, 48, 0.9);
    border-right: 1px solid #2d3444;
    border-radius: 8px 0 0 8px;
}

body.ayu-mirage .section-nav::-webkit-scrollbar-track {
    background: #191e2a;
}

body.ayu-mirage .section-nav::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #33415e 0%, #2d3444 100%);
    border-radius: 4px;
    box-shadow: 0 0 5px rgba(51, 65, 94, 0.3);
}

body.ayu-mirage .section-nav::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #607080 0%, #33415e 100%);
}

body.ayu-mirage .section-nav h3 {
    background: #232834;
    color: #ffcc66;
    border-bottom: 1px solid rgba(255, 204, 102, 0.2);
    font-weight: 600;
    text-shadow: 0 0 10px rgba(255, 204, 102, 0.2);
    border-radius: 8px 0 0 0;
}

body.ayu-mirage .nav-section-header {
    color: #cccac2;
    transition: all 0.2s ease;
}

body.ayu-mirage .nav-section-header:hover {
    background: rgba(115, 208, 255, 0.1);
    border-left: 3px solid #73d0ff;
}

body.ayu-mirage .nav-section-header.active {
    background: rgba(255, 204, 102, 0.15);
    color: #ffcc66;
    border-left: 3px solid #ffcc66;
    box-shadow: inset 0 0 20px rgba(255, 204, 102, 0.1);
}

body.ayu-mirage .nav-section-icon {
    background: rgba(115, 208, 255, 0.2);
    color: #73d0ff;
    border-radius: 4px;
    box-shadow: 0 0 10px rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .nav-section-header.active .nav-section-icon {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%);
    color: #1f2430;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.4);
}

body.ayu-mirage .nav-sub-list {
    background: rgba(25, 30, 42, 0.5);
    border-left: 1px solid rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .nav-sub-list a {
    color: #607080;
}

body.ayu-mirage .nav-sub-list a:hover {
    color: #ffcc66;
    text-shadow: 0 0 5px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .nav-sub-list a.active {
    color: #d5ff80;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(213, 255, 128, 0.3);
}

body.ayu-mirage .nav-sub-list a.active::before {
    background: #d5ff80;
    box-shadow: 0 0 10px rgba(213, 255, 128, 0.5);
}

/* Collapsible sections */
body.ayu-mirage .man-section {
    background: rgba(31, 36, 48, 0.6);
    border: 1px solid #2d3444;
    border-radius: 6px;
}

body.ayu-mirage .man-section:hover {
    border-color: #33415e;
    box-shadow: 0 0 20px rgba(51, 65, 94, 0.2);
}

body.ayu-mirage .man-section-header {
    background: rgba(35, 40, 52, 0.8);
    border-radius: 6px 6px 0 0;
}

body.ayu-mirage .man-section-title {
    color: #ffd173;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(255, 209, 115, 0.2);
}

body.ayu-mirage .collapse-icon {
    color: #607080;
}

body.ayu-mirage .man-section-content {
    background: rgba(25, 30, 42, 0.3);
}

/* TLDR Section */
body.ayu-mirage .tldr-section {
    background: linear-gradient(180deg, rgba(25, 30, 42, 0.9) 0%, rgba(45, 52, 68, 0.3) 100%);
    border-top: 2px solid #95e6cb;
    border-radius: 0 0 6px 6px;
    box-shadow: 0 -5px 20px rgba(149, 230, 203, 0.1);
}

body.ayu-mirage .tldr-section h4 {
    color: #95e6cb;
    font-weight: 600;
    text-shadow: 0 0 15px rgba(149, 230, 203, 0.4);
}

body.ayu-mirage .tldr-examples h5 {
    color: #73d0ff;
    font-weight: 500;
}

body.ayu-mirage .tldr-description {
    color: #cccac2;
}

body.ayu-mirage .tldr-example {
    background: rgba(45, 52, 68, 0.3);
    border-left: 3px solid #d5ff80;
    border-radius: 4px;
    box-shadow: inset 0 0 20px rgba(213, 255, 128, 0.05);
}

body.ayu-mirage .example-code {
    background: rgba(25, 30, 42, 0.8);
    color: #5ccfe6;
    border: 1px solid #2d3444;
    border-radius: 4px;
    text-shadow: 0 0 2px rgba(92, 207, 230, 0.2);
}

body.ayu-mirage .example-description {
    color: #607080;
}

body.ayu-mirage .tldr-placeholder {
    background: rgba(213, 255, 128, 0.2);
    color: #d5ff80;
    border: 1px solid rgba(213, 255, 128, 0.3);
    border-radius: 3px;
    padding: 0 4px;
    box-shadow: 0 0 5px rgba(213, 255, 128, 0.2);
}

body.ayu-mirage .tldr-option {
    color: #ffad66;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(255, 173, 102, 0.2);
}

/* Other elements */
body.ayu-mirage .shortcuts-help-content {
    color: #cccac2;
}

body.ayu-mirage .shortcut-item {
    border-bottom: 1px solid rgba(51, 65, 94, 0.2);
    color: #cccac2;
}

body.ayu-mirage .shortcut-description {
    color: #cccac2 !important;
    opacity: 0.9;
}

body.ayu-mirage .shortcut-key {
    background: rgba(115, 208, 255, 0.15);
    border: 1px solid #73d0ff;
    color: #73d0ff;
    border-radius: 4px;
    font-weight: 500;
    box-shadow: 0 0 5px rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .loading {
    color: #607080;
}

body.ayu-mirage .error {
    background: rgba(255, 102, 102, 0.15);
    color: #ff6666;
    border-radius: 6px;
    box-shadow: 0 0 20px rgba(255, 102, 102, 0.2);
}

/* Related commands */
body.ayu-mirage .related-commands {
    background: rgba(31, 36, 48, 0.6);
    border: 1px solid #2d3444;
    border-radius: 6px;
}

body.ayu-mirage .related-commands a {
    background: rgba(115, 208, 255, 0.1);
    color: #73d0ff;
    border: 1px solid rgba(115, 208, 255, 0.3);
    border-radius: 4px;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.2);
    transition: all 0.2s ease;
}

body.ayu-mirage .related-commands a:hover {
    background: rgba(115, 208, 255, 0.2);
    box-shadow: 0 0 15px rgba(115, 208, 255, 0.3);
    transform: translateY(-1px);
}

/* Search in page */
body.ayu-mirage .search-in-page {
    background: rgba(35, 40, 52, 0.95);
    border-bottom: 2px solid #ffcc66;
}

body.ayu-mirage .search-in-page input {
    background: rgba(25, 30, 42, 0.8);
    border: 1px solid #33415e;
    color: #cccac2;
    border-radius: 4px;
}

body.ayu-mirage .search-in-page input:focus {
    border-color: #ffcc66;
    box-shadow: 0 0 10px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .search-in-page button {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%);
    color: #1f2430;
    border-radius: 4px;
    font-weight: 500;
    box-shadow: 0 0 10px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .search-in-page button:hover {
    background: linear-gradient(135deg, #d5ff80 0%, #95e6cb 100%);
    box-shadow: 0 0 15px rgba(213, 255, 128, 0.4);
}

body.ayu-mirage .highlight {
    background: rgba(255, 209, 115, 0.3);
    color: #1f2430;
    border-radius: 2px;
    box-shadow: 0 0 8px rgba(255, 209, 115, 0.3);
}

body.ayu-mirage .highlight.current {
    background: rgba(213, 255, 128, 0.4);
    color: #1f2430;
    box-shadow: 0 0 12px rgba(213, 255, 128, 0.4);
}

/* Theme toggle button */
body.ayu-mirage .theme-toggle {
    background: rgba(255, 204, 102, 0.1);
    border: 2px solid #ffcc66;
    border-radius: 50%;
    box-shadow: 0 0 20px rgba(255, 204, 102, 0.2);
}

body.ayu-mirage .theme-toggle:hover {
    background: rgba(255, 204, 102, 0.2);
    box-shadow: 0 0 30px rgba(255, 204, 102, 0.4);
    transform: scale(1.1);
}

/* Side panel tabs */
body.ayu-mirage .side-panel-tab {
    color: #607080;
    transition: all 0.2s ease;
}

body.ayu-mirage .side-panel-tab.active {
    color: #ffcc66;
    border-bottom: 2px solid #ffcc66;
    text-shadow: 0 0 5px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .side-panel-tabs {
    border-bottom: 1px solid rgba(51, 65, 94, 0.2);
    background: rgba(35, 40, 52, 0.8);
}

body.ayu-mirage .side-panel-content {
    background: rgba(31, 36, 48, 0.9);
    border: 1px solid #2d3444;
}

body.ayu-mirage .side-panel-item {
    border-bottom: 1px solid rgba(51, 65, 94, 0.1);
    color: #cccac2;
    transition: all 0.2s ease;
}

body.ayu-mirage .side-panel-item:hover {
    background: rgba(255, 204, 102, 0.05);
}

body.ayu-mirage .side-panel-item-command {
    color: #73d0ff;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.2);
}

/* Side panel header styling */
body.ayu-mirage .side-panel-header h3 {
    color: #cccac2 !important;
    font-weight: 600 !important;
    text-shadow: 0 0 10px rgba(204, 202, 194, 0.2);
}

/* Search bar styling */
body.ayu-mirage .search-input {
    background: #191e2a;
    color: #cccac2;
    border: 1px solid #33415e;
    border-radius: 8px;
}

body.ayu-mirage .search-input::placeholder {
    color: #607080;
}

body.ayu-mirage .search-input:focus {
    border-color: #ffcc66;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .search-button {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%);
    color: #1f2430;
    border-radius: 8px;
    font-weight: 500;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.3);
    transition: all 0.2s ease;
}

body.ayu-mirage .search-button:hover {
    background: linear-gradient(135deg, #73d0ff 0%, #5ccfe6 100%);
    box-shadow: 0 0 20px rgba(115, 208, 255, 0.4);
    transform: translateY(-1px);
}

body.ayu-mirage .section-select {
    background: #191e2a;
    color: #cccac2;
    border: 1px solid #33415e;
    border-radius: 8px;
}

/* Command Explainer styling */
body.ayu-mirage .command-explainer-modal {
    background: rgba(31, 36, 48, 0.95);
    color: #cccac2;
    border: 1px solid #33415e;
    border-radius: 12px;
    box-shadow: 
        0 20px 40px rgba(20, 25, 37, 0.8),
        0 0 0 1px rgba(255, 204, 102, 0.1);
    backdrop-filter: blur(12px);
}

body.ayu-mirage .command-explainer-header {
    background: rgba(35, 40, 52, 0.8);
    border-bottom: 1px solid #2d3444;
    border-radius: 12px 12px 0 0;
}

body.ayu-mirage .command-explainer-header h3 {
    color: #ffcc66;
    font-weight: 600;
    text-shadow: 0 0 10px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .command-explainer-content {
    background: transparent;
}

body.ayu-mirage .command-input {
    background: rgba(25, 30, 42, 0.8);
    color: #cccac2;
    border: 2px solid #33415e;
    border-radius: 8px;
    box-shadow: inset 0 0 20px rgba(25, 30, 42, 0.5);
}

body.ayu-mirage .command-input:focus {
    border-color: #ffcc66;
    box-shadow: 
        0 0 20px rgba(255, 204, 102, 0.3),
        inset 0 0 20px rgba(25, 30, 42, 0.5);
}

body.ayu-mirage .command-breakdown {
    background: rgba(25, 30, 42, 0.4);
    border: 1px solid #2d3444;
    border-radius: 8px;
}

body.ayu-mirage .command-token.command {
    background: linear-gradient(135deg, #2d3444 0%, #33415e 100%);
    color: #73d0ff;
    border: 1px solid #5ccfe6;
    border-radius: 4px;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(115, 208, 255, 0.3);
}

body.ayu-mirage .command-token.option {
    background: linear-gradient(135deg, #33415e 0%, #607080 100%);
    color: #ffad66;
    border: 1px solid #ff8800;
    border-radius: 4px;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(255, 173, 102, 0.3);
}

body.ayu-mirage .command-token.argument {
    background: rgba(213, 255, 128, 0.15);
    color: #d5ff80;
    border: 1px solid #95e6cb;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .command-token.pipe {
    background: rgba(255, 102, 102, 0.15);
    color: #ff6666;
    border: 1px solid #ff3333;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .command-token.redirect {
    background: rgba(223, 191, 255, 0.15);
    color: #dfbfff;
    border: 1px solid #cba6f7;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .command-token.unknown {
    background: rgba(96, 112, 128, 0.15);
    color: #607080;
    border: 1px solid #607080;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .explanation-section {
    background: rgba(35, 40, 52, 0.6);
    border: 1px solid #2d3444;
    border-radius: 8px;
}

body.ayu-mirage .explanation-header {
    background: rgba(25, 30, 42, 0.8);
    border-bottom: 1px solid #2d3444;
    color: #607080;
    border-radius: 8px 8px 0 0;
}

body.ayu-mirage .explanation-header:hover {
    background: rgba(115, 208, 255, 0.1);
    color: #ffcc66;
}

body.ayu-mirage .option-name {
    color: #ffad66;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(255, 173, 102, 0.3);
}

body.ayu-mirage .option-description {
    color: #607080;
}

body.ayu-mirage .example-command {
    background: rgba(25, 30, 42, 0.8);
    border: 1px solid #2d3444;
    color: #5ccfe6;
    border-radius: 4px;
    font-weight: 500;
    box-shadow: inset 0 0 20px rgba(25, 30, 42, 0.5);
}

body.ayu-mirage .no-explanation {
    color: #607080;
    font-style: italic;
}

/* Theme Modal styling */
body.ayu-mirage .theme-modal {
    background: #1f2430 !important;
    color: #cccac2 !important;
    border: 1px solid #33415e !important;
    border-radius: 12px !important;
    box-shadow: 0 20px 40px rgba(20, 25, 37, 0.8) !important;
}

body.ayu-mirage .theme-modal-header {
    background: #232834 !important;
    border-bottom: 1px solid #2d3444 !important;
    border-radius: 12px 12px 0 0 !important;
}

body.ayu-mirage .theme-modal-header h3 {
    color: #ffcc66 !important;
    font-weight: 600 !important;
    text-shadow: 0 0 10px rgba(255, 204, 102, 0.3) !important;
}

body.ayu-mirage .theme-modal-content {
    background: #1f2430 !important;
}

body.ayu-mirage .theme-modal .close-button {
    color: #607080 !important;
    background: rgba(45, 52, 68, 0.4) !important;
    border: 1px solid #33415e !important;
    border-radius: 4px !important;
}

body.ayu-mirage .theme-modal .close-button:hover {
    color: #ff6666 !important;
    background: rgba(255, 102, 102, 0.1) !important;
    border-color: #ff6666 !important;
}

body.ayu-mirage .theme-option {
    border: 1px solid #2d3444 !important;
    border-radius: 8px !important;
    background: rgba(35, 40, 52, 0.6) !important;
    transition: all 0.2s ease !important;
}

body.ayu-mirage .theme-option:hover {
    border-color: #ffcc66 !important;
    background: rgba(255, 204, 102, 0.1) !important;
    transform: translateY(-2px) !important;
}

body.ayu-mirage .theme-option h4 {
    color: #73d0ff !important;
    font-weight: 600 !important;
}

body.ayu-mirage .theme-option p {
    color: #607080 !important;
}

/* FAB Buttons */
body.ayu-mirage .fab-container .fab {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%) !important;
    color: #1f2430 !important;
    border-radius: 50% !important;
    font-weight: 500 !important;
    box-shadow: 0 8px 25px rgba(255, 204, 102, 0.3) !important;
    transition: all 0.3s ease !important;
}

body.ayu-mirage .fab-container .fab:hover {
    background: linear-gradient(135deg, #73d0ff 0%, #5ccfe6 100%) !important;
    box-shadow: 0 12px 35px rgba(115, 208, 255, 0.4) !important;
    transform: scale(1.1) translateY(-2px);
}

/* Status message */
body.ayu-mirage .status {
    background: rgba(31, 36, 48, 0.95) !important;
    color: #cccac2 !important;
    border: 1px solid #33415e !important;
    border-radius: 8px !important;
    box-shadow: 0 8px 25px rgba(20, 25, 37, 0.6) !important;
    backdrop-filter: blur(8px) !important;
}</style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --dropdown-arrow: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23cccac2' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            transition: all 0.3s ease;
            
            /* Default dropdown theme variables (Ayu Mirage) */
            --dropdown-bg: #232834;
            --dropdown-text: #cccac2;
            --dropdown-border: #2d3444;
            --dropdown-hover-bg: #2d3444;
            --dropdown-hover-text: #ffcc66;
            --dropdown-focus-bg: #2d3444;
            --dropdown-focus-shadow: rgba(255, 204, 102, 0.3);
            --dropdown-focus-border: #ffcc66;
            --dropdown-option-bg: #232834;
            --dropdown-option-text: #cccac2;
            --dropdown-option-hover-bg: #2d3444;
            --dropdown-option-hover-text: #ffcc66;
            --input-text: #cccac2;
            --input-focus-border: #ffcc66;
            --search-box-bg: #232834;
            --search-box-border: #2d3444;
            --search-box-focus-border: #ffcc66;
            
            /* Default shortcuts modal theme variables (Ayu Mirage) */
            --shortcuts-bg: #232834;
            --shortcuts-header-bg: #1f2430;
            --shortcuts-border: #2d3444;
            --shortcuts-title-color: #ffcc66;
            --shortcuts-text: #cccac2;
            --shortcuts-button-bg: rgba(45, 52, 68, 0.4);
            --shortcuts-button-border: #33415e;
            --shortcuts-button-hover-bg: rgba(255, 204, 102, 0.1);
            --shortcuts-button-hover-color: #ffcc66;
            --shortcuts-button-hover-border: #ffcc66;
            --shortcuts-scrollbar-track: #191e2a;
            --shortcuts-scrollbar-thumb: #33415e;
            --shortcuts-section-bg: rgba(31, 36, 48, 0.6);
            --shortcuts-section-border: #2d3444;
            --shortcuts-section-title: #cccac2;
            --shortcuts-accent: #ffcc66;
            --shortcuts-item-border: rgba(51, 65, 94, 0.2);
            --shortcuts-kbd-bg: rgba(115, 208, 255, 0.15);
            --shortcuts-kbd-border: #73d0ff;
            --shortcuts-kbd-color: #73d0ff;
            --shortcuts-kbd-shadow: rgba(115, 208, 255, 0.2);
            --shortcuts-plus-color: #607080;
        }

        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container.search-active {
            justify-content: flex-start;
            padding-top: 40px;
        }

        .logo {
            font-size: 48px;
            font-weight: bold;
            color: white;
            margin-bottom: 40px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .search-active .logo {
            font-size: 32px;
            margin-bottom: 20px;
        }

        .search-container {
            width: 100%;
            max-width: 600px;
            position: relative;
        }

        .search-box {
            display: flex;
            background: var(--search-box-bg, #232834);
            border-radius: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
            border: 1px solid var(--search-box-border, #2d3444);
        }

        .search-box:focus-within {
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            border-color: var(--search-box-focus-border, #ffcc66);
        }

        .section-select {
            padding: 12px 16px;
            border: none;
            background: var(--dropdown-bg, #232834);
            backdrop-filter: blur(8px);
            font-size: 14px;
            color: var(--dropdown-text, #cccac2);
            cursor: pointer;
            min-width: 140px;
            border-right: 1px solid var(--dropdown-border, #2d3444);
            border-radius: 8px 0 0 8px;
            font-weight: 500;
            transition: all 0.2s ease;
            appearance: none;
            background-image: var(--dropdown-arrow);
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }
        
        .section-select:hover {
            background: var(--dropdown-hover-bg, #2d3444);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            color: var(--dropdown-hover-text, #ffcc66);
        }
        
        .section-select:focus {
            outline: 2px solid var(--dropdown-focus-border, #ffcc66);
            outline-offset: -2px;
            background: var(--dropdown-focus-bg, #2d3444);
        }
        
        .section-select option {
            padding: 12px 16px;
            background: var(--dropdown-option-bg, #232834);
            color: var(--dropdown-option-text, #cccac2);
            font-weight: 500;
        }
        
        .section-select option:hover {
            background: var(--dropdown-option-hover-bg, #2d3444);
            color: var(--dropdown-option-hover-text, #ffcc66);
        }
        
        /* Light theme dropdown overrides */
        body.light {
            --dropdown-bg: rgba(255, 255, 255, 0.9);
            --dropdown-text: #333;
            --dropdown-border: #e0e0e0;
            --dropdown-hover-bg: rgba(255, 255, 255, 0.95);
            --dropdown-hover-text: #0066cc;
            --dropdown-focus-bg: rgba(255, 255, 255, 1);
            --dropdown-focus-shadow: rgba(0, 102, 204, 0.2);
            --dropdown-focus-border: #0066cc;
            --dropdown-option-bg: #fff;
            --dropdown-option-text: #333;
            --dropdown-option-hover-bg: #f8f9fa;
            --dropdown-option-hover-text: #0066cc;
            --dropdown-arrow: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            --input-text: #333;
            --input-focus-border: #0066cc;
            --search-box-bg: white;
            --search-box-border: #e0e0e0;
            --search-box-focus-border: #0066cc;
        }
        
        /* Hotdog Stand dropdown overrides */
        body.hotdog-stand {
            --dropdown-bg: #FF0000;
            --dropdown-text: #FFFF00;
            --dropdown-border: #FFFF00;
            --dropdown-hover-bg: #FFFF00;
            --dropdown-hover-text: #FF0000;
            --dropdown-focus-bg: #FFFF00;
            --dropdown-focus-shadow: rgba(255, 0, 0, 0.5);
            --dropdown-focus-border: #FF0000;
            --dropdown-option-bg: #FF0000;
            --dropdown-option-text: #FFFF00;
            --dropdown-option-hover-bg: #FFFF00;
            --dropdown-option-hover-text: #FF0000;
            --dropdown-arrow: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23FFFF00' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
        }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            font-size: 16px;
            outline: none;
            background: transparent;
            color: var(--input-text, #cccac2);
        }
        
        .search-input:focus {
            outline: 2px solid var(--input-focus-border, #ffcc66);
            outline-offset: -2px;
        }

        .search-button {
            padding: 12px 24px;
            border: none;
            background: #4285f4;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-button:hover {
            background: #3367d6;
        }

        .suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border-radius: 8px;
            margin-top: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 100;
        }

        .suggestion {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background 0.2s;
        }

        .suggestion:hover, .suggestion.selected {
            background: #f8f9fa;
        }

        .suggestion:last-child {
            border-bottom: none;
        }

        .suggestion-info {
            flex: 1;
        }

        .suggestion-command {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .suggestion-desc {
            font-size: 14px;
            color: #666;
        }

        .section-badge {
            background: #e8f0fe;
            color: #1967d2;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 12px;
        }

        .section-area {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .section-clickable {
            cursor: pointer;
            transition: all 0.2s;
        }

        .section-clickable:hover {
            background: #1967d2 !important;
            color: white !important;
        }

        /* Main content area with navigation */
        .content-wrapper {
            display: none;
            width: 100%;
            max-width: 1600px;
            margin-top: 20px;
            flex-direction: row;
            gap: 24px;
            padding: 0 20px;
        }

        /* Section navigation sidebar */
        .section-nav {
            width: 220px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 0;
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            overflow-x: hidden;
            flex-shrink: 0;
        }
        
        /* Custom scrollbar for section nav */
        .section-nav::-webkit-scrollbar {
            width: 6px;
        }
        
        .section-nav::-webkit-scrollbar-track {
            background: #f5f7fa;
        }
        
        .section-nav::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }
        
        .section-nav::-webkit-scrollbar-thumb:hover {
            background: #bbb;
        }

        .section-nav h3 {
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
            padding: 20px 24px 16px;
            color: #666;
            background: #fafbfc;
            border-bottom: 1px solid #e8eaed;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .section-nav > ul {
            padding: 12px 0;
        }
        
        .section-nav > ul > li {
            margin-bottom: 0;
        }

        .section-nav ul {
            list-style: none;
        }

        .section-nav li {
            margin-bottom: 0;
        }

        .section-nav a {
            color: #666;
            text-decoration: none;
            font-size: 14px;
            display: block;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .section-nav a:hover, .section-nav a.active {
            background: #e8f0fe;
            color: #1967d2;
        }
        
        /* Section group header styling */
        .nav-section-header {
            padding: 12px 24px;
            font-weight: 600;
            font-size: 15px;
            color: #1a1a1a;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        
        .nav-section-header:hover {
            background: #f8f9fa;
            border-left-color: #1967d2;
        }
        
        .nav-section-header.active {
            background: #e8f0fe;
            color: #1967d2;
            border-left-color: #1967d2;
        }
        
        .nav-section-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background: #e8eaed;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: #666;
            flex-shrink: 0;
        }
        
        .nav-section-header.active .nav-section-icon {
            background: #1967d2;
            color: white;
        }
        
        /* Sub-navigation items */
        .nav-sub-list {
            display: none;
            background: #fafbfc;
            border-left: 3px solid #e8eaed;
            margin-left: 24px;
            padding: 8px 0;
        }
        
        .nav-sub-list.active {
            display: block;
        }
        
        .nav-sub-list li {
            margin: 0;
        }
        
        .nav-sub-list a {
            padding: 8px 20px;
            font-size: 13px;
            color: #666;
            position: relative;
            transition: all 0.15s;
        }
        
        .nav-sub-list a:hover {
            background: transparent;
            color: #1967d2;
            padding-left: 24px;
        }
        
        .nav-sub-list a.active {
            color: #1967d2;
            font-weight: 500;
            background: transparent;
        }
        
        .nav-sub-list a.active::before {
            content: '';
            position: absolute;
            left: -3px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 16px;
            background: #1967d2;
        }

        .man-page-container {
            flex: 1;
            background: #f5f7fa;
            border-radius: 0;
            box-shadow: none;
            overflow: visible;
            padding: 8px 16px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .man-page-header {
            background: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .man-page-title {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .action-button {
            background: none;
            border: 1px solid #ddd;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            transition: all 0.2s;
        }

        .action-button:hover {
            background: #f8f9fa;
            border-color: #999;
            color: #333;
        }
        
        .command-link-button {
            background: #1a1a1a;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .command-link-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            filter: brightness(1.2);
        }
        
        /* Command color coding */
        .command-link-button.command-0 { background: #4a90e2; }
        .command-link-button.command-1 { background: #e74c3c; }
        .command-link-button.command-2 { background: #2ecc71; }
        .command-link-button.command-3 { background: #f39c12; }
        .command-link-button.command-4 { background: #9b59b6; }
        
        .command-header {
            font-weight: 600;
            font-size: 14px;
            margin-top: 15px;
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            color: #fff;
            display: inline-block;
        }
        
        .command-header.command-0 { background: #4a90e2; }
        .command-header.command-1 { background: #e74c3c; }
        .command-header.command-2 { background: #2ecc71; }
        .command-header.command-3 { background: #f39c12; }
        .command-header.command-4 { background: #9b59b6; }

        .action-button.active {
            background: #e8f0fe;
            color: #1967d2;
            border-color: #1967d2;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.2s;
        }

        .close-button:hover {
            color: #333;
        }


        .man-page-content {
            padding: 20px 30px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            white-space: normal;
            word-wrap: break-word;
            color: #333;
            position: relative;
            max-width: 900px;
            margin: 0 auto;
        }
        
        /* Remove default container styling when displaying sections */
        .man-sections-container .man-page-header {
            display: none;
        }
        
        .man-page-content pre {
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            white-space: normal;
            word-wrap: break-word;
            margin: 0;
            background: transparent;
            border: none;
            padding: 0;
            overflow-x: auto;
        }
        
        /* Handle code blocks and examples differently */
        .man-page-content .code-block,
        .man-page-content pre code {
            white-space: pre;
            background: #f6f8fa;
            padding: 8px 12px;
            border-radius: 4px;
            display: block;
            margin: 8px 0;
            overflow-x: auto;
        }
        
        /* Better paragraph spacing */
        .man-page-content p {
            margin: 0.5em 0;
            white-space: normal;
        }
        
        /* Indented content */
        .man-page-content .indent {
            margin-left: 2em;
        }
        
        /* Collapsible sections for multiple man pages */
        .man-sections-container {
            padding: 0;
        }
        
        .man-section {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin-bottom: 4px;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .man-section:hover {
            border-color: #1967d2;
        }
        
        .man-section-header {
            background: white;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            position: relative;
        }
        
        .man-section-header:hover {
            background: #f8f9fa;
        }
        
        .man-section-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .man-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #1a1a1a;
        }
        
        .section-badge {
            background: #e8f0fe;
            color: #1967d2;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 500;
        }
        
        .unloaded-indicator {
            color: #ffa500;
            font-size: 10px;
            margin-left: 8px;
        }
        
        .collapse-icon {
            font-size: 14px;
            color: #999;
            transition: transform 0.3s;
            flex-shrink: 0;
            margin-left: 12px;
        }
        
        .man-section.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }
        
        .man-section-content {
            max-height: none;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: #fafbfc;
        }
        
        .man-section.collapsed .man-section-content {
            max-height: 0;
        }
        
        .man-section-content .man-page-content {
            padding: 16px;
            background: #fafbfc;
            border: none;
            box-shadow: none;
            font-size: 13px;
        }

        /* Syntax highlighting */
        .man-page-content .section-header {
            font-weight: bold;
            color: #1967d2;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .man-page-content .option {
            color: #d73a49;
            font-weight: 600;
        }

        .man-page-content .command {
            color: #005cc5;
            font-weight: 600;
        }
        
        /* Bold and italic text in man pages */
        .man-page-content strong {
            font-weight: bold;
            color: #000;
        }
        
        .man-page-content em {
            font-style: italic;
            color: #333;
        }

        .man-page-content .example {
            background: #f6f8fa;
            border-left: 4px solid #1967d2;
            margin: 16px 0;
            padding: 12px 16px;
            border-radius: 4px;
        }



        .man-page-content .placeholder {
            color: #059669;
            font-style: italic;
        }

        .man-page-content .cross-ref {
            color: #1967d2;
            text-decoration: underline;
            cursor: pointer;
        }

        .man-page-content .cross-ref:hover {
            color: #0056b3;
        }

        /* History and bookmarks panel */
        .side-panel {
            position: fixed;
            right: -320px; /* Increased to ensure it's fully hidden */
            top: 0;
            width: 300px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 200;
            display: flex;
            visibility: hidden; /* Initially hidden */
            flex-direction: column;
        }

        .side-panel.open {
            right: 0;
            visibility: visible; /* Make visible when open */
        }

        .side-panel-header {
            padding: 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .side-panel-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
        }

        .side-panel-tab {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .side-panel-tab.active {
            color: #1967d2;
            border-bottom-color: #1967d2;
        }

        .side-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .side-panel-item {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .side-panel-item:hover {
            background: #f8f9fa;
        }

        .side-panel-item-command {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .side-panel-item-meta {
            font-size: 12px;
            color: #999;
        }

        /* Floating action buttons */
        .fab-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column-reverse;
            gap: 12px;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #1967d2;
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(25, 103, 210, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
        }

        .fab:hover {
            transform: scale(1.1);
            background: #1557b0;
            box-shadow: 0 6px 16px rgba(25, 103, 210, 0.4);
        }

        .fab.secondary {
            width: 48px;
            height: 48px;
            font-size: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .fab.secondary:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }

        /* Related commands */
        .related-commands {
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            padding: 20px 24px;
        }

        .related-commands h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #333;
        }

        .related-commands-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .related-command {
            background: white;
            border: 1px solid #ddd;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
            color: #1967d2;
            text-decoration: none;
            transition: all 0.2s;
            cursor: pointer;
        }

        .related-command:hover {
            background: #e8f0fe;
            border-color: #1967d2;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .loading-placeholder {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
            cursor: pointer;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #d93025;
        }

        .no-results {
            padding: 24px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            z-index: 300;
        }

        .status.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Clean, Basic Keyboard Shortcuts Modal */
        .shortcuts-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--shortcuts-bg, #232834);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 1200px;
            max-height: 85vh;
            z-index: 1000;
            display: none;
            overflow: hidden;
            border: 1px solid var(--shortcuts-border, #2d3444);
        }

        .shortcuts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 28px;
            background: var(--shortcuts-header-bg, #1f2430);
            border-bottom: 1px solid var(--shortcuts-border, #2d3444);
        }

        .shortcuts-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--shortcuts-title-color, #ffcc66);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shortcuts-header h3::before {
            content: '⌨️';
            font-size: 24px;
        }

        .close-button {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: var(--shortcuts-button-bg, rgba(45, 52, 68, 0.4));
            border: 1px solid var(--shortcuts-button-border, #33415e);
            color: var(--shortcuts-text, #cccac2);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-button:hover {
            background: var(--shortcuts-button-hover-bg, rgba(255, 204, 102, 0.1));
            color: var(--shortcuts-button-hover-color, #ffcc66);
            border-color: var(--shortcuts-button-hover-border, #ffcc66);
        }

        /* Removed search and categories */
        .shortcuts-search-bar,
        .shortcuts-categories {
            display: none;
        }

        /* Content area */
        .shortcuts-content {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(85vh - 80px);
            background: var(--shortcuts-bg, #232834);
        }

        .shortcuts-content::-webkit-scrollbar {
            width: 8px;
        }

        .shortcuts-content::-webkit-scrollbar-track {
            background: var(--shortcuts-scrollbar-track, #191e2a);
        }

        .shortcuts-content::-webkit-scrollbar-thumb {
            background: var(--shortcuts-scrollbar-thumb, #33415e);
            border-radius: 4px;
        }

        /* Grid layout for sections */
        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
        }

        .shortcut-section {
            background: var(--shortcuts-section-bg, rgba(31, 36, 48, 0.6));
            border-radius: 8px;
            padding: 20px;
            border: 1px solid var(--shortcuts-section-border, #2d3444);
        }

        .shortcut-section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--shortcuts-accent, #ffcc66);
        }

        .shortcut-section-icon {
            font-size: 20px;
        }

        .shortcut-section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--shortcuts-section-title, #cccac2);
        }

        /* Shortcut items */
        .shortcut-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--shortcuts-item-border, rgba(51, 65, 94, 0.2));
        }

        .shortcut-item:last-child {
            border-bottom: none;
        }

        .shortcut-description {
            color: var(--shortcuts-text, #cccac2);
            font-size: 14px;
            flex: 1;
        }

        .shortcut-keys {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .shortcut-item kbd {
            background: var(--shortcuts-kbd-bg, rgba(115, 208, 255, 0.15));
            border: 1px solid var(--shortcuts-kbd-border, #73d0ff);
            border-radius: 4px;
            padding: 3px 8px;
            font-family: monospace;
            font-size: 12px;
            font-weight: 500;
            color: var(--shortcuts-kbd-color, #73d0ff);
            min-width: 24px;
            text-align: center;
            box-shadow: 0 0 5px var(--shortcuts-kbd-shadow, rgba(115, 208, 255, 0.2));
        }

        .shortcut-plus {
            color: var(--shortcuts-plus-color, #607080);
            font-size: 11px;
            margin: 0 2px;
        }



        /* Responsive adjustments */
        @media (max-width: 768px) {
            .shortcuts-help {
                width: 100%;
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
            }
            
            .shortcuts-header {
                padding: 24px;
            }
            
            .shortcuts-search-bar,
            .shortcuts-categories,
            .shortcuts-content {
                padding-left: 24px;
                padding-right: 24px;
            }
            
            .shortcuts-grid {
                grid-template-columns: 1fr;
            }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 399;
            display: none;
        }

        /* Revamped Theme Modal with Live Previews */
        .theme-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            z-index: 500;
            display: none;
            overflow: hidden;
            color: #333;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .theme-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 28px;
            border-bottom: 1px solid #e0e0e0;
            background: linear-gradient(to bottom, #ffffff, #f8f9fa);
        }

        .theme-modal-header h3 {
            margin: 0;
            font-size: 24px;
            color: #1a1a1a;
            font-weight: 600;
        }

        /* Theme search and filter bar */
        .theme-filter-bar {
            padding: 16px 28px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .theme-search-input {
            flex: 1;
            padding: 10px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: all 0.2s ease;
        }

        .theme-search-input:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
        }

        .theme-category-filter {
            display: flex;
            gap: 8px;
        }

        .theme-filter-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            background: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .theme-filter-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        .theme-filter-btn.active {
            background: #4285f4;
            color: white;
            border-color: #4285f4;
        }

        .theme-modal-content {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(90vh - 160px);
            background: #f5f5f5;
        }

        .theme-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
        }

        /* Enhanced theme option card */
        .theme-option {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 2px solid transparent;
        }

        .theme-option:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        }

        .theme-option.active {
            border-color: #4285f4;
            box-shadow: 0 8px 24px rgba(66, 133, 244, 0.25);
        }

        .theme-option-header {
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        .theme-option-icon {
            font-size: 28px;
            filter: none !important;
        }

        .theme-option-info {
            flex: 1;
        }

        .theme-option-name {
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a !important;
            margin-bottom: 2px;
        }

        .theme-option-description {
            font-size: 12px;
            color: #666 !important;
        }

        .theme-option.active .theme-option-header {
            background: #e8f0fe;
        }

        /* Live terminal preview */
        .theme-preview-terminal {
            height: 200px;
            position: relative;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow: hidden;
        }

        .preview-terminal-header {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .preview-terminal-dots {
            display: flex;
            gap: 6px;
        }

        .preview-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0.8;
        }

        .preview-terminal-content {
            padding: 12px;
            height: calc(100% - 32px);
            overflow: hidden;
        }

        .preview-prompt {
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .preview-command {
            font-weight: 600;
        }

        .preview-section {
            margin-top: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preview-option {
            margin-left: 16px;
            margin-top: 4px;
        }

        .preview-description {
            margin-left: 32px;
            opacity: 0.8;
            font-size: 10px;
        }

        /* Active indicator */
        .theme-option.active::after {
            content: '✓';
            position: absolute;
            top: 12px;
            right: 12px;
            background: #4285f4;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(66, 133, 244, 0.3);
        }

        /* Theme tags */
        .theme-tags {
            position: absolute;
            bottom: 12px;
            left: 16px;
            display: flex;
            gap: 6px;
        }

        .theme-tag {
            padding: 4px 8px;
            background: rgba(0,0,0,0.06);
            border-radius: 12px;
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Consistent preview styling */
        .theme-option-preview > div {
            flex: 1;
            min-height: 0;
        }
        
        /* Ensure close button stays consistent */
        .theme-modal .close-button {
            background: transparent !important;
            border: 1px solid #999 !important;
            color: #666 !important;
            padding: 4px 12px !important;
            border-radius: 4px !important;
            font-size: 14px !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }
        
        .theme-modal .close-button:hover {
            background: #f0f0f0 !important;
            border-color: #666 !important;
            color: #333 !important;
        }

        @media (max-width: 1024px) {
            .content-wrapper {
                flex-direction: column;
            }

            .section-nav {
                width: 100%;
                position: static;
                max-height: none;
                margin-bottom: 20px;
            }
        }

        @media (max-width: 600px) {
            .logo {
                font-size: 36px;
            }

            .search-active .logo {
                font-size: 24px;
            }

            .search-box {
                flex-direction: column;
                border-radius: 12px;
            }

            .section-select {
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                width: 100%;
                border-radius: 8px 8px 0 0;
                margin-bottom: 0;
            }

            .search-input {
                padding: 16px;
            }

            .search-button {
                padding: 16px;
            }

            .man-page-content {
                font-size: 12px;
                padding: 16px;
            }

            .fab-container {
                bottom: 10px;
                right: 10px;
            }

            .fab {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }

            .fab.secondary {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                transition: none !important;
            }
        }

        /* Theme styles are now in separate CSS files */

        /* TLDR Section Styles */
        .tldr-section {
            background: #f0f8ff;
            border-top: 1px solid #e0e0e0;
            padding: 20px 24px;
        }

        .tldr-section h4 {
            color: #0066cc;
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
        }

        .tldr-content {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .tldr-description {
            color: #666;
            margin-bottom: 20px;
            font-style: italic;
            font-size: 14px;
        }

        .tldr-examples h5 {
            color: #333;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
        }

        .tldr-example {
            margin-bottom: 20px;
            padding: 12px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #0066cc;
        }

        .example-description {
            color: #555;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .example-code {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .tldr-placeholder {
            color: #e91e63;
            font-weight: bold;
            background: #fce4ec;
            padding: 0 4px;
            border-radius: 3px;
        }

        .tldr-option {
            color: #ff5722;
            font-weight: 600;
        }

        .no-tldr {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .tldr-loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .theme-icon {
            font-size: 24px;
            transition: transform 0.3s ease;
        }
        
        .theme-toggle:hover .theme-icon {
            transform: rotate(30deg);
        }
        
        
        
        /* Theme icon adjustments */
        .theme-name {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        
        .theme-toggle:hover .theme-name {
            opacity: 1;
        }

        /* Command Explainer Styles */
        .command-explainer-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            z-index: 500;
            display: none;
            overflow: hidden;
            color: #333;
            border: none;
        }
        
        /* Responsive sizing for very long commands */
        @media (min-width: 1400px) {
            .command-explainer-modal {
                max-width: 1400px;
            }
        }

        .command-explainer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: white;
        }

        .command-explainer-header h3 {
            margin: 0;
            font-size: 20px;
            color: #333;
            text-shadow: none;
        }

        .command-explainer-content {
            padding: 20px;
            overflow-y: auto;
            overflow-x: visible;
            max-height: calc(90vh - 80px);
            background: white;
            position: relative;
        }

        .command-input-container {
            margin-bottom: 24px;
        }

        .command-input {
            width: 100%;
            padding: 14px 18px;
            font-size: 16px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
            background: #f8f9fa;
            color: #333;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            min-height: 50px;
            max-height: 150px;
            overflow-y: auto;
            resize: vertical;
        }

        .command-input:focus {
            border-color: #4285f4;
        }
        

        .command-breakdown {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            padding-top: 50px; /* Extra space for tooltips above */
            padding-bottom: 30px; /* Extra space for tooltips below */
            margin-bottom: 20px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            min-height: 60px;
            max-height: none; /* Remove height restriction */
            overflow: visible; /* Allow tooltips to show */
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
        }
        

        .command-token {
            display: inline-flex;
            align-items: center;
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            position: relative;
            cursor: help;
            transition: all 0.2s ease;
            max-width: 400px;
            overflow: visible; /* Changed from hidden to allow tooltips */
            user-select: none;
            -webkit-user-select: none;
        }

        .command-token > span {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .command-token:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .command-token:hover > span {
            overflow: visible;
            white-space: normal;
            word-break: break-all;
        }

        .command-token.command {
            background: var(--token-command-bg, #e3f2fd);
            color: var(--token-command-color, #1565c0);
            border: 1px solid var(--token-command-border, #bbdefb);
        }
        
        .command-token.subcommand {
            background: var(--token-subcommand-bg, #f3e5f5);
            color: var(--token-subcommand-color, #7b1fa2);
            border: 1px solid var(--token-subcommand-border, #e1bee7);
            font-weight: 500;
        }

        .command-token.option {
            background: var(--token-option-bg, #f3e5f5);
            color: var(--token-option-color, #6a1b9a);
            border: 1px solid var(--token-option-border, #e1bee7);
        }

        .command-token.argument {
            background: var(--token-argument-bg, #e8f5e9);
            color: var(--token-argument-color, #2e7d32);
            border: 1px solid var(--token-argument-border, #c8e6c9);
        }

        .command-token.pipe,
        .command-token.pipe-both,
        .command-token.and,
        .command-token.or,
        .command-token.semicolon,
        .command-token.background,
        .command-token.case-end {
            background: var(--token-operator-bg, #fff3e0);
            color: var(--token-operator-color, #e65100);
            border: 1px solid var(--token-operator-border, #ffe0b2);
        }

        .command-token.redirect,
        .command-token.redirect-out,
        .command-token.redirect-in,
        .command-token.redirect-append,
        .command-token.redirect-err,
        .command-token.redirect-err-append,
        .command-token.redirect-err-to-out,
        .command-token.redirect-both,
        .command-token.redirect-both-append,
        .command-token.redirect-read-write,
        .command-token.redirect-force,
        .command-token.redirect-out-to-err,
        .command-token.here-doc,
        .command-token.here-doc-indent,
        .command-token.here-string {
            background: var(--token-redirect-bg, #fce4ec);
            color: var(--token-redirect-color, #c2185b);
            border: 1px solid var(--token-redirect-border, #f8bbd0);
        }
        
        .command-token.keyword {
            background: var(--token-argument-bg, #e8f5e9);
            color: var(--token-argument-color, #2e7d32);
            border: 1px solid var(--token-argument-border, #c8e6c9);
            font-weight: 600;
        }
        
        .command-token.process-substitution {
            background: var(--token-expansion-bg, #f3e5f5);
            color: var(--token-expansion-color, #5e35b1);
            border: 1px solid var(--token-expansion-border, #d1c4e9);
        }
        
        .command-token.substitution {
            background: var(--token-expansion-bg, #e0f2f1);
            color: var(--token-expansion-color, #00695c);
            border: 1px solid var(--token-expansion-border, #b2dfdb);
        }
        
        .command-token.special {
            background: var(--token-special-bg, #fafafa);
            color: var(--token-special-color, #424242);
            border: 1px solid var(--token-special-border, #e0e0e0);
            font-weight: 600;
        }

        .command-token.unknown {
            background: var(--token-special-bg, #fafafa);
            color: var(--token-special-color, #616161);
            border: 1px solid var(--token-special-border, #e0e0e0);
        }

        .command-token.variable {
            background: var(--token-variable-bg, #e1f5fe);
            color: var(--token-variable-color, #0277bd);
            border: 1px solid var(--token-variable-border, #b3e5fc);
            font-style: italic;
        }

        .command-token.variable-assignment {
            background: var(--token-variable-bg, #e8f5e9);
            color: var(--token-variable-color, #2e7d32);
            border: 1px solid var(--token-variable-border, #c8e6c9);
        }

        .command-token.arithmetic {
            background: var(--token-expansion-bg, #fff3e0);
            color: var(--token-expansion-color, #e65100);
            border: 1px solid var(--token-expansion-border, #ffe0b2);
            font-family: monospace;
        }

        .command-token.tilde {
            background: var(--token-expansion-bg, #f3e5f5);
            color: var(--token-expansion-color, #6a1b9a);
            border: 1px solid var(--token-expansion-border, #e1bee7);
        }

        .command-token.ansi-c-quote {
            background: var(--token-expansion-bg, #e0f2f1);
            color: var(--token-expansion-color, #00695c);
            border: 1px solid var(--token-expansion-border, #b2dfdb);
        }

        .token-tooltip {
            position: fixed; /* Changed to fixed for viewport positioning */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 400;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            max-width: 300px;
            min-width: 150px;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.5;
            z-index: 2147483647; /* Maximum z-index to ensure tooltip is always on top */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            animation: tooltipFadeIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }
        
        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .command-token:hover .token-tooltip {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .token-tooltip::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border: 6px solid transparent;
        }
        
        /* Arrow pointing down (tooltip above) */
        .token-tooltip:not(.tooltip-below):not(.tooltip-left):not(.tooltip-right)::before {
            top: 100%;
            border-top-color: #16213e;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }
        
        /* Arrow pointing up (tooltip below) */
        .token-tooltip.tooltip-below::before {
            bottom: 100%;
            border-bottom-color: #1a1a2e;
            filter: drop-shadow(0 -2px 4px rgba(0, 0, 0, 0.2));
        }
        
        /* Arrow pointing left (tooltip on right) */
        .token-tooltip.tooltip-right::before {
            right: 100%;
            top: 50%;
            left: auto;
            transform: translateY(-50%);
            border-right-color: #1a1a2e;
        }
        
        /* Arrow pointing right (tooltip on left) */
        .token-tooltip.tooltip-left::before {
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            border-left-color: #16213e;
        }
        
        /* Centered tooltip (last resort) */
        .token-tooltip.tooltip-centered {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4), 0 0 0 2px rgba(255, 255, 255, 0.2);
            max-width: 400px;
        }
        
        .token-tooltip.tooltip-centered::before {
            display: none; /* Hide arrow for centered tooltips */
        }

        .command-explanations {
            margin-top: 24px;
        }

        .explanation-section {
            margin-bottom: 20px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        .explanation-header {
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .explanation-header:hover {
            background: #f0f1f3;
        }

        .explanation-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.2s;
        }

        .explanation-section.collapsed .explanation-header::after {
            transform: rotate(-90deg);
        }

        .explanation-content {
            padding: 16px;
            overflow-x: auto;
            transition: all 0.3s ease;
        }

        .explanation-section.collapsed .explanation-content {
            max-height: 0;
            padding: 0 16px;
            overflow: hidden;
        }

        /* Ensure options list and examples sections expand to show all content */
        .explanation-section:not(.collapsed) .explanation-content {
            max-height: none;
            overflow-y: visible;
        }

        /* Remove any height restrictions from options list */
        .options-list {
            max-height: none;
            overflow: visible;
        }

        .option-item {
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .option-item:last-child {
            border-bottom: none;
        }

        .option-name {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            color: #6a1b9a;
            margin-bottom: 4px;
            word-break: break-all;
        }

        .option-description {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .example-command {
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            margin-top: 12px;
            border: 1px solid #e0e0e0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .no-explanation {
            text-align: center;
            color: #666;
            padding: 40px;
            font-style: italic;
        }

        /* Override theme styles for command explainer tooltips */
        .command-explainer-modal .token-tooltip {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%) !important;
            color: #ffffff !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
        }
        
        /* Enhanced token colors for better visibility */
        .command-explainer-modal .command-token.command {
            background: linear-gradient(135deg, #e3f2fd 0%, #d1e9fc 100%);
            border: 1px solid #90caf9;
        }
        
        .command-explainer-modal .command-token.option {
            background: linear-gradient(135deg, #f3e5f5 0%, #e8d4eb 100%);
            border: 1px solid #ce93d8;
        }
        
        .command-explainer-modal .command-token.argument {
            background: linear-gradient(135deg, #e8f5e9 0%, #d4edd5 100%);
            border: 1px solid #81c784;
        }
        
        .command-explainer-modal .command-token.pipe,
        .command-explainer-modal .command-token.redirect {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe8cc 100%);
            border: 1px solid #ffb74d;
        }
        
        
        /* Better tooltip typography */
        .token-tooltip {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            letter-spacing: 0.3px;
        }

    </style>
<style id="skeleton-styles">
                        .skeleton {
                            animation: skeleton-loading 1.5s infinite;
                            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
                            background-size: 200% 100%;
                            border-radius: 4px;
                        }
                        
                        @keyframes skeleton-loading {
                            0% { background-position: -200% 0; }
                            100% { background-position: 200% 0; }
                        }
                        
                        .skeleton-line {
                            height: 16px;
                            margin-bottom: 8px;
                            border-radius: 4px;
                        }
                        
                        .skeleton-line.title { height: 24px; width: 60%; }
                        .skeleton-line.subtitle { height: 18px; width: 40%; }
                        .skeleton-line.short { width: 80%; }
                        .skeleton-line.medium { width: 90%; }
                        .skeleton-line.long { width: 95%; }
                        
                        .skeleton-search-result {
                            padding: 12px 16px;
                            border-bottom: 1px solid #f0f0f0;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                        }
                        
                        .skeleton-search-result .skeleton-info {
                            flex: 1;
                        }
                        
                        .skeleton-search-result .skeleton-badge {
                            width: 24px;
                            height: 24px;
                            border-radius: 12px;
                            margin-left: 16px;
                        }
                        
                        .skeleton-manpage-content {
                            padding: 20px;
                        }
                        
                        .skeleton-manpage-content .skeleton-header {
                            margin-bottom: 20px;
                        }
                        
                        .skeleton-manpage-content .skeleton-section {
                            margin-bottom: 16px;
                        }
                        
                        .loading-overlay {
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(255, 255, 255, 0.8);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            z-index: 1000;
                            backdrop-filter: blur(2px);
                        }
                        
                        .loading-spinner {
                            width: 32px;
                            height: 32px;
                            border: 3px solid #f3f3f3;
                            border-top: 3px solid #4285f4;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                        }
                        
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                        
                        .fade-in {
                            animation: fadeIn 0.3s ease-in;
                        }
                        
                        @keyframes fadeIn {
                            from { opacity: 0; transform: translateY(10px); }
                            to { opacity: 1; transform: translateY(0); }
                        }
                    </style><style id="theme-performance-styles">/* Ayu Mirage Theme */
/* A sophisticated dark theme with warm colors and excellent readability
   Part of the popular Ayu theme family, Mirage variant offers perfect balance
   Features orange accents, soft blues, and warm grays
*/

/* Ayu Mirage Color Palette:
   Background:
   bg: #1f2430 (main background)
   bg_dark: #191e2a (darker background)
   bg_highlight: #232834 (highlighted background)
   panel_bg: #232834 (panel background)
   panel_shadow: #141925 (shadow color)
   
   Foreground:
   fg: #cccac2 (main text)
   fg_idle: #607080 (idle/muted text)
   fg_accent: #ffcc66 (accent text)
   
   UI Colors:
   ui_bg: #1f2430 (ui background)
   ui_highlight: #2d3444 (ui highlight)
   ui_selection: #33415e (selection)
   ui_cursor: #ffcc66 (cursor)
   
   Syntax Colors:
   orange: #ffad66 (keywords, constants)
   yellow: #ffd173 (strings)
   green: #d5ff80 (functions)
   cyan: #73d0ff (types, classes)
   blue: #5ccfe6 (variables)
   purple: #dfbfff (interfaces)
   red: #ff6666 (errors)
   
   Special:
   accent: #ffcc66 (main accent)
   keyword: #ffad66 (keywords)
   func: #ffd173 (functions)
   entity: #73d0ff (entities)
   string: #d5ff80 (strings)
   constant: #dfbfff (constants)
   operator: #f29e74 (operators)
   error: #ff3333 (errors)
   warning: #ffcc66 (warnings)
   info: #5ccfe6 (info)
   success: #95e6cb (success)
*/

body.ayu-mirage {
    background: linear-gradient(135deg, #191e2a 0%, #1f2430 50%, #232834 100%);
    min-height: 100vh;
    color: #cccac2;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
}

/* Main containers */
body.ayu-mirage .content-wrapper,
body.ayu-mirage .section-nav,
body.ayu-mirage .man-page-container,
body.ayu-mirage .side-panel,
body.ayu-mirage .shortcuts-help {
    background: rgba(31, 36, 48, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid #2d3444;
    border-radius: 8px;
    box-shadow: 
        0 8px 32px rgba(20, 25, 37, 0.4),
        0 0 0 1px rgba(255, 204, 102, 0.05);
}

body.ayu-mirage .man-page-header {
    background: linear-gradient(90deg, #232834 0%, #2d3444 100%);
    border-bottom: 2px solid #ffcc66;
    border-radius: 8px 8px 0 0;
    box-shadow: 0 2px 20px rgba(255, 204, 102, 0.1);
}

body.ayu-mirage .side-panel-header {
    background: #232834;
    border-bottom: 2px solid #ffcc66;
    border-radius: 8px 8px 0 0;
}

/* Text colors */
body.ayu-mirage .logo {
    color: #ffcc66;
    text-shadow: 
        0 0 20px rgba(255, 204, 102, 0.4),
        0 0 40px rgba(255, 204, 102, 0.2);
    font-weight: 600;
}

body.ayu-mirage .container {
    color: #cccac2;
}

body.ayu-mirage .man-page-title,
body.ayu-mirage .section-nav h3,
body.ayu-mirage .shortcuts-help h3,
body.ayu-mirage .related-commands h4 {
    color: #73d0ff;
    text-shadow: 0 0 10px rgba(115, 208, 255, 0.3);
    font-weight: 600;
}

body.ayu-mirage .close-button,
body.ayu-mirage .action-button {
    color: #cccac2;
    background: rgba(45, 52, 68, 0.4);
    border: 1px solid #33415e;
    border-radius: 6px;
    transition: all 0.2s ease;
}

body.ayu-mirage .close-button:hover,
body.ayu-mirage .action-button:hover {
    color: #ffcc66;
    background: rgba(255, 204, 102, 0.1);
    border-color: #ffcc66;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.2);
}

body.ayu-mirage .action-button.active {
    background: rgba(115, 208, 255, 0.15);
    color: #73d0ff;
    border-color: #73d0ff;
    box-shadow: 0 0 20px rgba(115, 208, 255, 0.3);
}

/* Man page content */
body.ayu-mirage .man-page-content {
    background: rgba(25, 30, 42, 0.8);
    color: #cccac2;
    border: 1px solid #2d3444;
    border-radius: 6px;
}

body.ayu-mirage .man-page-content .section-header {
    color: #ffd173;
    font-weight: 600;
    text-shadow: 0 0 8px rgba(255, 209, 115, 0.3);
    border-bottom: 1px solid rgba(255, 209, 115, 0.2);
    margin-bottom: 12px;
    padding-bottom: 8px;
}

body.ayu-mirage .man-page-content .option {
    color: #ffad66;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(255, 173, 102, 0.2);
}

body.ayu-mirage .man-page-content .command {
    color: #5ccfe6;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(92, 207, 230, 0.2);
}

body.ayu-mirage .man-page-content .example {
    background: rgba(45, 52, 68, 0.3);
    border-left: 3px solid #95e6cb;
    border-radius: 4px;
    box-shadow: inset 0 0 20px rgba(149, 230, 203, 0.05);
}

body.ayu-mirage .man-page-content strong {
    color: #d5ff80;
    font-weight: 600;
    text-shadow: 0 0 3px rgba(213, 255, 128, 0.3);
}

body.ayu-mirage .man-page-content .cross-ref {
    color: #73d0ff;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.3);
}

body.ayu-mirage .man-page-content em {
    color: #607080;
    font-style: italic;
}

/* Suggestions */
body.ayu-mirage .suggestions {
    background: rgba(35, 40, 52, 0.95);
    border: 1px solid #33415e;
    border-radius: 8px;
    box-shadow: 
        0 8px 32px rgba(20, 25, 37, 0.6),
        0 0 0 1px rgba(255, 204, 102, 0.1);
}

body.ayu-mirage .suggestion {
    border-bottom: 1px solid rgba(51, 65, 94, 0.3);
    color: #cccac2;
}

body.ayu-mirage .suggestion:hover,
body.ayu-mirage .suggestion.selected {
    background: rgba(255, 204, 102, 0.1);
    border-left: 3px solid #ffcc66;
    box-shadow: inset 0 0 20px rgba(255, 204, 102, 0.05);
}

body.ayu-mirage .suggestion-command {
    color: #73d0ff;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .suggestion-desc {
    color: #607080;
}

body.ayu-mirage .section-badge {
    background: rgba(115, 208, 255, 0.15);
    color: #73d0ff;
    border: 1px solid rgba(115, 208, 255, 0.3);
    border-radius: 12px;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(115, 208, 255, 0.3);
}

/* Navigation */
body.ayu-mirage .section-nav {
    background: rgba(31, 36, 48, 0.9);
    border-right: 1px solid #2d3444;
    border-radius: 8px 0 0 8px;
}

body.ayu-mirage .section-nav::-webkit-scrollbar-track {
    background: #191e2a;
}

body.ayu-mirage .section-nav::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #33415e 0%, #2d3444 100%);
    border-radius: 4px;
    box-shadow: 0 0 5px rgba(51, 65, 94, 0.3);
}

body.ayu-mirage .section-nav::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #607080 0%, #33415e 100%);
}

body.ayu-mirage .section-nav h3 {
    background: #232834;
    color: #ffcc66;
    border-bottom: 1px solid rgba(255, 204, 102, 0.2);
    font-weight: 600;
    text-shadow: 0 0 10px rgba(255, 204, 102, 0.2);
    border-radius: 8px 0 0 0;
}

body.ayu-mirage .nav-section-header {
    color: #cccac2;
    transition: all 0.2s ease;
}

body.ayu-mirage .nav-section-header:hover {
    background: rgba(115, 208, 255, 0.1);
    border-left: 3px solid #73d0ff;
}

body.ayu-mirage .nav-section-header.active {
    background: rgba(255, 204, 102, 0.15);
    color: #ffcc66;
    border-left: 3px solid #ffcc66;
    box-shadow: inset 0 0 20px rgba(255, 204, 102, 0.1);
}

body.ayu-mirage .nav-section-icon {
    background: rgba(115, 208, 255, 0.2);
    color: #73d0ff;
    border-radius: 4px;
    box-shadow: 0 0 10px rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .nav-section-header.active .nav-section-icon {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%);
    color: #1f2430;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.4);
}

body.ayu-mirage .nav-sub-list {
    background: rgba(25, 30, 42, 0.5);
    border-left: 1px solid rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .nav-sub-list a {
    color: #607080;
}

body.ayu-mirage .nav-sub-list a:hover {
    color: #ffcc66;
    text-shadow: 0 0 5px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .nav-sub-list a.active {
    color: #d5ff80;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(213, 255, 128, 0.3);
}

body.ayu-mirage .nav-sub-list a.active::before {
    background: #d5ff80;
    box-shadow: 0 0 10px rgba(213, 255, 128, 0.5);
}

/* Collapsible sections */
body.ayu-mirage .man-section {
    background: rgba(31, 36, 48, 0.6);
    border: 1px solid #2d3444;
    border-radius: 6px;
}

body.ayu-mirage .man-section:hover {
    border-color: #33415e;
    box-shadow: 0 0 20px rgba(51, 65, 94, 0.2);
}

body.ayu-mirage .man-section-header {
    background: rgba(35, 40, 52, 0.8);
    border-radius: 6px 6px 0 0;
}

body.ayu-mirage .man-section-title {
    color: #ffd173;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(255, 209, 115, 0.2);
}

body.ayu-mirage .collapse-icon {
    color: #607080;
}

body.ayu-mirage .man-section-content {
    background: rgba(25, 30, 42, 0.3);
}

/* TLDR Section */
body.ayu-mirage .tldr-section {
    background: linear-gradient(180deg, rgba(25, 30, 42, 0.9) 0%, rgba(45, 52, 68, 0.3) 100%);
    border-top: 2px solid #95e6cb;
    border-radius: 0 0 6px 6px;
    box-shadow: 0 -5px 20px rgba(149, 230, 203, 0.1);
}

body.ayu-mirage .tldr-section h4 {
    color: #95e6cb;
    font-weight: 600;
    text-shadow: 0 0 15px rgba(149, 230, 203, 0.4);
}

body.ayu-mirage .tldr-examples h5 {
    color: #73d0ff;
    font-weight: 500;
}

body.ayu-mirage .tldr-description {
    color: #cccac2;
}

body.ayu-mirage .tldr-example {
    background: rgba(45, 52, 68, 0.3);
    border-left: 3px solid #d5ff80;
    border-radius: 4px;
    box-shadow: inset 0 0 20px rgba(213, 255, 128, 0.05);
}

body.ayu-mirage .example-code {
    background: rgba(25, 30, 42, 0.8);
    color: #5ccfe6;
    border: 1px solid #2d3444;
    border-radius: 4px;
    text-shadow: 0 0 2px rgba(92, 207, 230, 0.2);
}

body.ayu-mirage .example-description {
    color: #607080;
}

body.ayu-mirage .tldr-placeholder {
    background: rgba(213, 255, 128, 0.2);
    color: #d5ff80;
    border: 1px solid rgba(213, 255, 128, 0.3);
    border-radius: 3px;
    padding: 0 4px;
    box-shadow: 0 0 5px rgba(213, 255, 128, 0.2);
}

body.ayu-mirage .tldr-option {
    color: #ffad66;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(255, 173, 102, 0.2);
}

/* Other elements */
body.ayu-mirage .shortcuts-help-content {
    color: #cccac2;
}

body.ayu-mirage .shortcut-item {
    border-bottom: 1px solid rgba(51, 65, 94, 0.2);
    color: #cccac2;
}

body.ayu-mirage .shortcut-description {
    color: #cccac2 !important;
    opacity: 0.9;
}

body.ayu-mirage .shortcut-key {
    background: rgba(115, 208, 255, 0.15);
    border: 1px solid #73d0ff;
    color: #73d0ff;
    border-radius: 4px;
    font-weight: 500;
    box-shadow: 0 0 5px rgba(115, 208, 255, 0.2);
}

body.ayu-mirage .loading {
    color: #607080;
}

body.ayu-mirage .error {
    background: rgba(255, 102, 102, 0.15);
    color: #ff6666;
    border-radius: 6px;
    box-shadow: 0 0 20px rgba(255, 102, 102, 0.2);
}

/* Related commands */
body.ayu-mirage .related-commands {
    background: rgba(31, 36, 48, 0.6);
    border: 1px solid #2d3444;
    border-radius: 6px;
}

body.ayu-mirage .related-commands a {
    background: rgba(115, 208, 255, 0.1);
    color: #73d0ff;
    border: 1px solid rgba(115, 208, 255, 0.3);
    border-radius: 4px;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.2);
    transition: all 0.2s ease;
}

body.ayu-mirage .related-commands a:hover {
    background: rgba(115, 208, 255, 0.2);
    box-shadow: 0 0 15px rgba(115, 208, 255, 0.3);
    transform: translateY(-1px);
}

/* Search in page */
body.ayu-mirage .search-in-page {
    background: rgba(35, 40, 52, 0.95);
    border-bottom: 2px solid #ffcc66;
}

body.ayu-mirage .search-in-page input {
    background: rgba(25, 30, 42, 0.8);
    border: 1px solid #33415e;
    color: #cccac2;
    border-radius: 4px;
}

body.ayu-mirage .search-in-page input:focus {
    border-color: #ffcc66;
    box-shadow: 0 0 10px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .search-in-page button {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%);
    color: #1f2430;
    border-radius: 4px;
    font-weight: 500;
    box-shadow: 0 0 10px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .search-in-page button:hover {
    background: linear-gradient(135deg, #d5ff80 0%, #95e6cb 100%);
    box-shadow: 0 0 15px rgba(213, 255, 128, 0.4);
}

body.ayu-mirage .highlight {
    background: rgba(255, 209, 115, 0.3);
    color: #1f2430;
    border-radius: 2px;
    box-shadow: 0 0 8px rgba(255, 209, 115, 0.3);
}

body.ayu-mirage .highlight.current {
    background: rgba(213, 255, 128, 0.4);
    color: #1f2430;
    box-shadow: 0 0 12px rgba(213, 255, 128, 0.4);
}

/* Theme toggle button */
body.ayu-mirage .theme-toggle {
    background: rgba(255, 204, 102, 0.1);
    border: 2px solid #ffcc66;
    border-radius: 50%;
    box-shadow: 0 0 20px rgba(255, 204, 102, 0.2);
}

body.ayu-mirage .theme-toggle:hover {
    background: rgba(255, 204, 102, 0.2);
    box-shadow: 0 0 30px rgba(255, 204, 102, 0.4);
    transform: scale(1.1);
}

/* Side panel tabs */
body.ayu-mirage .side-panel-tab {
    color: #607080;
    transition: all 0.2s ease;
}

body.ayu-mirage .side-panel-tab.active {
    color: #ffcc66;
    border-bottom: 2px solid #ffcc66;
    text-shadow: 0 0 5px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .side-panel-tabs {
    border-bottom: 1px solid rgba(51, 65, 94, 0.2);
    background: rgba(35, 40, 52, 0.8);
}

body.ayu-mirage .side-panel-content {
    background: rgba(31, 36, 48, 0.9);
    border: 1px solid #2d3444;
}

body.ayu-mirage .side-panel-item {
    border-bottom: 1px solid rgba(51, 65, 94, 0.1);
    color: #cccac2;
    transition: all 0.2s ease;
}

body.ayu-mirage .side-panel-item:hover {
    background: rgba(255, 204, 102, 0.05);
}

body.ayu-mirage .side-panel-item-command {
    color: #73d0ff;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(115, 208, 255, 0.2);
}

/* Side panel header styling */
body.ayu-mirage .side-panel-header h3 {
    color: #cccac2 !important;
    font-weight: 600 !important;
    text-shadow: 0 0 10px rgba(204, 202, 194, 0.2);
}

/* Search bar styling */
body.ayu-mirage .search-input {
    background: #191e2a;
    color: #cccac2;
    border: 1px solid #33415e;
    border-radius: 8px;
}

body.ayu-mirage .search-input::placeholder {
    color: #607080;
}

body.ayu-mirage .search-input:focus {
    border-color: #ffcc66;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .search-button {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%);
    color: #1f2430;
    border-radius: 8px;
    font-weight: 500;
    box-shadow: 0 0 15px rgba(255, 204, 102, 0.3);
    transition: all 0.2s ease;
}

body.ayu-mirage .search-button:hover {
    background: linear-gradient(135deg, #73d0ff 0%, #5ccfe6 100%);
    box-shadow: 0 0 20px rgba(115, 208, 255, 0.4);
    transform: translateY(-1px);
}

body.ayu-mirage .section-select {
    background: #191e2a;
    color: #cccac2;
    border: 1px solid #33415e;
    border-radius: 8px;
}

/* Command Explainer styling */
body.ayu-mirage .command-explainer-modal {
    background: rgba(31, 36, 48, 0.95);
    color: #cccac2;
    border: 1px solid #33415e;
    border-radius: 12px;
    box-shadow: 
        0 20px 40px rgba(20, 25, 37, 0.8),
        0 0 0 1px rgba(255, 204, 102, 0.1);
    backdrop-filter: blur(12px);
}

body.ayu-mirage .command-explainer-header {
    background: rgba(35, 40, 52, 0.8);
    border-bottom: 1px solid #2d3444;
    border-radius: 12px 12px 0 0;
}

body.ayu-mirage .command-explainer-header h3 {
    color: #ffcc66;
    font-weight: 600;
    text-shadow: 0 0 10px rgba(255, 204, 102, 0.3);
}

body.ayu-mirage .command-explainer-content {
    background: transparent;
}

body.ayu-mirage .command-input {
    background: rgba(25, 30, 42, 0.8);
    color: #cccac2;
    border: 2px solid #33415e;
    border-radius: 8px;
    box-shadow: inset 0 0 20px rgba(25, 30, 42, 0.5);
}

body.ayu-mirage .command-input:focus {
    border-color: #ffcc66;
    box-shadow: 
        0 0 20px rgba(255, 204, 102, 0.3),
        inset 0 0 20px rgba(25, 30, 42, 0.5);
}

body.ayu-mirage .command-breakdown {
    background: rgba(25, 30, 42, 0.4);
    border: 1px solid #2d3444;
    border-radius: 8px;
}

body.ayu-mirage .command-token.command {
    background: linear-gradient(135deg, #2d3444 0%, #33415e 100%);
    color: #73d0ff;
    border: 1px solid #5ccfe6;
    border-radius: 4px;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(115, 208, 255, 0.3);
}

body.ayu-mirage .command-token.option {
    background: linear-gradient(135deg, #33415e 0%, #607080 100%);
    color: #ffad66;
    border: 1px solid #ff8800;
    border-radius: 4px;
    font-weight: 500;
    text-shadow: 0 0 5px rgba(255, 173, 102, 0.3);
}

body.ayu-mirage .command-token.argument {
    background: rgba(213, 255, 128, 0.15);
    color: #d5ff80;
    border: 1px solid #95e6cb;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .command-token.pipe {
    background: rgba(255, 102, 102, 0.15);
    color: #ff6666;
    border: 1px solid #ff3333;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .command-token.redirect {
    background: rgba(223, 191, 255, 0.15);
    color: #dfbfff;
    border: 1px solid #cba6f7;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .command-token.unknown {
    background: rgba(96, 112, 128, 0.15);
    color: #607080;
    border: 1px solid #607080;
    border-radius: 4px;
    font-weight: 500;
}

body.ayu-mirage .explanation-section {
    background: rgba(35, 40, 52, 0.6);
    border: 1px solid #2d3444;
    border-radius: 8px;
}

body.ayu-mirage .explanation-header {
    background: rgba(25, 30, 42, 0.8);
    border-bottom: 1px solid #2d3444;
    color: #607080;
    border-radius: 8px 8px 0 0;
}

body.ayu-mirage .explanation-header:hover {
    background: rgba(115, 208, 255, 0.1);
    color: #ffcc66;
}

body.ayu-mirage .option-name {
    color: #ffad66;
    font-weight: 500;
    text-shadow: 0 0 3px rgba(255, 173, 102, 0.3);
}

body.ayu-mirage .option-description {
    color: #607080;
}

body.ayu-mirage .example-command {
    background: rgba(25, 30, 42, 0.8);
    border: 1px solid #2d3444;
    color: #5ccfe6;
    border-radius: 4px;
    font-weight: 500;
    box-shadow: inset 0 0 20px rgba(25, 30, 42, 0.5);
}

body.ayu-mirage .no-explanation {
    color: #607080;
    font-style: italic;
}

/* Theme Modal styling */
body.ayu-mirage .theme-modal {
    background: #1f2430 !important;
    color: #cccac2 !important;
    border: 1px solid #33415e !important;
    border-radius: 12px !important;
    box-shadow: 0 20px 40px rgba(20, 25, 37, 0.8) !important;
}

body.ayu-mirage .theme-modal-header {
    background: #232834 !important;
    border-bottom: 1px solid #2d3444 !important;
    border-radius: 12px 12px 0 0 !important;
}

body.ayu-mirage .theme-modal-header h3 {
    color: #ffcc66 !important;
    font-weight: 600 !important;
    text-shadow: 0 0 10px rgba(255, 204, 102, 0.3) !important;
}

body.ayu-mirage .theme-modal-content {
    background: #1f2430 !important;
}

body.ayu-mirage .theme-modal .close-button {
    color: #607080 !important;
    background: rgba(45, 52, 68, 0.4) !important;
    border: 1px solid #33415e !important;
    border-radius: 4px !important;
}

body.ayu-mirage .theme-modal .close-button:hover {
    color: #ff6666 !important;
    background: rgba(255, 102, 102, 0.1) !important;
    border-color: #ff6666 !important;
}

body.ayu-mirage .theme-option {
    border: 1px solid #2d3444 !important;
    border-radius: 8px !important;
    background: rgba(35, 40, 52, 0.6) !important;
    transition: all 0.2s ease !important;
}

body.ayu-mirage .theme-option:hover {
    border-color: #ffcc66 !important;
    background: rgba(255, 204, 102, 0.1) !important;
    transform: translateY(-2px) !important;
}

body.ayu-mirage .theme-option h4 {
    color: #73d0ff !important;
    font-weight: 600 !important;
}

body.ayu-mirage .theme-option p {
    color: #607080 !important;
}

/* FAB Buttons */
body.ayu-mirage .fab-container .fab {
    background: linear-gradient(135deg, #ffcc66 0%, #ffad66 100%) !important;
    color: #1f2430 !important;
    border-radius: 50% !important;
    font-weight: 500 !important;
    box-shadow: 0 8px 25px rgba(255, 204, 102, 0.3) !important;
    transition: all 0.3s ease !important;
}

body.ayu-mirage .fab-container .fab:hover {
    background: linear-gradient(135deg, #73d0ff 0%, #5ccfe6 100%) !important;
    box-shadow: 0 12px 35px rgba(115, 208, 255, 0.4) !important;
    transform: scale(1.1) translateY(-2px);
}

/* Status message */
body.ayu-mirage .status {
    background: rgba(31, 36, 48, 0.95) !important;
    color: #cccac2 !important;
    border: 1px solid #33415e !important;
    border-radius: 8px !important;
    box-shadow: 0 8px 25px rgba(20, 25, 37, 0.6) !important;
    backdrop-filter: blur(8px) !important;
}</style></head>
<body class="ayu-mirage">
    <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme">
        <span class="theme-icon">🌑</span>
    </button>
    
    <div class="container" id="container">
        <h1 class="logo">Linux Man Pages</h1>
        
        <div class="search-container">
            <div class="search-box">
                <select class="section-select" id="sectionSelect">
                    <option value="">All Sections</option>
                    <option value="1">1 - User Commands</option>
                    <option value="2">2 - System Calls</option>
                    <option value="3">3 - Library Functions</option>
                    <option value="4">4 - Device Files</option>
                    <option value="5">5 - File Formats</option>
                    <option value="6">6 - Games</option>
                    <option value="7">7 - Miscellaneous</option>
                    <option value="8">8 - System Admin</option>
                </select>
                <input type="text" class="search-input" id="searchInput" placeholder="Search for a command..." autocomplete="off">
                <button class="search-button" id="searchButton">Search</button>
            </div>
            
            
            <div class="suggestions" id="suggestions"><div style="height: 0px; pointer-events: none;"></div><div style="position: relative;"></div><div style="height: 0px; pointer-events: none;"></div></div>
        </div>
        
        <div class="content-wrapper" id="contentWrapper">
            <nav class="section-nav" id="sectionNav">
                <h3>Sections</h3>
                <ul id="sectionNavList"></ul>
            </nav>
            
            <div class="man-page-container" id="manPageContainer">
                <div class="man-page-header">
                    <h2 class="man-page-title" id="manPageTitle"></h2>
                    <div class="header-actions">
                        <button class="action-button" id="tldrJumpBtn" title="Jump to TLDR">📋</button>
                        <button class="action-button" id="bookmarkBtn" title="Bookmark this page">⭐</button>
                        <button class="close-button" id="closeButton">×</button>
                    </div>
                </div>
                <div class="man-page-content" id="manPageContent"></div>
                <div class="related-commands" id="relatedCommands" style="display: none;">
                    <h4>Related Commands</h4>
                    <div class="related-commands-list" id="relatedCommandsList"></div>
                </div>
                <div class="tldr-section" id="tldrSection" style="display: none;">
                    <h4>TLDR Summary</h4>
                    <div class="tldr-content" id="tldrContent"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="side-panel" id="sidePanel" style="">
        <div class="side-panel-header">
            <h3>History &amp; Bookmarks</h3>
            <button class="close-button" id="sidePanelClose">×</button>
        </div>
        <div class="side-panel-tabs">
            <button class="side-panel-tab active" data-tab="history">History</button>
            <button class="side-panel-tab" data-tab="bookmarks">Bookmarks</button>
        </div>
        <div class="side-panel-content" id="historyContent">
            <!-- History items will be populated here -->
        </div>
        <div class="side-panel-content" id="bookmarksContent" style="display: none;">
            <!-- Bookmark items will be populated here -->
        </div>
    </div>

    <div class="fab-container">
        <button class="fab secondary" id="historyFab" title="History &amp; Bookmarks">📚</button>
        <button class="fab secondary" id="helpFab" title="Keyboard shortcuts">?</button>
        <button class="fab secondary" id="explainerFab" title="Command Explainer">🔍</button>
    </div>

    <div class="shortcuts-help" id="shortcutsHelp">
        <div class="shortcuts-header">
            <h3>Keyboard Shortcuts</h3>
            <button class="close-button" id="shortcutsClose">×</button>
        </div>
        
        <div class="shortcuts-content">
            <div class="shortcuts-grid" id="shortcutsGrid">
                <!-- Shortcuts will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <div class="theme-modal" id="themeModal">
        <div class="theme-modal-header">
            <h3>Choose Your Theme</h3>
            <button class="close-button" id="themeModalClose">×</button>
        </div>
        <div class="theme-filter-bar">
            <input type="text" class="theme-search-input" id="themeSearchInput" placeholder="Search themes..." autocomplete="off">
            <div class="theme-category-filter">
                <button class="theme-filter-btn active" data-category="all">All</button>
                <button class="theme-filter-btn" data-category="dark">Dark</button>
                <button class="theme-filter-btn" data-category="light">Light</button>
                <button class="theme-filter-btn" data-category="vibrant">Vibrant</button>
                <button class="theme-filter-btn" data-category="nature">Nature</button>
            </div>
        </div>
        <div class="theme-modal-content">
            <div class="theme-options" id="themeOptions">
                <!-- Theme options will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="status show" id="status">Processing search index... (50%)</div>

    <div class="command-explainer-modal" id="commandExplainerModal">
        <div class="command-explainer-header">
            <h3>Command Explainer</h3>
            <button class="close-button" id="commandExplainerClose">×</button>
        </div>
        <div class="command-explainer-content">
            <div class="command-input-container">
                <textarea class="command-input" id="commandInput" placeholder="Enter a command to explain (e.g., ls -la /home)" autocomplete="off" rows="1"></textarea>
            </div>
            
            <div class="command-breakdown" id="commandBreakdown">
                <div class="no-explanation">Enter a command above to see its breakdown</div>
            </div>
            
            <div class="command-explanations" id="commandExplanations">
                <!-- Explanations will be populated here -->
            </div>
        </div>
    </div>

    <!-- Dynamic data loading will be handled by JavaScript -->
    
    <script>
        // Application state
        let currentState = 'initial';
        let searchTimeout = null;
        let currentManPage = null;
        let history = [];
        let bookmarks = [];

        // Performance-optimized caching and indexing system
        class PerformanceManager {
            constructor() {
                // Memory management
                this.eventListeners = new Map();
                this.cleanupTasks = [];
                this.memoryThreshold = 50 * 1024 * 1024; // 50MB
                
                // Enhanced caching system
                this.caches = {
                    search: new LRUCache(100, 5 * 60 * 1000), // 100 items, 5 min TTL
                    manPages: new LRUCache(50, 10 * 60 * 1000), // 50 items, 10 min TTL
                    tldr: new LRUCache(30, 15 * 60 * 1000), // 30 items, 15 min TTL
                    crossRefs: new LRUCache(200, 60 * 1000) // 200 items, 1 min TTL
                };
                
                // Optimized search indexes
                this.searchIndexes = {
                    byCommand: new Map(),
                    byPrefix: new Map(),
                    byKeyword: new Map(),
                    tokenized: new Map(),
                    fuzzy: new Map()
                };
                
                this.isIndexBuilt = false;
                this.indexBuildPromise = null;
                
                // Start memory monitoring
                this.startMemoryMonitoring();
            }
            
            // LRU Cache implementation with TTL
            createLRUCache(maxSize, ttl) {
                return new LRUCache(maxSize, ttl);
            }
            
            // Build optimized search indexes
            async buildSearchIndexes() {
                if (this.isIndexBuilt) return true;
                if (this.indexBuildPromise) return this.indexBuildPromise;
                
                this.indexBuildPromise = this._buildSearchIndexes();
                return this.indexBuildPromise;
            }
            
            async _buildSearchIndexes() {
                try {
                    console.log('Building optimized search indexes...');
                    const startTime = performance.now();
                    
                    if (!window.searchIndex) {
                        console.error('Search index not loaded');
                        return false;
                    }
                    
                    const { byCommand, byPrefix, byKeyword, tokenized, fuzzy } = this.searchIndexes;
                    
                    // Clear existing indexes
                    byCommand.clear();
                    byPrefix.clear();
                    byKeyword.clear();
                    tokenized.clear();
                    fuzzy.clear();
                    
                    for (const entry of window.searchIndex) {
                        const command = (entry.command || entry.name || '').toLowerCase();
                        const description = (entry.description || '').toLowerCase();
                        
                        if (!command) continue;
                        
                        // 1. Command name index (O(1) exact lookups)
                        if (!byCommand.has(command)) {
                            byCommand.set(command, []);
                        }
                        byCommand.get(command).push(entry);
                        
                        // 2. Prefix index (O(1) prefix lookups)
                        for (let i = 1; i <= Math.min(command.length, 6); i++) {
                            const prefix = command.substring(0, i);
                            if (!byPrefix.has(prefix)) {
                                byPrefix.set(prefix, []);
                            }
                            byPrefix.get(prefix).push(entry);
                        }
                        
                        // 3. Keyword index from descriptions
                        const keywords = description.split(/\s+/).filter(word => 
                            word.length > 2 && !this.isStopWord(word)
                        );
                        
                        for (const keyword of keywords) {
                            if (!byKeyword.has(keyword)) {
                                byKeyword.set(keyword, []);
                            }
                            byKeyword.get(keyword).push(entry);
                        }
                        
                        // 4. Tokenized data for fast substring matching
                        tokenized.set(entry, {
                            commandLower: command,
                            descLower: description,
                            keywords: keywords
                        });
                        
                        // 5. Fuzzy matching data (simplified soundex)
                        const soundex = this.generateSoundex(command);
                        if (!fuzzy.has(soundex)) {
                            fuzzy.set(soundex, []);
                        }
                        fuzzy.get(soundex).push(entry);
                    }
                    
                    this.isIndexBuilt = true;
                    const buildTime = performance.now() - startTime;
                    console.log(`Search indexes built in ${buildTime.toFixed(2)}ms`);
                    console.log(`Index sizes: Commands=${byCommand.size}, Prefixes=${byPrefix.size}, Keywords=${byKeyword.size}`);
                    
                    return true;
                } catch (error) {
                    console.error('Failed to build search indexes:', error);
                    return false;
                }
            }
            
            // Optimized search using built indexes
            performOptimizedSearch(query, section = '', maxResults = 10) {
                if (!this.isIndexBuilt) {
                    console.warn('Search indexes not built, falling back to linear search');
                    return this.performLinearSearch(query, section, maxResults);
                }
                
                const startTime = performance.now();
                const lowerQuery = query.toLowerCase();
                const results = new Map(); // Use Map to avoid duplicates
                const { byCommand, byPrefix, byKeyword, tokenized, fuzzy } = this.searchIndexes;
                
                // 1. Exact command matches (highest priority)
                if (byCommand.has(lowerQuery)) {
                    for (const entry of byCommand.get(lowerQuery)) {
                        if (!section || entry.section === parseInt(section)) {
                            results.set(this.getEntryKey(entry), { entry, score: 100 });
                        }
                    }
                }
                
                // 2. Prefix matches
                if (results.size < maxResults && lowerQuery.length >= 2) {
                    const prefixMatches = byPrefix.get(lowerQuery.substring(0, Math.min(lowerQuery.length, 6)));
                    if (prefixMatches) {
                        for (const entry of prefixMatches) {
                            const key = this.getEntryKey(entry);
                            if (!results.has(key) && (!section || entry.section === parseInt(section))) {
                                const command = entry.command || entry.name;
                                if (command && command.toLowerCase().startsWith(lowerQuery)) {
                                    const score = 90 - (command.length - lowerQuery.length);
                                    results.set(key, { entry, score });
                                }
                            }
                        }
                    }
                }
                
                // 3. Keyword matches in descriptions
                if (results.size < maxResults) {
                    const queryWords = lowerQuery.split(/\s+/);
                    for (const word of queryWords) {
                        if (word.length > 2 && byKeyword.has(word)) {
                            for (const entry of byKeyword.get(word)) {
                                const key = this.getEntryKey(entry);
                                if (!results.has(key) && (!section || entry.section === parseInt(section))) {
                                    results.set(key, { entry, score: 70 });
                                }
                            }
                        }
                    }
                }
                
                // 4. Substring matches in commands
                if (results.size < maxResults) {
                    for (const [entry, data] of tokenized) {
                        if (results.size >= maxResults * 2) break; // Limit iteration
                        
                        const key = this.getEntryKey(entry);
                        if (!results.has(key) && (!section || entry.section === parseInt(section))) {
                            if (data.commandLower.includes(lowerQuery)) {
                                const score = 60 - Math.abs(data.commandLower.length - lowerQuery.length);
                                results.set(key, { entry, score });
                            } else if (data.descLower.includes(lowerQuery)) {
                                results.set(key, { entry, score: 40 });
                            }
                        }
                    }
                }
                
                // 5. Fuzzy matches (if still need more results)
                if (results.size < maxResults && lowerQuery.length >= 3) {
                    const querySoundex = this.generateSoundex(lowerQuery);
                    const fuzzyMatches = fuzzy.get(querySoundex);
                    if (fuzzyMatches) {
                        for (const entry of fuzzyMatches) {
                            const key = this.getEntryKey(entry);
                            if (!results.has(key) && (!section || entry.section === parseInt(section))) {
                                results.set(key, { entry, score: 20 });
                            }
                        }
                    }
                }
                
                // Sort by score and return top results
                const sortedResults = Array.from(results.values())
                    .sort((a, b) => b.score - a.score)
                    .slice(0, maxResults)
                    .map(item => item.entry);
                
                const searchTime = performance.now() - startTime;
                console.log(`Optimized search for "${query}" completed in ${searchTime.toFixed(2)}ms, found ${sortedResults.length} results`);
                
                return sortedResults;
            }
            
            // Fallback linear search
            performLinearSearch(query, section = '', maxResults = 10) {
                const startTime = performance.now();
                const lowerQuery = query.toLowerCase();
                const results = [];
                
                for (const entry of window.searchIndex) {
                    if (results.length >= maxResults) break;
                    if (section && entry.section !== parseInt(section)) continue;
                    
                    const command = (entry.command || entry.name || '').toLowerCase();
                    const description = (entry.description || '').toLowerCase();
                    
                    if (command.includes(lowerQuery) || description.includes(lowerQuery)) {
                        results.push(entry);
                    }
                }
                
                const searchTime = performance.now() - startTime;
                console.log(`Linear search completed in ${searchTime.toFixed(2)}ms`);
                
                return results;
            }
            
            // Helper methods
            getEntryKey(entry) {
                return `${entry.command || entry.name}_${entry.section}`;
            }
            
            isStopWord(word) {
                const stopWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'among', 'within', 'without', 'under', 'over', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should']);
                return stopWords.has(word);
            }
            
            generateSoundex(str) {
                if (!str || str.length === 0) return '';
                
                const code = str.toUpperCase()
                    .replace(/[AEIOUYHW]/g, '0')
                    .replace(/[BFPV]/g, '1')
                    .replace(/[CGJKQSXZ]/g, '2')
                    .replace(/[DT]/g, '3')
                    .replace(/[L]/g, '4')
                    .replace(/[MN]/g, '5')
                    .replace(/[R]/g, '6')
                    .replace(/0+/g, '0')
                    .replace(/(.)\1+/g, '$1');
                
                return (code.charAt(0) + code.slice(1).replace(/0/g, '')).padEnd(4, '0').substring(0, 4);
            }
            
            // Event listener management with automatic cleanup
            addManagedEventListener(element, event, handler, options = {}) {
                element.addEventListener(event, handler, options);
                
                const key = `${element.tagName || 'UNKNOWN'}_${event}_${Date.now()}`;
                this.eventListeners.set(key, { element, event, handler, options });
                
                // Return cleanup function
                return () => {
                    element.removeEventListener(event, handler, options);
                    this.eventListeners.delete(key);
                };
            }
            
            // Batch remove event listeners
            cleanupEventListeners() {
                for (const [key, { element, event, handler, options }] of this.eventListeners) {
                    try {
                        element.removeEventListener(event, handler, options);
                    } catch (error) {
                        console.warn(`Failed to remove event listener ${key}:`, error);
                    }
                }
                this.eventListeners.clear();
                console.log('All event listeners cleaned up');
            }
            
            // Memory monitoring and cleanup
            startMemoryMonitoring() {
                const checkMemory = () => {
                    if (performance.memory) {
                        const used = performance.memory.usedJSHeapSize;
                        const total = performance.memory.totalJSHeapSize;
                        
                        if (used > this.memoryThreshold) {
                            console.warn(`Memory usage high: ${(used / 1024 / 1024).toFixed(2)}MB`);
                            this.performMemoryCleanup();
                        }
                        
                        // Log memory stats every 30 seconds in development
                        if (window.location.hostname === 'localhost') {
                            console.log(`Memory: ${(used / 1024 / 1024).toFixed(2)}MB / ${(total / 1024 / 1024).toFixed(2)}MB`);
                        }
                    }
                };
                
                // Check every 30 seconds
                this.memoryCheckInterval = setInterval(checkMemory, 30000);
                this.cleanupTasks.push(() => clearInterval(this.memoryCheckInterval));
            }
            
            performMemoryCleanup() {
                console.log('Performing memory cleanup...');
                
                // Clear old cache entries
                Object.values(this.caches).forEach(cache => cache.cleanup());
                
                // Force garbage collection if available (Chrome DevTools)
                if (window.gc) {
                    window.gc();
                }
                
                console.log('Memory cleanup completed');
            }
            
            // Cleanup all resources
            destroy() {
                this.cleanupEventListeners();
                this.cleanupTasks.forEach(task => task());
                Object.values(this.caches).forEach(cache => cache.clear());
                
                this.searchIndexes.byCommand.clear();
                this.searchIndexes.byPrefix.clear();
                this.searchIndexes.byKeyword.clear();
                this.searchIndexes.tokenized.clear();
                this.searchIndexes.fuzzy.clear();
                
                console.log('PerformanceManager destroyed');
            }
        }

        // LRU Cache with TTL implementation
        class LRUCache {
            constructor(maxSize, ttl) {
                this.maxSize = maxSize;
                this.ttl = ttl;
                this.cache = new Map();
                this.accessOrder = new Map();
                this.accessCounter = 0;
            }
            
            get(key) {
                const item = this.cache.get(key);
                if (!item) return null;
                
                const now = Date.now();
                if (now - item.timestamp > this.ttl) {
                    this.cache.delete(key);
                    this.accessOrder.delete(key);
                    return null;
                }
                
                // Update access order
                this.accessOrder.set(key, ++this.accessCounter);
                return item.value;
            }
            
            set(key, value) {
                const now = Date.now();
                
                // Remove oldest entries if at capacity
                if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
                    this.evictOldest();
                }
                
                this.cache.set(key, { value, timestamp: now });
                this.accessOrder.set(key, ++this.accessCounter);
            }
            
            evictOldest() {
                let oldestKey = null;
                let oldestAccess = Infinity;
                
                for (const [key, accessTime] of this.accessOrder) {
                    if (accessTime < oldestAccess) {
                        oldestAccess = accessTime;
                        oldestKey = key;
                    }
                }
                
                if (oldestKey) {
                    this.cache.delete(oldestKey);
                    this.accessOrder.delete(oldestKey);
                }
            }
            
            cleanup() {
                const now = Date.now();
                const keysToDelete = [];
                
                for (const [key, item] of this.cache) {
                    if (now - item.timestamp > this.ttl) {
                        keysToDelete.push(key);
                    }
                }
                
                keysToDelete.forEach(key => {
                    this.cache.delete(key);
                    this.accessOrder.delete(key);
                });
                
                return keysToDelete.length;
            }
            
            clear() {
                this.cache.clear();
                this.accessOrder.clear();
                this.accessCounter = 0;
            }
            
            size() {
                return this.cache.size;
            }
            
            getStats() {
                return {
                    size: this.cache.size,
                    maxSize: this.maxSize,
                    ttl: this.ttl
                };
            }
        }

        // Initialize performance manager
        const performanceManager = new PerformanceManager();

        // Smart Search Manager for debouncing and request cancellation
        class SmartSearchManager {
            constructor() {
                this.searchTimeout = null;
                this.currentController = null;
                this.requestId = 0;
                this.isSearching = false;
                
                // Optimized timing based on query length and user behavior
                this.DEBOUNCE_SHORT = 100;  // For short queries (1-2 chars)
                this.DEBOUNCE_NORMAL = 150; // For normal queries (3+ chars)
                this.DEBOUNCE_LONG = 200;   // For complex queries (8+ chars)
            }
            
            setupSearchInput(searchInput, searchCallback) {
                searchInput.addEventListener('input', (e) => {
                    this.handleSearchInput(e.target.value, searchCallback);
                });
                
                // Cancel search when user presses Escape
                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.cancelCurrentSearch();
                        searchInput.blur();
                    }
                });
            }
            
            handleSearchInput(query, callback) {
                // Cancel any pending search
                this.cancelCurrentSearch();
                
                // Determine optimal debounce timing
                const debounceTime = this.getOptimalDebounceTime(query);
                
                console.log(`Search input: "${query}" (debounce: ${debounceTime}ms)`);
                
                this.searchTimeout = setTimeout(() => {
                    this.performSearch(query, callback);
                }, debounceTime);
            }
            
            getOptimalDebounceTime(query) {
                const length = query.length;
                
                if (length === 0) return 0; // Immediate for clearing
                if (length <= 2) return this.DEBOUNCE_SHORT; // Quick for short
                if (length >= 8) return this.DEBOUNCE_LONG; // Longer for complex
                return this.DEBOUNCE_NORMAL; // Normal for most cases
            }
            
            async performSearch(query, callback) {
                // Increment request ID to handle race conditions
                const requestId = ++this.requestId;
                
                // Create new AbortController for this search
                this.currentController = new AbortController();
                
                try {
                    this.isSearching = true;
                    
                    // Call the provided search callback with abort signal
                    const results = await callback(query, {
                        signal: this.currentController ? this.currentController.signal : null,
                        requestId: requestId
                    });
                    
                    // Only process results if this is still the latest request
                    if (requestId === this.requestId && this.currentController && !this.currentController.signal.aborted) {
                        console.log(`Search completed for "${query}": ${results.length} results`);
                        return results;
                    } else {
                        console.log(`Search cancelled or superseded: "${query}"`);
                        return null;
                    }
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log(`Search aborted: "${query}"`);
                        return null;
                    } else {
                        console.error(`Search failed for "${query}":`, error);
                        throw error;
                    }
                } finally {
                    this.isSearching = false;
                }
            }
            
            cancelCurrentSearch() {
                // Cancel pending timeout
                if (this.searchTimeout) {
                    clearTimeout(this.searchTimeout);
                    this.searchTimeout = null;
                }
                
                // Abort current request
                if (this.currentController) {
                    this.currentController.abort();
                    this.currentController = null;
                }
            }
            
            isCurrentlySearching() {
                return this.isSearching;
            }
            
            // Get stats for debugging
            getStats() {
                return {
                    currentRequestId: this.requestId,
                    isSearching: this.isSearching,
                    hasPendingTimeout: !!this.searchTimeout,
                    hasActiveRequest: !!this.currentController
                };
            }
            
            // Cleanup method to prevent memory leaks
            destroy() {
                // Cancel any pending search
                this.cancelCurrentSearch();
                
                // Clear references
                this.searchInput = null;
                this.searchHandler = null;
                
                console.log('SmartSearchManager destroyed');
            }
        }

        // Loading State Manager for improved UX
        class LoadingStateManager {
            constructor() {
                this.activeLoadings = new Map();
                this.skeletonStyles = this.createSkeletonStyles();
            }
            
            createSkeletonStyles() {
                // Add skeleton CSS if not already present
                if (!document.getElementById('skeleton-styles')) {
                    const style = document.createElement('style');
                    style.id = 'skeleton-styles';
                    style.textContent = `
                        .skeleton {
                            animation: skeleton-loading 1.5s infinite;
                            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
                            background-size: 200% 100%;
                            border-radius: 4px;
                        }
                        
                        @keyframes skeleton-loading {
                            0% { background-position: -200% 0; }
                            100% { background-position: 200% 0; }
                        }
                        
                        .skeleton-line {
                            height: 16px;
                            margin-bottom: 8px;
                            border-radius: 4px;
                        }
                        
                        .skeleton-line.title { height: 24px; width: 60%; }
                        .skeleton-line.subtitle { height: 18px; width: 40%; }
                        .skeleton-line.short { width: 80%; }
                        .skeleton-line.medium { width: 90%; }
                        .skeleton-line.long { width: 95%; }
                        
                        .skeleton-search-result {
                            padding: 12px 16px;
                            border-bottom: 1px solid #f0f0f0;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                        }
                        
                        .skeleton-search-result .skeleton-info {
                            flex: 1;
                        }
                        
                        .skeleton-search-result .skeleton-badge {
                            width: 24px;
                            height: 24px;
                            border-radius: 12px;
                            margin-left: 16px;
                        }
                        
                        .skeleton-manpage-content {
                            padding: 20px;
                        }
                        
                        .skeleton-manpage-content .skeleton-header {
                            margin-bottom: 20px;
                        }
                        
                        .skeleton-manpage-content .skeleton-section {
                            margin-bottom: 16px;
                        }
                        
                        .loading-overlay {
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(255, 255, 255, 0.8);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            z-index: 1000;
                            backdrop-filter: blur(2px);
                        }
                        
                        .loading-spinner {
                            width: 32px;
                            height: 32px;
                            border: 3px solid #f3f3f3;
                            border-top: 3px solid #4285f4;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                        }
                        
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                        
                        .fade-in {
                            animation: fadeIn 0.3s ease-in;
                        }
                        
                        @keyframes fadeIn {
                            from { opacity: 0; transform: translateY(10px); }
                            to { opacity: 1; transform: translateY(0); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
            
            showSearchLoading(container) {
                if (!container) return; // Safety check to prevent null reference errors
                
                const loadingId = 'search-loading';
                
                if (this.activeLoadings.has(loadingId)) {
                    return; // Already showing loading
                }
                
                const skeleton = this.createSearchSkeleton();
                container.innerHTML = '';
                container.appendChild(skeleton);
                container.style.display = 'block';
                
                this.activeLoadings.set(loadingId, { container, type: 'search' });
            }
            
            createSearchSkeleton() {
                const fragment = document.createDocumentFragment();
                
                // Create 5 skeleton search results
                for (let i = 0; i < 5; i++) {
                    const result = document.createElement('div');
                    result.className = 'skeleton-search-result';
                    result.innerHTML = `
                        <div class="skeleton-info">
                            <div class="skeleton skeleton-line title" style="margin-bottom: 4px;"></div>
                            <div class="skeleton skeleton-line short"></div>
                        </div>
                        <div class="skeleton skeleton-badge"></div>
                    `;
                    fragment.appendChild(result);
                }
                
                return fragment;
            }
            
            showManPageLoading(container) {
                if (!container) return; // Safety check to prevent null reference errors
                
                const loadingId = 'manpage-loading';
                
                if (this.activeLoadings.has(loadingId)) {
                    return;
                }
                
                const skeleton = this.createManPageSkeleton();
                container.innerHTML = '';
                container.appendChild(skeleton);
                
                this.activeLoadings.set(loadingId, { container, type: 'manpage' });
            }
            
            createManPageSkeleton() {
                const skeleton = document.createElement('div');
                skeleton.className = 'skeleton-manpage-content';
                skeleton.innerHTML = `
                    <div class="skeleton-header">
                        <div class="skeleton skeleton-line title" style="margin-bottom: 8px;"></div>
                        <div class="skeleton skeleton-line subtitle" style="margin-bottom: 16px;"></div>
                    </div>
                    
                    <div class="skeleton-section">
                        <div class="skeleton skeleton-line medium" style="margin-bottom: 12px;"></div>
                        <div class="skeleton skeleton-line long"></div>
                        <div class="skeleton skeleton-line medium"></div>
                        <div class="skeleton skeleton-line short"></div>
                    </div>
                    
                    <div class="skeleton-section">
                        <div class="skeleton skeleton-line title" style="margin-bottom: 8px;"></div>
                        <div class="skeleton skeleton-line long"></div>
                        <div class="skeleton skeleton-line medium"></div>
                        <div class="skeleton skeleton-line long"></div>
                        <div class="skeleton skeleton-line short"></div>
                    </div>
                    
                    <div class="skeleton-section">
                        <div class="skeleton skeleton-line medium"></div>
                        <div class="skeleton skeleton-line long"></div>
                        <div class="skeleton skeleton-line medium"></div>
                    </div>
                `;
                
                return skeleton;
            }
            
            showSpinner(container, message = 'Loading...') {
                const loadingId = `spinner-${Date.now()}`;
                
                const overlay = document.createElement('div');
                overlay.className = 'loading-overlay';
                overlay.innerHTML = `
                    <div style="text-align: center;">
                        <div class="loading-spinner"></div>
                        <div style="margin-top: 12px; color: #666;">${message}</div>
                    </div>
                `;
                
                // Make container relative if not already
                const originalPosition = container.style.position;
                if (!originalPosition || originalPosition === 'static') {
                    container.style.position = 'relative';
                }
                
                container.appendChild(overlay);
                
                this.activeLoadings.set(loadingId, { 
                    container, 
                    type: 'spinner', 
                    overlay,
                    originalPosition 
                });
                
                return loadingId;
            }
            
            hideLoading(containerOrId, content = null) {
                let loadingInfo;
                
                if (typeof containerOrId === 'string') {
                    // Find by ID
                    loadingInfo = this.activeLoadings.get(containerOrId);
                } else {
                    // Find by container
                    for (const [id, info] of this.activeLoadings) {
                        if (info.container === containerOrId) {
                            loadingInfo = info;
                            containerOrId = id;
                            break;
                        }
                    }
                }
                
                if (!loadingInfo) return;
                
                const { container, type, overlay, originalPosition } = loadingInfo;
                
                if (type === 'spinner' && overlay) {
                    // Remove spinner overlay
                    overlay.remove();
                    if (originalPosition) {
                        container.style.position = originalPosition;
                    }
                } else if (content) {
                    // Replace skeleton with content
                    this.smoothContentTransition(container, content);
                }
                
                this.activeLoadings.delete(containerOrId);
            }
            
            async smoothContentTransition(container, content) {
                if (!container) return; // Safety check to prevent null reference errors
                
                // Use DOM batch updater for smooth transitions
                
                // Phase 1: Fade out (write operation)
                await domBatchUpdater.updateElement(container, {
                    style: { 
                        opacity: '0.5',
                        transition: 'opacity 0.2s ease'
                    }
                });
                
                // Wait for fade out
                await new Promise(resolve => setTimeout(resolve, 150));
                
                // Phase 2: Replace content and fade in (batched operations)
                await domBatchUpdater.batch([
                    {
                        type: 'write',
                        operation: () => {
                            // Replace content
                            if (typeof content === 'string') {
                                container.innerHTML = content;
                            } else {
                                container.innerHTML = '';
                                container.appendChild(content);
                            }
                        }
                    },
                    {
                        type: 'write', 
                        operation: () => {
                            // Fade in new content
                            container.style.opacity = '1';
                            container.classList.add('fade-in');
                        }
                    }
                ]);
                
                // Phase 3: Clean up animation (delayed)
                setTimeout(async () => {
                    await domBatchUpdater.updateElement(container, {
                        classList: { 'fade-in': false },
                        style: { transition: '' }
                    });
                }, 300);
            }
            
            hideAllLoading() {
                for (const [id, info] of this.activeLoadings) {
                    this.hideLoading(id);
                }
            }
            
            isLoading(container) {
                for (const info of this.activeLoadings.values()) {
                    if (info.container === container) {
                        return true;
                    }
                }
                return false;
            }
            
            // Update loading progress for progressive operations
            updateLoadingProgress(percentage, message) {
                // Find active loading with progress support
                for (const [id, info] of this.activeLoadings) {
                    if (info.type === 'progress' || info.container.querySelector('.loading-progress')) {
                        this.updateProgressIndicator(info.container, percentage, message);
                        return;
                    }
                }
                
                // If no progress indicator exists, just update status
                if (percentage < 100) {
                    showStatus(`${message} (${Math.round(percentage)}%)`);
                }
            }
            
            // Update progress indicator in container
            updateProgressIndicator(container, percentage, message) {
                let progressElement = container.querySelector('.loading-progress');
                
                if (!progressElement) {
                    // Create progress indicator if it doesn't exist
                    progressElement = this.createProgressIndicator();
                    container.appendChild(progressElement);
                }
                
                // Update progress bar and message
                const progressBar = progressElement.querySelector('.progress-bar');
                const progressMessage = progressElement.querySelector('.progress-message');
                
                if (progressBar) {
                    progressBar.style.width = `${percentage}%`;
                }
                
                if (progressMessage) {
                    progressMessage.textContent = message;
                }
                
                // Remove progress indicator when complete
                if (percentage >= 100) {
                    setTimeout(() => {
                        if (progressElement.parentNode) {
                            progressElement.remove();
                        }
                    }, 1000);
                }
            }
            
            // Create a progress indicator element
            createProgressIndicator() {
                const progressDiv = document.createElement('div');
                progressDiv.className = 'loading-progress';
                progressDiv.style.cssText = `
                    position: absolute;
                    bottom: 10px;
                    left: 10px;
                    right: 10px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    z-index: 1000;
                `;
                
                const progressMessage = document.createElement('div');
                progressMessage.className = 'progress-message';
                progressMessage.style.cssText = 'margin-bottom: 4px;';
                
                const progressTrack = document.createElement('div');
                progressTrack.style.cssText = `
                    background: rgba(255, 255, 255, 0.2);
                    height: 4px;
                    border-radius: 2px;
                    overflow: hidden;
                `;
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                progressBar.style.cssText = `
                    background: #4CAF50;
                    height: 100%;
                    width: 0%;
                    transition: width 0.3s ease;
                `;
                
                progressTrack.appendChild(progressBar);
                progressDiv.appendChild(progressMessage);
                progressDiv.appendChild(progressTrack);
                
                return progressDiv;
            }
        }

        // DOM Batch Update System for performance optimization
        class DOMBatchUpdater {
            constructor() {
                this.readOperations = [];
                this.writeOperations = [];
                this.isScheduled = false;
                this.frameId = null;
                
                // Performance monitoring
                this.batchCount = 0;
                this.totalOperations = 0;
                this.measurementEnabled = false;
            }
            
            // Queue a DOM read operation (measure phase)
            queueRead(operation, context = null) {
                return new Promise((resolve, reject) => {
                    this.readOperations.push({
                        operation,
                        context,
                        resolve,
                        reject,
                        timestamp: performance.now()
                    });
                    
                    this.scheduleUpdate();
                });
            }
            
            // Queue a DOM write operation (mutate phase)
            queueWrite(operation, context = null) {
                return new Promise((resolve, reject) => {
                    this.writeOperations.push({
                        operation,
                        context,
                        resolve,
                        reject,
                        timestamp: performance.now()
                    });
                    
                    this.scheduleUpdate();
                });
            }
            
            // Batch multiple operations together
            batch(operations) {
                const promises = operations.map(({ type, operation, context }) => {
                    if (type === 'read') {
                        return this.queueRead(operation, context);
                    } else if (type === 'write') {
                        return this.queueWrite(operation, context);
                    }
                });
                
                return Promise.all(promises);
            }
            
            // Schedule the batched update
            scheduleUpdate() {
                if (this.isScheduled) return;
                
                this.isScheduled = true;
                this.frameId = requestAnimationFrame(() => {
                    this.processBatch();
                });
            }
            
            // Process all queued operations in optimal order
            processBatch() {
                const startTime = performance.now();
                
                try {
                    // Phase 1: Execute all READ operations first (no layout)
                    const readResults = this.executeReads();
                    
                    // Phase 2: Execute all WRITE operations (triggers layout once)
                    const writeResults = this.executeWrites();
                    
                    // Performance tracking
                    if (this.measurementEnabled) {
                        const endTime = performance.now();
                        this.batchCount++;
                        this.totalOperations += this.readOperations.length + this.writeOperations.length;
                        
                        console.log(`DOM Batch ${this.batchCount}: ${this.readOperations.length} reads, ${this.writeOperations.length} writes in ${(endTime - startTime).toFixed(2)}ms`);
                    }
                    
                } catch (error) {
                    console.error('DOM batch processing failed:', error);
                } finally {
                    // Reset for next batch
                    this.readOperations = [];
                    this.writeOperations = [];
                    this.isScheduled = false;
                    this.frameId = null;
                }
            }
            
            executeReads() {
                const results = [];
                
                for (const { operation, context, resolve, reject } of this.readOperations) {
                    try {
                        const result = operation.call(context);
                        results.push(result);
                        resolve(result);
                    } catch (error) {
                        console.error('DOM read operation failed:', error);
                        reject(error);
                    }
                }
                
                return results;
            }
            
            executeWrites() {
                const results = [];
                
                for (const { operation, context, resolve, reject } of this.writeOperations) {
                    try {
                        const result = operation.call(context);
                        results.push(result);
                        resolve(result);
                    } catch (error) {
                        console.error('DOM write operation failed:', error);
                        reject(error);
                    }
                }
                
                return results;
            }
            
            // High-level convenience methods
            async updateElement(element, updates) {
                return this.queueWrite(() => {
                    Object.entries(updates).forEach(([property, value]) => {
                        if (property === 'textContent' || property === 'innerHTML') {
                            element[property] = value;
                        } else if (property === 'style') {
                            Object.assign(element.style, value);
                        } else if (property === 'attributes') {
                            Object.entries(value).forEach(([attr, attrValue]) => {
                                element.setAttribute(attr, attrValue);
                            });
                        } else if (property === 'classList') {
                            if (Array.isArray(value)) {
                                element.classList.add(...value);
                            } else {
                                Object.entries(value).forEach(([className, shouldAdd]) => {
                                    element.classList.toggle(className, shouldAdd);
                                });
                            }
                        }
                    });
                });
            }
            
            async appendElements(container, elements) {
                return this.queueWrite(() => {
                    if (Array.isArray(elements)) {
                        const fragment = document.createDocumentFragment();
                        elements.forEach(el => fragment.appendChild(el));
                        container.appendChild(fragment);
                    } else {
                        container.appendChild(elements);
                    }
                });
            }
            
            async clearContainer(container) {
                return this.queueWrite(() => {
                    while (container.firstChild) {
                        container.removeChild(container.firstChild);
                    }
                });
            }
            
            async measureElement(element, properties = ['offsetWidth', 'offsetHeight']) {
                return this.queueRead(() => {
                    const measurements = {};
                    properties.forEach(prop => {
                        measurements[prop] = element[prop];
                    });
                    return measurements;
                });
            }
            
            // Force immediate execution (emergency use only)
            forceFlush() {
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                }
                this.processBatch();
            }
            
            // Enable/disable performance monitoring
            enableMeasurement(enabled = true) {
                this.measurementEnabled = enabled;
                if (enabled) {
                    console.log('DOM batch performance monitoring enabled');
                }
            }
            
            // Get performance stats
            getStats() {
                return {
                    batchCount: this.batchCount,
                    totalOperations: this.totalOperations,
                    averageOpsPerBatch: this.batchCount > 0 ? this.totalOperations / this.batchCount : 0,
                    pendingReads: this.readOperations.length,
                    pendingWrites: this.writeOperations.length,
                    isScheduled: this.isScheduled
                };
            }
            
            // Clear all pending operations (cleanup)
            clear() {
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                }
                
                // Reject all pending operations
                [...this.readOperations, ...this.writeOperations].forEach(({ reject }) => {
                    reject(new Error('DOM batch cleared'));
                });
                
                this.readOperations = [];
                this.writeOperations = [];
                this.isScheduled = false;
                this.frameId = null;
            }
        }

        // Element Recycling Pool for memory optimization
        class ElementRecyclingPool {
            constructor() {
                this.pools = new Map();
                this.maxPoolSize = 50; // Configurable per element type
                this.totalElementsCreated = 0;
                this.totalElementsRecycled = 0;
                this.cleanupInterval = null;
                
                // Start periodic cleanup
                this.startPeriodicCleanup();
            }
            
            // Get or create an element of specified type and classes
            getElement(tagName, className = '', poolKey = null) {
                const key = poolKey || `${tagName}_${className}`;
                
                if (!this.pools.has(key)) {
                    this.pools.set(key, []);
                }
                
                const pool = this.pools.get(key);
                
                if (pool.length > 0) {
                    // Reuse existing element
                    const element = pool.pop();
                    this.totalElementsRecycled++;
                    
                    // Reset element to clean state
                    this.resetElement(element);
                    
                    return element;
                } else {
                    // Create new element
                    const element = document.createElement(tagName);
                    if (className) {
                        element.className = className;
                    }
                    
                    this.totalElementsCreated++;
                    
                    // Mark element for tracking
                    element.dataset.poolKey = key;
                    
                    return element;
                }
            }
            
            // Return element to pool for reuse
            recycleElement(element) {
                const poolKey = element.dataset.poolKey;
                if (!poolKey) return false; // Element not from pool
                
                const pool = this.pools.get(poolKey);
                if (!pool) return false;
                
                // Don't exceed max pool size
                if (pool.length >= this.maxPoolSize) {
                    return false;
                }
                
                // Remove from DOM if attached
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
                
                // Clean element and return to pool
                this.resetElement(element);
                pool.push(element);
                
                return true;
            }
            
            // Reset element to clean state
            resetElement(element) {
                // Clear content
                element.innerHTML = '';
                element.textContent = '';
                
                // Reset styles
                element.style.cssText = '';
                
                // Clear data attributes (except pool key)
                const poolKey = element.dataset.poolKey;
                element.dataset = {};
                if (poolKey) {
                    element.dataset.poolKey = poolKey;
                }
                
                // Remove event listeners (if any managed ones exist)
                element.onclick = null;
                element.onmouseenter = null;
                element.onmouseleave = null;
                
                // Reset className to original
                const originalClassName = poolKey ? poolKey.split('_').slice(1).join('_') : '';
                element.className = originalClassName;
            }
            
            // Batch recycle multiple elements
            recycleElements(elements) {
                let recycledCount = 0;
                for (const element of elements) {
                    if (this.recycleElement(element)) {
                        recycledCount++;
                    }
                }
                return recycledCount;
            }
            
            // Create optimized suggestion element using recycling
            createSuggestionElement(result, index) {
                // Get main suggestion container
                const suggestion = this.getElement('div', 'suggestion', 'suggestion_main');
                suggestion.dataset.index = index;
                suggestion.dataset.command = result.command || result.name;
                suggestion.dataset.section = result.section;
                
                // Get suggestion info container
                const suggestionInfo = this.getElement('div', 'suggestion-info', 'suggestion_info');
                
                // Get command element
                const suggestionCommand = this.getElement('div', 'suggestion-command', 'suggestion_command');
                suggestionCommand.textContent = result.command || result.name;
                
                // Get description element
                const suggestionDesc = this.getElement('div', 'suggestion-desc', 'suggestion_desc');
                suggestionDesc.textContent = result.description || 'No description available';
                
                // Assemble info
                suggestionInfo.appendChild(suggestionCommand);
                suggestionInfo.appendChild(suggestionDesc);
                
                // Get section area
                const sectionArea = this.getElement('div', 'section-area', 'suggestion_section');
                
                if (result.sections && result.sections.length > 1) {
                    // Multiple sections - create individual clickable spans
                    const sortedSections = result.sections.sort((a, b) => a - b);
                    sortedSections.forEach(sectionNum => {
                        const sectionBtn = this.getElement('span', 'section-badge section-clickable', 'section_clickable');
                        sectionBtn.textContent = `Section ${sectionNum}`;
                        sectionBtn.dataset.command = result.command;
                        sectionBtn.dataset.section = sectionNum;
                        
                        performanceManager.addManagedEventListener(sectionBtn, 'click', (e) => {
                            e.stopPropagation();
                            displayManPage(result.command, sectionNum);
                            suggestions.style.display = 'none';
                        });
                        
                        sectionArea.appendChild(sectionBtn);
                    });
                } else {
                    // Single section - show badge
                    const sectionBadge = this.getElement('span', 'section-badge', 'section_badge');
                    sectionBadge.textContent = `Section ${result.section || '1'}`;
                    sectionArea.appendChild(sectionBadge);
                }
                
                // Assemble final structure
                suggestion.appendChild(suggestionInfo);
                suggestion.appendChild(sectionArea);
                
                return suggestion;
            }
            
            // Clear suggestions and recycle elements
            async clearSuggestionsWithRecycling(container) {
                const suggestions = Array.from(container.children);
                
                // Remove from DOM first
                await domBatchUpdater.clearContainer(container);
                
                // Recycle elements for reuse
                const recycledCount = this.recycleElements(suggestions);
                
                if (window.location.hostname === 'localhost') {
                    console.log(`Recycled ${recycledCount}/${suggestions.length} suggestion elements`);
                }
            }
            
            // Periodic cleanup of oversized pools
            startPeriodicCleanup() {
                this.cleanupInterval = setInterval(() => {
                    this.cleanupPools();
                }, 30000); // Every 30 seconds
            }
            
            cleanupPools() {
                let totalCleaned = 0;
                
                for (const [key, pool] of this.pools) {
                    if (pool.length > this.maxPoolSize) {
                        const excess = pool.splice(this.maxPoolSize);
                        totalCleaned += excess.length;
                    }
                }
                
                if (totalCleaned > 0 && window.location.hostname === 'localhost') {
                    console.log(`Element pool cleanup: removed ${totalCleaned} excess elements`);
                }
            }
            
            // Get recycling statistics
            getStats() {
                const poolSizes = {};
                let totalPooled = 0;
                
                for (const [key, pool] of this.pools) {
                    poolSizes[key] = pool.length;
                    totalPooled += pool.length;
                }
                
                return {
                    totalElementsCreated: this.totalElementsCreated,
                    totalElementsRecycled: this.totalElementsRecycled,
                    recyclingRate: this.totalElementsCreated > 0 ? 
                        (this.totalElementsRecycled / this.totalElementsCreated * 100).toFixed(1) + '%' : '0%',
                    poolCount: this.pools.size,
                    totalPooledElements: totalPooled,
                    poolSizes: poolSizes
                };
            }
            
            // Destroy all pools and cleanup
            destroy() {
                if (this.cleanupInterval) {
                    clearInterval(this.cleanupInterval);
                }
                
                this.pools.clear();
                this.totalElementsCreated = 0;
                this.totalElementsRecycled = 0;
            }
        }

        // Async DOM Scheduler for non-blocking operations
        class AsyncDOMScheduler {
            constructor() {
                this.taskQueue = [];
                this.isProcessing = false;
                this.frameId = null;
                this.maxTasksPerFrame = 5; // Configurable workload per frame
                this.frameTimeLimit = 16; // ~60 FPS (16ms per frame)
                
                // Performance monitoring
                this.totalTasks = 0;
                this.completedTasks = 0;
                this.averageTaskTime = 0;
            }
            
            // Schedule a task to run asynchronously without blocking
            scheduleTask(taskFunction, priority = 'normal', context = null) {
                return new Promise((resolve, reject) => {
                    const task = {
                        id: ++this.totalTasks,
                        function: taskFunction,
                        priority: priority, // 'high', 'normal', 'low'
                        context: context,
                        resolve: resolve,
                        reject: reject,
                        createdAt: performance.now()
                    };
                    
                    // Insert task based on priority
                    if (priority === 'high') {
                        this.taskQueue.unshift(task);
                    } else {
                        this.taskQueue.push(task);
                    }
                    
                    this.processQueue();
                });
            }
            
            // Process the task queue in small chunks
            processQueue() {
                if (this.isProcessing || this.taskQueue.length === 0) {
                    return;
                }
                
                this.isProcessing = true;
                this.frameId = requestAnimationFrame(() => {
                    this.executeTaskBatch();
                });
            }
            
            executeTaskBatch() {
                const frameStartTime = performance.now();
                let tasksProcessed = 0;
                
                while (this.taskQueue.length > 0 && 
                       tasksProcessed < this.maxTasksPerFrame && 
                       (performance.now() - frameStartTime) < this.frameTimeLimit) {
                    
                    const task = this.taskQueue.shift();
                    this.executeTask(task);
                    tasksProcessed++;
                }
                
                // Schedule next batch if more tasks remain
                if (this.taskQueue.length > 0) {
                    this.frameId = requestAnimationFrame(() => {
                        this.executeTaskBatch();
                    });
                } else {
                    this.isProcessing = false;
                    this.frameId = null;
                }
            }
            
            executeTask(task) {
                const taskStartTime = performance.now();
                
                try {
                    const result = task.function.call(task.context);
                    
                    // Update performance metrics
                    const taskTime = performance.now() - taskStartTime;
                    this.updatePerformanceMetrics(taskTime);
                    this.completedTasks++;
                    
                    task.resolve(result);
                    
                } catch (error) {
                    console.error(`Async DOM task ${task.id} failed:`, error);
                    task.reject(error);
                }
            }
            
            updatePerformanceMetrics(taskTime) {
                // Running average calculation
                const alpha = 0.1; // Smoothing factor
                this.averageTaskTime = this.averageTaskTime * (1 - alpha) + taskTime * alpha;
            }
            
            // Schedule DOM-heavy operations that should be split across frames
            async scheduleHeavyDOMWork(workItems, processor, priority = 'normal') {
                const chunkSize = Math.max(1, Math.floor(workItems.length / 10)); // Split into 10 chunks
                const results = [];
                
                for (let i = 0; i < workItems.length; i += chunkSize) {
                    const chunk = workItems.slice(i, i + chunkSize);
                    
                    const chunkResult = await this.scheduleTask(() => {
                        return chunk.map(processor);
                    }, priority);
                    
                    results.push(...chunkResult);
                    
                    // Allow other high-priority tasks to run between chunks
                    if (i + chunkSize < workItems.length) {
                        await this.scheduleTask(() => {
                            // Yield to high-priority tasks
                        }, 'low');
                    }
                }
                
                return results;
            }
            
            // Schedule multiple related DOM operations as a sequence
            async scheduleSequence(operations, priority = 'normal') {
                const results = [];
                
                for (const operation of operations) {
                    const result = await this.scheduleTask(operation.task, priority, operation.context);
                    results.push(result);
                    
                    // Optional delay between operations
                    if (operation.delay) {
                        await new Promise(resolve => setTimeout(resolve, operation.delay));
                    }
                }
                
                return results;
            }
            
            // Create optimized search results using async scheduling
            async createSearchResultsAsync(results) {
                if (results.length === 0) return [];
                
                // For small result sets, process synchronously
                if (results.length <= 10) {
                    return this.scheduleTask(() => {
                        return results.map((result, index) => 
                            elementPool.createSuggestionElement(result, index)
                        );
                    }, 'high');
                }
                
                // For large result sets, split across multiple frames
                return this.scheduleHeavyDOMWork(
                    results, 
                    (result, index) => elementPool.createSuggestionElement(result, index),
                    'high'
                );
            }
            
            // Async man page content rendering
            async renderManPageContentAsync(contentSections) {
                return this.scheduleSequence(
                    contentSections.map((section, index) => ({
                        task: () => this.processManPageSection(section),
                        context: this,
                        delay: index > 0 ? 5 : 0 // Small delay between sections
                    })),
                    'normal'
                );
            }
            
            processManPageSection(section) {
                // Process man page section without blocking
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'man-section';
                sectionDiv.innerHTML = section.content;
                return sectionDiv;
            }
            
            // Clear task queue (cleanup)
            clear() {
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                    this.frameId = null;
                }
                
                // Reject all pending tasks
                this.taskQueue.forEach(task => {
                    task.reject(new Error('Task queue cleared'));
                });
                
                this.taskQueue = [];
                this.isProcessing = false;
            }
            
            // Get scheduler performance statistics
            getStats() {
                return {
                    totalTasks: this.totalTasks,
                    completedTasks: this.completedTasks,
                    pendingTasks: this.taskQueue.length,
                    completionRate: this.totalTasks > 0 ? 
                        (this.completedTasks / this.totalTasks * 100).toFixed(1) + '%' : '0%',
                    averageTaskTime: this.averageTaskTime.toFixed(2) + 'ms',
                    isProcessing: this.isProcessing,
                    maxTasksPerFrame: this.maxTasksPerFrame,
                    frameTimeLimit: this.frameTimeLimit
                };
            }
            
            // Adjust performance settings dynamically
            adjustPerformance(options = {}) {
                if (options.maxTasksPerFrame !== undefined) {
                    this.maxTasksPerFrame = Math.max(1, options.maxTasksPerFrame);
                }
                if (options.frameTimeLimit !== undefined) {
                    this.frameTimeLimit = Math.max(8, options.frameTimeLimit); // Min 8ms
                }
                
                console.log(`AsyncDOMScheduler performance adjusted: ${this.maxTasksPerFrame} tasks/frame, ${this.frameTimeLimit}ms limit`);
            }
        }

        // Virtual Scroll Manager for efficient rendering of large lists
        class VirtualScrollManager {
            constructor(container, options = {}) {
                this.container = container;
                this.scrollContainer = options.scrollContainer || container;
                
                // Configuration
                this.itemHeight = options.itemHeight || 50; // Default estimated height
                this.bufferSize = options.bufferSize || 5; // Extra items to render above/below
                this.throttleDelay = options.throttleDelay || 16; // ~60fps
                
                // Memory management configuration
                this.maxCacheSize = options.maxCacheSize || 1000; // Limit cached item heights
                this.cleanupThreshold = Math.floor(this.maxCacheSize * 0.8); // Start cleanup at 80%
                this.maxVisibleItems = options.maxVisibleItems || 100; // Limit rendered items
                
                // State management
                this.items = []; // All items data
                this.visibleItems = new Map(); // Currently rendered items
                this.itemHeights = new Map(); // Measured item heights
                this.totalHeight = 0;
                this.scrollTop = 0;
                this.containerHeight = 0;
                this.startIndex = 0;
                this.endIndex = 0;
                
                // Performance tracking
                this.renderCount = 0;
                this.lastRenderTime = 0;
                
                // DOM elements
                this.viewport = null;
                this.spacerTop = null;
                this.spacerBottom = null;
                
                // Event handling
                this.scrollHandler = this.throttle(this.handleScroll.bind(this), this.throttleDelay);
                this.resizeObserver = null;
                
                this.init();
            }
            
            init() {
                // Create virtual scroll structure
                this.createVirtualScrollStructure();
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Initial measurement
                this.measureContainer();
            }
            
            createVirtualScrollStructure() {
                // Clear existing content
                this.container.innerHTML = '';
                
                // Create spacer elements for virtual positioning
                this.spacerTop = document.createElement('div');
                this.spacerTop.style.height = '0px';
                this.spacerTop.style.pointerEvents = 'none';
                
                this.viewport = document.createElement('div');
                this.viewport.style.position = 'relative';
                
                this.spacerBottom = document.createElement('div');
                this.spacerBottom.style.height = '0px';
                this.spacerBottom.style.pointerEvents = 'none';
                
                this.container.appendChild(this.spacerTop);
                this.container.appendChild(this.viewport);
                this.container.appendChild(this.spacerBottom);
            }
            
            setupEventListeners() {
                // Scroll event listener
                this.scrollContainer.addEventListener('scroll', this.scrollHandler, { passive: true });
                
                // Resize observer for container size changes
                if (window.ResizeObserver) {
                    this.resizeObserver = new ResizeObserver(this.handleResize.bind(this));
                    this.resizeObserver.observe(this.scrollContainer);
                }
                
                // Fallback resize listener
                window.addEventListener('resize', this.handleResize.bind(this));
            }
            
            measureContainer() {
                const rect = this.scrollContainer.getBoundingClientRect();
                this.containerHeight = rect.height;
                this.scrollTop = this.scrollContainer.scrollTop;
            }
            
            handleScroll() {
                this.scrollTop = this.scrollContainer.scrollTop;
                this.updateVisibleRange();
                this.renderVisibleItems();
            }
            
            handleResize() {
                this.measureContainer();
                this.updateVisibleRange();
                this.renderVisibleItems();
            }
            
            // Calculate which items should be visible based on scroll position
            updateVisibleRange() {
                if (this.items.length === 0) {
                    this.startIndex = 0;
                    this.endIndex = 0;
                    return;
                }
                
                // Calculate visible range with buffer
                const visibleStart = Math.max(0, this.scrollTop);
                const visibleEnd = visibleStart + this.containerHeight;
                
                // Find start index
                this.startIndex = Math.max(0, 
                    Math.floor(visibleStart / this.itemHeight) - this.bufferSize
                );
                
                // Find end index
                this.endIndex = Math.min(this.items.length - 1,
                    Math.ceil(visibleEnd / this.itemHeight) + this.bufferSize
                );
                
                // Update spacer heights
                const topOffset = this.startIndex * this.itemHeight;
                const bottomOffset = (this.items.length - this.endIndex - 1) * this.itemHeight;
                
                this.spacerTop.style.height = `${topOffset}px`;
                this.spacerBottom.style.height = `${bottomOffset}px`;
            }
            
            // Render only the visible items
            async renderVisibleItems() {
                const renderStart = performance.now();
                
                // Get current visible item indices
                const currentIndices = new Set();
                for (let i = this.startIndex; i <= this.endIndex; i++) {
                    currentIndices.add(i);
                }
                
                // Remove items that are no longer visible
                for (const [index, element] of this.visibleItems) {
                    if (!currentIndices.has(index)) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                        // Return element to recycling pool if available
                        if (window.elementPool) {
                            elementPool.recycleElement(element);
                        }
                        this.visibleItems.delete(index);
                    }
                }
                
                // Add new visible items
                const elementsToAdd = [];
                for (let i = this.startIndex; i <= this.endIndex; i++) {
                    if (!this.visibleItems.has(i) && this.items[i]) {
                        const element = await this.createItemElement(this.items[i], i);
                        this.visibleItems.set(i, element);
                        elementsToAdd.push(element);
                    }
                }
                
                // Batch add new elements
                if (elementsToAdd.length > 0) {
                    const fragment = document.createDocumentFragment();
                    elementsToAdd.forEach(el => fragment.appendChild(el));
                    this.viewport.appendChild(fragment);
                }
                
                // Memory management: limit visible items if necessary
                this.limitVisibleItems();
                
                // Update performance metrics
                this.renderCount++;
                this.lastRenderTime = performance.now() - renderStart;
            }
            
            // Create an item element (can be overridden by subclasses)
            async createItemElement(item, index) {
                // Use element pool if available, otherwise create new element
                let element;
                if (window.elementPool) {
                    element = elementPool.getElement('div', 'virtual-scroll-item');
                } else {
                    element = document.createElement('div');
                    element.className = 'virtual-scroll-item';
                }
                
                // Set item content (this should be overridden for specific use cases)
                element.textContent = item.toString();
                element.style.height = `${this.itemHeight}px`;
                element.dataset.index = index;
                
                return element;
            }
            
            // Memory management: cleanup old cache entries
            cleanupItemCache() {
                if (this.itemHeights.size <= this.cleanupThreshold) {
                    return; // No cleanup needed
                }
                
                // Convert Map to array for sorting
                const entries = Array.from(this.itemHeights.entries());
                
                // Keep only the most recently used entries (by index proximity to current view)
                const currentCenter = Math.floor((this.startIndex + this.endIndex) / 2);
                entries.sort((a, b) => {
                    const distanceA = Math.abs(a[0] - currentCenter);
                    const distanceB = Math.abs(b[0] - currentCenter);
                    return distanceA - distanceB;
                });
                
                // Keep only the closest entries up to cleanupThreshold
                const toKeep = entries.slice(0, this.cleanupThreshold);
                const removedCount = this.itemHeights.size - toKeep.length;
                
                // Rebuild the map with only the entries to keep
                this.itemHeights.clear();
                toKeep.forEach(([index, height]) => {
                    this.itemHeights.set(index, height);
                });
                
                if (removedCount > 0) {
                    console.log(`VirtualScrollManager: Cleaned up ${removedCount} cached item heights`);
                }
            }
            
            // Check and cleanup visible items if too many
            limitVisibleItems() {
                if (this.visibleItems.size <= this.maxVisibleItems) {
                    return;
                }
                
                // Remove items that are furthest from the current view
                const currentCenter = Math.floor((this.startIndex + this.endIndex) / 2);
                const entries = Array.from(this.visibleItems.entries());
                
                entries.sort((a, b) => {
                    const distanceA = Math.abs(a[0] - currentCenter);
                    const distanceB = Math.abs(b[0] - currentCenter);
                    return distanceB - distanceA; // Sort by distance descending
                });
                
                // Remove the furthest items
                const toRemove = entries.slice(this.maxVisibleItems);
                toRemove.forEach(([index, element]) => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                    if (window.elementPool) {
                        elementPool.recycleElement(element);
                    }
                    this.visibleItems.delete(index);
                });
                
                if (toRemove.length > 0) {
                    console.log(`VirtualScrollManager: Removed ${toRemove.length} excess visible items`);
                }
            }
            
            // Update the items data and re-render
            async setItems(newItems) {
                this.items = newItems;
                this.totalHeight = this.items.length * this.itemHeight;
                
                // Trigger cache cleanup if approaching limits
                if (this.itemHeights.size > this.cleanupThreshold) {
                    this.cleanupItemCache();
                }
                
                // Clear current render
                this.clearVisibleItems();
                
                // Update range and render
                this.updateVisibleRange();
                await this.renderVisibleItems();
            }
            
            // Clear all visible items
            clearVisibleItems() {
                for (const [index, element] of this.visibleItems) {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                    // Return to recycling pool if available
                    if (window.elementPool) {
                        elementPool.recycleElement(element);
                    }
                }
                this.visibleItems.clear();
            }
            
            // Get an item by index
            getItem(index) {
                return this.items[index];
            }
            
            // Scroll to a specific item
            scrollToItem(index) {
                if (index < 0 || index >= this.items.length) return;
                
                const targetScroll = index * this.itemHeight;
                this.scrollContainer.scrollTop = targetScroll;
                this.handleScroll(); // Force immediate update
            }
            
            // Throttle function for performance
            throttle(func, delay) {
                let timeoutId;
                let lastExecTime = 0;
                
                return function (...args) {
                    const currentTime = Date.now();
                    
                    if (currentTime - lastExecTime > delay) {
                        func.apply(this, args);
                        lastExecTime = currentTime;
                    } else {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            func.apply(this, args);
                            lastExecTime = Date.now();
                        }, delay - (currentTime - lastExecTime));
                    }
                };
            }
            
            // Get performance statistics
            getStats() {
                return {
                    totalItems: this.items.length,
                    visibleItems: this.visibleItems.size,
                    startIndex: this.startIndex,
                    endIndex: this.endIndex,
                    renderCount: this.renderCount,
                    lastRenderTime: this.lastRenderTime.toFixed(2) + 'ms',
                    containerHeight: this.containerHeight,
                    totalHeight: this.totalHeight,
                    scrollTop: this.scrollTop,
                    itemHeight: this.itemHeight,
                    bufferSize: this.bufferSize
                };
            }
            
            // Cleanup resources
            destroy() {
                // Remove event listeners
                this.scrollContainer.removeEventListener('scroll', this.scrollHandler);
                window.removeEventListener('resize', this.handleResize);
                
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                    this.resizeObserver = null;
                }
                
                // Clear visible items
                this.clearVisibleItems();
                
                // Clear memory caches
                this.itemHeights.clear();
                this.items = [];
                
                // Clear container
                if (this.container) {
                    this.container.innerHTML = '';
                }
                
                // Clear references
                this.container = null;
                this.scrollContainer = null;
                this.viewport = null;
                this.spacerTop = null;
                this.spacerBottom = null;
                this.scrollHandler = null;
                
                console.log('VirtualScrollManager destroyed and cleaned up');
            }
        }

        // Specialized Virtual Scroll Manager for Search Suggestions
        class VirtualSearchManager extends VirtualScrollManager {
            constructor(container, options = {}) {
                // Search-specific default options
                const searchOptions = {
                    itemHeight: 53, // Height of a suggestion item (12px padding + content + 1px border)
                    bufferSize: 3, // Keep buffer small for suggestions
                    throttleDelay: 8, // More responsive for search
                    ...options
                };
                
                super(container, searchOptions);
                
                // Search-specific properties
                this.selectedIndex = -1;
                this.isEnabled = false;
                this.keyboardHandler = this.handleKeyboard.bind(this);
                this.clickHandler = this.handleItemClick.bind(this);
                
                this.setupSearchEvents();
            }
            
            setupSearchEvents() {
                // Set up keyboard navigation
                document.addEventListener('keydown', this.keyboardHandler);
                
                // Set up click handling for virtual items
                this.container.addEventListener('click', this.clickHandler);
            }
            
            // Override createItemElement for search suggestions
            async createItemElement(item, index) {
                let element;
                if (window.elementPool) {
                    element = elementPool.getElement('div', 'suggestion virtual-suggestion');
                } else {
                    element = document.createElement('div');
                    element.className = 'suggestion virtual-suggestion';
                }
                
                // Set suggestion content using the same structure as regular suggestions
                element.style.height = `${this.itemHeight}px`;
                element.style.boxSizing = 'border-box';
                element.dataset.index = index;
                element.dataset.command = item.command;
                element.dataset.section = item.section;
                
                // Create suggestion content structure
                const leftDiv = document.createElement('div');
                leftDiv.innerHTML = `
                    <strong>${item.command}</strong>
                    <span style="color: #666; margin-left: 8px;">${item.section}</span>
                `;
                
                const rightDiv = document.createElement('div');
                rightDiv.style.color = '#999';
                rightDiv.style.fontSize = '12px';
                rightDiv.textContent = item.description ? item.description.substring(0, 50) + '...' : '';
                
                element.appendChild(leftDiv);
                element.appendChild(rightDiv);
                
                // Apply selection styling if this is the selected item
                if (index === this.selectedIndex) {
                    element.classList.add('selected');
                }
                
                return element;
            }
            
            // Enhanced setItems for search results with dynamic update handling
            async setSearchResults(results, options = {}) {
                const {
                    preserveSelection = false,
                    preserveScrollPosition = false,
                    animateChanges = false
                } = options;
                
                this.isEnabled = results.length > 20; // Only use virtual scrolling for large result sets
                
                if (!this.isEnabled) {
                    // For small result sets, fall back to regular rendering
                    return null;
                }
                
                // Store current state for dynamic updates
                const previousScrollPosition = this.scrollTop;
                const previousSelectedItem = this.getSelectedItem();
                const previousItemCount = this.items.length;
                
                await this.setItems(results);
                
                // Handle selection preservation
                if (preserveSelection && previousSelectedItem) {
                    // Try to find the same item in the new results
                    const newIndex = results.findIndex(item => 
                        item.command === previousSelectedItem.command && 
                        item.section === previousSelectedItem.section
                    );
                    if (newIndex >= 0) {
                        this.selectedIndex = newIndex;
                        this.ensureSelectedVisible();
                    } else {
                        this.selectedIndex = -1;
                    }
                } else {
                    // Reset selection for new results
                    this.selectedIndex = -1;
                }
                
                // Handle scroll position preservation
                if (preserveScrollPosition && previousItemCount > 0) {
                    // Calculate relative position and maintain it
                    const relativePosition = previousScrollPosition / (previousItemCount * this.itemHeight);
                    const newScrollPosition = relativePosition * (results.length * this.itemHeight);
                    
                    // Smoothly transition to new position
                    if (animateChanges) {
                        this.smoothScrollTo(newScrollPosition);
                    } else {
                        this.scrollContainer.scrollTop = newScrollPosition;
                        this.handleScroll();
                    }
                }
                
                this.updateSelection();
                
                return true; // Indicates virtual scrolling is being used
            }
            
            // Smooth scroll to a specific position
            smoothScrollTo(targetPosition) {
                const startPosition = this.scrollContainer.scrollTop;
                const distance = targetPosition - startPosition;
                const duration = 300; // milliseconds
                const startTime = performance.now();
                
                const animateScroll = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function (ease-out)
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    this.scrollContainer.scrollTop = startPosition + (distance * eased);
                    this.handleScroll();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateScroll);
                    }
                };
                
                requestAnimationFrame(animateScroll);
            }
            
            // Update search results incrementally (for filtered/sorted results)
            async updateSearchResults(newResults, updateType = 'replace') {
                switch (updateType) {
                    case 'replace':
                        return this.setSearchResults(newResults, { preserveScrollPosition: true });
                        
                    case 'append':
                        const combinedResults = [...this.items, ...newResults];
                        return this.setSearchResults(combinedResults, { 
                            preserveSelection: true, 
                            preserveScrollPosition: true 
                        });
                        
                    case 'prepend':
                        const prependedResults = [...newResults, ...this.items];
                        // Adjust scroll position to account for prepended items
                        const scrollOffset = newResults.length * this.itemHeight;
                        await this.setSearchResults(prependedResults);
                        this.scrollContainer.scrollTop += scrollOffset;
                        this.handleScroll();
                        return true;
                        
                    case 'filter':
                        // Filter existing results based on new criteria
                        return this.setSearchResults(newResults, { 
                            preserveSelection: true,
                            animateChanges: true 
                        });
                        
                    default:
                        return this.setSearchResults(newResults);
                }
            }
            
            // Handle live search updates (debounced)
            handleLiveUpdate(results, query) {
                // Clear any pending update
                if (this.updateTimeout) {
                    clearTimeout(this.updateTimeout);
                }
                
                // Debounce rapid updates
                this.updateTimeout = setTimeout(() => {
                    this.updateSearchResults(results, 'replace').then(() => {
                        console.log(`Virtual scroll updated with ${results.length} results for query: "${query}"`);
                    });
                }, 50); // Short debounce for responsiveness
            }
            
            // Handle keyboard navigation
            handleKeyboard(event) {
                if (!this.isEnabled || this.items.length === 0) return;
                
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    this.selectNext();
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    this.selectPrevious();
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    this.selectCurrent();
                } else if (event.key === 'Escape') {
                    this.clearSelection();
                }
            }
            
            // Handle item clicks
            handleItemClick(event) {
                const suggestionElement = event.target.closest('.virtual-suggestion');
                if (!suggestionElement) return;
                
                const index = parseInt(suggestionElement.dataset.index);
                this.selectedIndex = index;
                this.selectCurrent();
            }
            
            selectNext() {
                if (this.selectedIndex < this.items.length - 1) {
                    this.selectedIndex++;
                    this.updateSelection();
                    this.ensureSelectedVisible();
                }
            }
            
            selectPrevious() {
                if (this.selectedIndex > 0) {
                    this.selectedIndex--;
                    this.updateSelection();
                    this.ensureSelectedVisible();
                } else if (this.selectedIndex === -1 && this.items.length > 0) {
                    this.selectedIndex = this.items.length - 1;
                    this.updateSelection();
                    this.ensureSelectedVisible();
                }
            }
            
            selectCurrent() {
                if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
                    const selectedItem = this.items[this.selectedIndex];
                    
                    // Trigger the same selection behavior as regular suggestions
                    if (window.displayManPage && selectedItem.command && selectedItem.section) {
                        displayManPage(selectedItem.command, selectedItem.section);
                    }
                    
                    // Hide suggestions
                    this.container.style.display = 'none';
                }
            }
            
            clearSelection() {
                this.selectedIndex = -1;
                this.updateSelection();
                this.container.style.display = 'none';
            }
            
            updateSelection() {
                // Update selection styling for all visible items
                for (const [index, element] of this.visibleItems) {
                    if (index === this.selectedIndex) {
                        element.classList.add('selected');
                    } else {
                        element.classList.remove('selected');
                    }
                }
            }
            
            ensureSelectedVisible() {
                if (this.selectedIndex >= 0) {
                    // Calculate if selected item is visible
                    if (this.selectedIndex < this.startIndex || this.selectedIndex > this.endIndex) {
                        // Scroll to make selected item visible
                        this.scrollToItem(this.selectedIndex);
                    }
                }
            }
            
            // Override renderVisibleItems to handle selection updates
            async renderVisibleItems() {
                await super.renderVisibleItems();
                this.updateSelection(); // Ensure selection styling is applied
            }
            
            // Get currently selected item
            getSelectedItem() {
                if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
                    return this.items[this.selectedIndex];
                }
                return null;
            }
            
            // Clear and disable virtual scrolling
            disable() {
                this.isEnabled = false;
                this.selectedIndex = -1;
                this.clearVisibleItems();
                
                // Reset container to original state
                this.container.innerHTML = '';
            }
            
            // Enhanced stats for search
            getSearchStats() {
                const baseStats = super.getStats();
                return {
                    ...baseStats,
                    selectedIndex: this.selectedIndex,
                    isEnabled: this.isEnabled,
                    itemType: 'search-suggestions'
                };
            }
            
            // Cleanup
            destroy() {
                // Clear any pending updates
                if (this.updateTimeout) {
                    clearTimeout(this.updateTimeout);
                    this.updateTimeout = null;
                }
                
                document.removeEventListener('keydown', this.keyboardHandler);
                this.container.removeEventListener('click', this.clickHandler);
                super.destroy();
            }
        }

        // Progressive Index Loader for chunked loading of search index
        class ProgressiveIndexLoader {
            constructor() {
                this.chunks = [];
                this.loadedChunks = 0;
                this.totalChunks = 0;
                this.isLoading = false;
                this.loadingPromise = null;
                
                // Progress tracking
                this.progressCallback = null;
                this.loadStartTime = 0;
                this.chunkLoadTimes = [];
                
                // Priority levels for different command types
                this.priorityCommands = [
                    // Core system commands (highest priority)
                    'ls', 'cd', 'pwd', 'mkdir', 'rmdir', 'rm', 'cp', 'mv', 'chmod', 'chown',
                    'cat', 'less', 'more', 'head', 'tail', 'grep', 'find', 'locate',
                    
                    // File operations
                    'touch', 'ln', 'stat', 'file', 'which', 'whereis', 'diff', 'sort', 'uniq',
                    
                    // Process management
                    'ps', 'top', 'htop', 'kill', 'killall', 'jobs', 'bg', 'fg', 'nohup',
                    
                    // Text processing
                    'awk', 'sed', 'cut', 'tr', 'wc', 'sort', 'uniq', 'join', 'paste',
                    
                    // Network
                    'wget', 'curl', 'ssh', 'scp', 'rsync', 'ping', 'netstat', 'ss',
                    
                    // Archive/compression
                    'tar', 'gzip', 'gunzip', 'zip', 'unzip', '7z'
                ];
            }
            
            // Initialize progressive loading
            async startProgressiveLoading(progressCallback = null) {
                if (this.isLoading) {
                    return this.loadingPromise;
                }
                
                this.progressCallback = progressCallback;
                this.isLoading = true;
                this.loadStartTime = performance.now();
                
                this.loadingPromise = this.performProgressiveLoading();
                return this.loadingPromise;
            }
            
            async performProgressiveLoading() {
                try {
                    // Check if we have a progressive index available
                    const hasProgressiveIndex = await this.checkProgressiveIndexAvailable();
                    
                    if (hasProgressiveIndex) {
                        // Load in chunks
                        await this.loadInChunks();
                    } else {
                        // Fallback to loading full index and splitting it
                        await this.loadFullIndexAndSplit();
                    }
                    
                    this.reportProgress(100, 'Index loading complete');
                    console.log(`Progressive index loading completed in ${(performance.now() - this.loadStartTime).toFixed(2)}ms`);
                    
                } catch (error) {
                    console.error('Progressive loading failed:', error);
                    this.reportProgress(100, 'Loading failed, falling back to full index');
                    // Fallback to original loading method
                    await ensureSearchIndex();
                } finally {
                    this.isLoading = false;
                }
            }
            
            async checkProgressiveIndexAvailable() {
                // Progressive chunks are not available in this build
                // Always return false to use the standard index.js
                return false;
            }
            
            async loadInChunks() {
                // Load priority chunk first
                this.reportProgress(5, 'Loading priority commands...');
                await this.loadChunk(0, 'priority');
                
                // Determine number of additional chunks
                const chunkCount = await this.determineChunkCount();
                this.totalChunks = chunkCount + 1; // +1 for priority chunk
                
                // Load remaining chunks in background
                for (let i = 1; i < chunkCount; i++) {
                    this.reportProgress(
                        5 + (i / chunkCount) * 90,
                        `Loading command set ${i}/${chunkCount - 1}...`
                    );
                    
                    await this.loadChunk(i, 'background');
                    
                    // Small delay to prevent blocking
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            async loadFullIndexAndSplit() {
                this.reportProgress(10, 'Loading search index...');
                
                // Load the full index
                const success = await loadDataFile('data/index.js', 'searchIndex');
                if (!success) {
                    throw new Error('Failed to load search index');
                }
                
                this.reportProgress(50, 'Processing search index...');
                
                // Split into priority and background sets
                await this.processFullIndex();
                
                this.reportProgress(90, 'Building search structures...');
                
                // Build the optimized search index
                buildOptimizedSearchIndex();
            }
            
            async processFullIndex() {
                if (!window.searchIndex) return;
                
                const prioritySet = new Set(this.priorityCommands);
                const priorityEntries = [];
                const backgroundEntries = [];
                
                // Split entries by priority
                for (const entry of window.searchIndex) {
                    const command = entry.command.toLowerCase();
                    if (prioritySet.has(command)) {
                        priorityEntries.push(entry);
                    } else {
                        backgroundEntries.push(entry);
                    }
                }
                
                // Process priority commands first
                await this.processChunk(priorityEntries, 'priority');
                
                // Process background commands in smaller batches
                const batchSize = Math.max(50, Math.floor(backgroundEntries.length / 10));
                for (let i = 0; i < backgroundEntries.length; i += batchSize) {
                    const batch = backgroundEntries.slice(i, i + batchSize);
                    await this.processChunk(batch, 'background');
                    
                    // Allow other tasks to run
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
            }
            
            async loadChunk(chunkIndex, priority) {
                const chunkStartTime = performance.now();
                
                try {
                    const filename = `data/index_chunk_${chunkIndex}.js`;
                    const success = await loadDataFile(filename, `searchIndexChunk${chunkIndex}`);
                    
                    if (success) {
                        // Process the loaded chunk
                        const chunkData = window[`searchIndexChunk${chunkIndex}`];
                        if (chunkData) {
                            await this.processChunk(chunkData, priority);
                        }
                    }
                    
                    this.loadedChunks++;
                    const chunkTime = performance.now() - chunkStartTime;
                    this.chunkLoadTimes.push(chunkTime);
                    
                    console.log(`Chunk ${chunkIndex} (${priority}) loaded in ${chunkTime.toFixed(2)}ms`);
                    
                } catch (error) {
                    console.warn(`Failed to load chunk ${chunkIndex}:`, error);
                }
            }
            
            async processChunk(entries, priority) {
                // Initialize search structures if needed
                if (!searchIndexMap) {
                    searchIndexMap = new Map();
                    searchIndexByPrefix = new Map();
                    tokenizedDescriptions = new Map();
                }
                
                // Process entries using async scheduling for large chunks
                if (entries.length > 100) {
                    await asyncDOMScheduler.scheduleTask(() => {
                        this.addEntriesToIndex(entries);
                    }, priority === 'priority' ? 'high' : 'normal');
                } else {
                    this.addEntriesToIndex(entries);
                }
            }
            
            addEntriesToIndex(entries) {
                for (const entry of entries) {
                    const commandLower = entry.command.toLowerCase();
                    
                    // Exact command lookup map
                    if (!searchIndexMap.has(commandLower)) {
                        searchIndexMap.set(commandLower, []);
                    }
                    searchIndexMap.get(commandLower).push(entry);

                    // Prefix index (first 2-4 characters)
                    for (let len = 2; len <= Math.min(4, commandLower.length); len++) {
                        const prefix = commandLower.substring(0, len);
                        if (!searchIndexByPrefix.has(prefix)) {
                            searchIndexByPrefix.set(prefix, new Set());
                        }
                        searchIndexByPrefix.get(prefix).add(entry);
                    }

                    // Tokenize and index description
                    if (entry.description) {
                        const descLower = entry.description.toLowerCase();
                        const tokens = descLower.split(/\s+/).filter(t => t.length > 2);
                        tokenizedDescriptions.set(entry, { descLower, tokens });
                    }
                }
            }
            
            async determineChunkCount() {
                // Try to determine how many chunks exist
                let count = 1;
                for (let i = 1; i <= 10; i++) { // Max 10 chunks
                    try {
                        const response = await fetch(`data/index_chunk_${i}.js`, { method: 'HEAD' });
                        if (response.ok) {
                            count++;
                        } else {
                            break;
                        }
                    } catch {
                        break;
                    }
                }
                return count;
            }
            
            reportProgress(percentage, message) {
                if (this.progressCallback) {
                    this.progressCallback(percentage, message);
                }
                
                // Also update the status for user feedback
                if (percentage < 100) {
                    showStatus(`${message} (${percentage.toFixed(0)}%)`);
                }
            }
            
            // Check if priority commands are loaded
            isPriorityLoaded() {
                if (!searchIndexMap) return false;
                
                // Check if at least 80% of priority commands are available
                let foundCount = 0;
                for (const cmd of this.priorityCommands) {
                    if (searchIndexMap.has(cmd)) {
                        foundCount++;
                    }
                }
                
                return foundCount >= this.priorityCommands.length * 0.8;
            }
            
            // Get loading statistics
            getLoadingStats() {
                return {
                    isLoading: this.isLoading,
                    loadedChunks: this.loadedChunks,
                    totalChunks: this.totalChunks,
                    completionPercentage: this.totalChunks > 0 ? 
                        (this.loadedChunks / this.totalChunks * 100).toFixed(1) : 0,
                    averageChunkTime: this.chunkLoadTimes.length > 0 ?
                        (this.chunkLoadTimes.reduce((a, b) => a + b, 0) / this.chunkLoadTimes.length).toFixed(2) : 0,
                    totalLoadTime: this.loadStartTime > 0 ? 
                        (performance.now() - this.loadStartTime).toFixed(2) : 0,
                    priorityCommandsLoaded: this.isPriorityLoaded()
                };
            }
        }

        // Theme Performance Manager for optimized theme switching
        class ThemePerformanceManager {
            constructor() {
                this.cssCache = new Map();
                this.preloadedThemes = new Set();
                this.transitionDuration = 300; // milliseconds
                this.isTransitioning = false;
                this.pendingTheme = null;
                this.themeQueue = []; // Queue for multiple pending theme switches
                this.transitionCleanupTimer = null; // Store timer reference
                
                // Performance tracking
                this.switchTimes = [];
                this.preloadTimes = [];
                
                // CSS injection optimization
                this.styleElement = null;
                this.transitionElement = null;
                
                this.init();
            }
            
            init() {
                // Create optimized style element for theme CSS
                this.styleElement = document.createElement('style');
                this.styleElement.id = 'theme-performance-styles';
                document.head.appendChild(this.styleElement);
                
                // Create transition overlay for smooth switches
                this.createTransitionOverlay();
                
                // Set up intersection observer for visible theme options
                this.setupThemePreloading();
            }
            
            createTransitionOverlay() {
                this.transitionElement = document.createElement('div');
                this.transitionElement.id = 'theme-transition-overlay';
                this.transitionElement.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.1);
                    backdrop-filter: blur(2px);
                    z-index: 9999;
                    opacity: 0;
                    pointer-events: none;
                    transition: opacity ${this.transitionDuration * 0.4}ms ease;
                `;
                document.body.appendChild(this.transitionElement);
            }
            
            // Preload themes in the background
            async preloadThemes(themesToPreload = []) {
                if (!window.themes) return;
                
                const startTime = performance.now();
                const preloadPromises = [];
                
                // Determine which themes to preload
                const targetThemes = themesToPreload.length > 0 ? 
                    themesToPreload : 
                    window.themes.slice(0, 5); // Preload first 5 themes by default
                
                for (const theme of targetThemes) {
                    if (theme.file && !this.preloadedThemes.has(theme.file)) {
                        preloadPromises.push(this.preloadTheme(theme));
                    }
                }
                
                await Promise.allSettled(preloadPromises);
                
                const preloadTime = performance.now() - startTime;
                this.preloadTimes.push(preloadTime);
                
                console.log(`Preloaded ${preloadPromises.length} themes in ${preloadTime.toFixed(2)}ms`);
            }
            
            async preloadTheme(theme) {
                if (!theme.file || this.preloadedThemes.has(theme.file)) {
                    return;
                }
                
                try {
                    const css = await this.loadThemeCSS(theme);
                    this.preloadedThemes.add(theme.file);
                    return css;
                } catch (error) {
                    console.warn(`Failed to preload theme ${theme.name}:`, error);
                }
            }
            
            async loadThemeCSS(theme) {
                if (!theme.file) {
                    return '';
                }
                
                // Check cache first
                if (this.cssCache.has(theme.file)) {
                    return this.cssCache.get(theme.file);
                }
                
                try {
                    // Use async DOM scheduler for non-blocking loading
                    const css = await asyncDOMScheduler.scheduleTask(async () => {
                        const response = await fetch(theme.file);
                        if (!response.ok) {
                            throw new Error(`Failed to load ${theme.file}: ${response.status}`);
                        }
                        return await response.text();
                    }, 'high');
                    
                    this.cssCache.set(theme.file, css);
                    return css;
                    
                } catch (error) {
                    console.error('Error loading theme CSS:', error);
                    return '';
                }
            }
            
            // Optimized theme switching with smooth transitions
            async switchTheme(themeIndex, options = {}) {
                const {
                    useTransition = true,
                    skipPreload = false,
                    force = false
                } = options;
                
                if (this.isTransitioning && !force) {
                    // Queue the theme switch, avoiding duplicates
                    if (!this.themeQueue.includes(themeIndex)) {
                        this.themeQueue.push(themeIndex);
                    }
                    return;
                }
                
                if (!window.themes || !window.themes[themeIndex]) {
                    console.warn(`Invalid theme index: ${themeIndex}, available themes: ${window.themes ? window.themes.length : 0}, falling back to index 0`);
                    themeIndex = 0; // Fall back to first theme
                    if (!window.themes || !window.themes[themeIndex]) {
                        console.error('No themes available');
                        return;
                    }
                }
                
                const startTime = performance.now();
                const theme = window.themes[themeIndex];
                
                this.isTransitioning = true;
                
                try {
                    // Phase 1: Start transition
                    if (useTransition) {
                        this.startTransition();
                    }
                    
                    // Phase 2: Load theme CSS (with preloading optimization)
                    const css = await this.loadThemeCSS(theme);
                    
                    // Phase 3: Apply theme using batched DOM operations
                    await this.applyThemeOptimized(theme, css);
                    
                    // Phase 4: Complete transition
                    if (useTransition) {
                        await this.completeTransition();
                    }
                    
                    // Phase 5: Background preload related themes
                    if (!skipPreload) {
                        this.preloadRelatedThemes(themeIndex);
                    }
                    
                    const switchTime = performance.now() - startTime;
                    this.switchTimes.push(switchTime);
                    
                    console.log(`Theme switch completed in ${switchTime.toFixed(2)}ms`);
                    
                    // Process next theme in queue if any
                    this.processNextThemeInQueue();
                    
                } catch (error) {
                    console.error('Theme switch failed:', error);
                    this.isTransitioning = false;
                    
                    // Clean up transition state
                    if (this.transitionCleanupTimer) {
                        clearTimeout(this.transitionCleanupTimer);
                        this.transitionCleanupTimer = null;
                    }
                    document.body.classList.remove('theme-transitioning');
                    
                    if (useTransition && this.transitionElement) {
                        this.transitionElement.style.opacity = '0';
                    }
                    
                    // Still process next theme in queue even if current one failed
                    this.processNextThemeInQueue();
                }
            }
            
            // Process the next theme switch in the queue
            processNextThemeInQueue() {
                if (this.themeQueue.length > 0) {
                    const nextThemeIndex = this.themeQueue.shift();
                    setTimeout(() => {
                        this.switchTheme(nextThemeIndex, { useTransition: false });
                    }, 50); // Small delay to ensure current transition cleanup is complete
                }
                
                // Maintain backward compatibility with legacy pendingTheme
                if (this.pendingTheme !== null) {
                    const pendingIndex = this.pendingTheme;
                    this.pendingTheme = null;
                    setTimeout(() => {
                        this.switchTheme(pendingIndex, { useTransition: false });
                    }, 50);
                }
            }
            
            startTransition() {
                // Cancel any existing cleanup timer
                if (this.transitionCleanupTimer) {
                    clearTimeout(this.transitionCleanupTimer);
                    this.transitionCleanupTimer = null;
                }
                
                // Remove any lingering transition class
                document.body.classList.remove('theme-transitioning');
                
                // Show transition overlay
                this.transitionElement.style.opacity = '0.5';
                
                // Add transition preparation class
                document.body.classList.add('theme-transitioning');
            }
            
            async applyThemeOptimized(theme, css) {
                // Use DOM batch updater for optimal performance
                await domBatchUpdater.batch([
                    {
                        type: 'write',
                        operation: () => {
                            // Update CSS in one operation
                            if (this.styleElement) {
                                this.styleElement.textContent = css;
                            }
                            
                            // Fallback: update main theme styles element
                            const mainThemeStyles = document.getElementById('theme-styles');
                            if (mainThemeStyles) {
                                mainThemeStyles.textContent = css;
                            }
                        }
                    },
                    {
                        type: 'write',
                        operation: () => {
                            // Remove all theme classes efficiently
                            const currentClasses = Array.from(document.body.classList);
                            const themeClasses = window.themes
                                .filter(t => t.class)
                                .map(t => t.class);
                            
                            themeClasses.forEach(cls => {
                                if (currentClasses.includes(cls)) {
                                    document.body.classList.remove(cls);
                                }
                            });
                            
                            // Add new theme class
                            if (theme.class) {
                                document.body.classList.add(theme.class);
                            }
                        }
                    },
                    {
                        type: 'write',
                        operation: () => {
                            // Update theme icon and save preference
                            const themeIcon = document.querySelector('.theme-icon');
                            if (themeIcon) {
                                themeIcon.textContent = theme.icon;
                            }
                            
                            localStorage.setItem('theme', theme.class || '');
                            
                            // Update theme CSS variables
                            updateThemeVariables(theme.class || '');
                        }
                    }
                ]);
            }
            
            async completeTransition() {
                // Wait for CSS to take effect
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Hide transition overlay
                this.transitionElement.style.opacity = '0';
                
                // Cancel any existing cleanup timer
                if (this.transitionCleanupTimer) {
                    clearTimeout(this.transitionCleanupTimer);
                }
                
                // Remove transition class after animation
                this.transitionCleanupTimer = setTimeout(() => {
                    document.body.classList.remove('theme-transitioning');
                    this.isTransitioning = false;
                    this.transitionCleanupTimer = null;
                }, this.transitionDuration);
            }
            
            // Preload themes that are likely to be used next
            preloadRelatedThemes(currentIndex) {
                if (!window.themes) return;
                
                // Preload adjacent themes
                const relatedIndices = [
                    currentIndex - 1,
                    currentIndex + 1
                ].filter(index => index >= 0 && index < window.themes.length);
                
                // Preload popular themes if not already loaded
                const popularThemes = ['dark', 'light', 'dracula', 'monokai'];
                const popularIndices = popularThemes
                    .map(name => window.themes.findIndex(t => 
                        t.name.toLowerCase().includes(name.toLowerCase())
                    ))
                    .filter(index => index >= 0);
                
                const themesToPreload = [...relatedIndices, ...popularIndices]
                    .filter((index, i, arr) => arr.indexOf(index) === i) // Remove duplicates
                    .map(index => window.themes[index])
                    .filter(theme => theme.file && !this.preloadedThemes.has(theme.file));
                
                if (themesToPreload.length > 0) {
                    setTimeout(() => {
                        this.preloadThemes(themesToPreload);
                    }, 500); // Small delay to not interfere with current switch
                }
            }
            
            setupThemePreloading() {
                // Set up intersection observer for theme options in modal
                if (window.IntersectionObserver) {
                    const themeObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const themeIndex = parseInt(entry.target.dataset.themeIndex);
                                if (!isNaN(themeIndex) && window.themes[themeIndex]) {
                                    this.preloadTheme(window.themes[themeIndex]);
                                }
                            }
                        });
                    }, {
                        rootMargin: '50px',
                        threshold: 0.1
                    });
                    
                    this.themeObserver = themeObserver;
                }
            }
            
            // Observe theme option elements for preloading
            observeThemeOptions(themeElements) {
                if (this.themeObserver) {
                    themeElements.forEach(element => {
                        this.themeObserver.observe(element);
                    });
                }
            }
            
            // Get performance statistics
            getPerformanceStats() {
                const avgSwitchTime = this.switchTimes.length > 0 ?
                    this.switchTimes.reduce((a, b) => a + b, 0) / this.switchTimes.length : 0;
                
                const avgPreloadTime = this.preloadTimes.length > 0 ?
                    this.preloadTimes.reduce((a, b) => a + b, 0) / this.preloadTimes.length : 0;
                
                return {
                    cachedThemes: this.cssCache.size,
                    preloadedThemes: this.preloadedThemes.size,
                    avgSwitchTime: avgSwitchTime.toFixed(2) + 'ms',
                    avgPreloadTime: avgPreloadTime.toFixed(2) + 'ms',
                    totalSwitches: this.switchTimes.length,
                    isTransitioning: this.isTransitioning,
                    pendingTheme: this.pendingTheme,
                    queuedThemes: this.themeQueue.length,
                    themeQueue: [...this.themeQueue] // Copy for debugging
                };
            }
            
            // Clear cache and reset
            clearCache() {
                this.cssCache.clear();
                this.preloadedThemes.clear();
                this.switchTimes = [];
                this.preloadTimes = [];
                this.themeQueue = [];
                this.pendingTheme = null;
                console.log('Theme performance cache cleared');
            }
            
            // Cleanup
            destroy() {
                // Cancel any pending transitions
                if (this.transitionCleanupTimer) {
                    clearTimeout(this.transitionCleanupTimer);
                    this.transitionCleanupTimer = null;
                }
                
                // Remove transition class
                document.body.classList.remove('theme-transitioning');
                
                if (this.themeObserver) {
                    this.themeObserver.disconnect();
                }
                
                if (this.transitionElement) {
                    this.transitionElement.remove();
                }
                
                if (this.styleElement) {
                    this.styleElement.remove();
                }
                
                this.clearCache();
            }
        }

        // Intelligent Preloading Manager with usage analytics and predictive loading
        class IntelligentPreloadingManager {
            constructor() {
                // Analytics tracking
                this.userBehavior = {
                    searchQueries: [],
                    commandAccesses: new Map(),
                    navigationPatterns: [],
                    sessionTime: Date.now(),
                    timeSpentOnCommands: new Map(),
                    searchToCommandConversions: new Map()
                };
                
                // Preloading state
                this.preloadQueue = [];
                this.activePreloads = new Set();
                this.preloadCache = new Map();
                this.maxCacheSize = 50; // Max preloaded items
                this.preloadedCommands = new Set();
                
                // Learning algorithms
                this.commandFrequency = new Map();
                this.commandSequences = [];
                this.timeBasedPatterns = new Map(); // Hour -> popular commands
                this.searchPatterns = new Map(); // Query patterns -> likely commands
                
                // Configuration
                this.preloadThreshold = 0.3; // Confidence threshold for preloading
                this.maxPreloadsPerSession = 20;
                this.currentPreloads = 0;
                
                // Performance tracking
                this.preloadHits = 0;
                this.preloadMisses = 0;
                this.totalPreloadTime = 0;
                this.lastAnalyticsUpdate = Date.now();
                
                // Timer and event listener tracking for cleanup
                this.analyticsInterval = null;
                this.setupTimeout = null;
                this.initialPreloadTimeout = null;
                this.eventListeners = [];
                
                this.init();
            }
            
            init() {
                // Load historical data from localStorage
                this.loadHistoricalData();
                
                // Start periodic analytics processing
                this.startAnalyticsProcessing();
                
                // Defer setup until DOM elements are available
                if (document.readyState === 'loading') {
                    const domHandler = () => {
                        this.setupBehaviorTracking();
                    };
                    document.addEventListener('DOMContentLoaded', domHandler);
                    this.eventListeners.push({ element: document, event: 'DOMContentLoaded', handler: domHandler });
                } else {
                    // DOM is already ready
                    this.setupTimeout = setTimeout(() => {
                        this.setupBehaviorTracking();
                    }, 100);
                }
                
                // Initial preloading based on historical data
                this.initialPreloadTimeout = setTimeout(() => {
                    this.performInitialPreloading();
                }, 3000); // Delay to not interfere with page load
            }
            
            loadHistoricalData() {
                try {
                    const saved = localStorage.getItem('intelligentPreloadingData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.commandFrequency = new Map(data.commandFrequency || []);
                        this.searchPatterns = new Map(data.searchPatterns || []);
                        this.timeBasedPatterns = new Map(data.timeBasedPatterns || []);
                        
                        console.log(`Loaded preloading analytics: ${this.commandFrequency.size} commands, ${this.searchPatterns.size} search patterns`);
                    }
                } catch (error) {
                    console.warn('Failed to load preloading analytics:', error);
                }
            }
            
            saveAnalyticsData() {
                try {
                    const data = {
                        commandFrequency: Array.from(this.commandFrequency.entries()),
                        searchPatterns: Array.from(this.searchPatterns.entries()),
                        timeBasedPatterns: Array.from(this.timeBasedPatterns.entries()),
                        lastUpdate: Date.now()
                    };
                    localStorage.setItem('intelligentPreloadingData', JSON.stringify(data));
                } catch (error) {
                    console.warn('Failed to save preloading analytics:', error);
                }
            }
            
            setupBehaviorTracking() {
                // Track search queries - find element by ID
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        this.trackSearchQuery(e.target.value);
                    });
                    console.log('✅ Search input tracking enabled');
                } else {
                    console.warn('⚠️ Search input element not found, retrying...');
                    // Retry after a short delay
                    setTimeout(() => {
                        this.setupBehaviorTracking();
                    }, 500);
                    return;
                }
                
                // Track command access via man page displays
                this.originalDisplayManPage = window.displayManPage;
                window.displayManPage = (command, section) => {
                    this.trackCommandAccess(command, section);
                    return this.originalDisplayManPage(command, section);
                };
                
                // Track page visibility for session analytics
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') {
                        this.processSessionAnalytics();
                        this.saveAnalyticsData();
                    }
                });
                
                console.log('🧠 Intelligent preloading behavior tracking initialized');
            }
            
            trackSearchQuery(query) {
                if (query.length >= 2) {
                    this.userBehavior.searchQueries.push({
                        query: query.toLowerCase(),
                        timestamp: Date.now()
                    });
                    
                    // Trigger predictive analysis for active search
                    this.analyzeSearchIntent(query);
                }
            }
            
            trackCommandAccess(command, section) {
                const commandKey = `${command}.${section}`;
                const now = Date.now();
                
                // Update frequency tracking
                const currentCount = this.commandFrequency.get(commandKey) || 0;
                this.commandFrequency.set(commandKey, currentCount + 1);
                
                // Track access time
                this.userBehavior.commandAccesses.set(commandKey, now);
                
                // Track time-based patterns
                const hour = new Date().getHours();
                const hourKey = `hour_${hour}`;
                if (!this.timeBasedPatterns.has(hourKey)) {
                    this.timeBasedPatterns.set(hourKey, new Map());
                }
                const hourPattern = this.timeBasedPatterns.get(hourKey);
                hourPattern.set(commandKey, (hourPattern.get(commandKey) || 0) + 1);
                
                // Record command sequence for pattern analysis
                this.commandSequences.push({
                    command: commandKey,
                    timestamp: now
                });
                
                // Check if this was a preloaded hit
                if (this.preloadedCommands.has(commandKey)) {
                    this.preloadHits++;
                    console.log(`✅ Preload hit: ${commandKey}`);
                } else {
                    this.preloadMisses++;
                }
                
                // Trigger related command preloading
                this.preloadRelatedCommands(command, section);
            }
            
            analyzeSearchIntent(query) {
                // Real-time search intent analysis
                const predictions = this.predictCommandsFromSearch(query);
                
                if (predictions.length > 0) {
                    // Preload top predictions with high confidence
                    predictions.slice(0, 3).forEach(prediction => {
                        if (prediction.confidence > this.preloadThreshold) {
                            this.schedulePreload(prediction.command, prediction.section, {
                                reason: 'search_intent',
                                confidence: prediction.confidence,
                                priority: 'high'
                            });
                        }
                    });
                }
            }
            
            predictCommandsFromSearch(query) {
                const queryLower = query.toLowerCase();
                const predictions = [];
                
                // Direct command matches
                if (window.searchIndexMap && searchIndexMap.has(queryLower)) {
                    const exactMatches = searchIndexMap.get(queryLower);
                    exactMatches.forEach(match => {
                        predictions.push({
                            command: match.command,
                            section: match.section,
                            confidence: 0.9,
                            reason: 'exact_match'
                        });
                    });
                }
                
                // Fuzzy matches based on search patterns
                for (const [pattern, commands] of this.searchPatterns) {
                    if (pattern.includes(queryLower) || queryLower.includes(pattern)) {
                        commands.forEach(cmd => {
                            predictions.push({
                                command: cmd.command,
                                section: cmd.section,
                                confidence: 0.6,
                                reason: 'pattern_match'
                            });
                        });
                    }
                }
                
                // Frequency-based predictions
                for (const [commandKey, frequency] of this.commandFrequency) {
                    const [command] = commandKey.split('.');
                    if (command.toLowerCase().includes(queryLower)) {
                        predictions.push({
                            command: command,
                            section: commandKey.split('.')[1],
                            confidence: Math.min(0.8, frequency / 10),
                            reason: 'frequency_match'
                        });
                    }
                }
                
                // Sort by confidence and remove duplicates
                return predictions
                    .sort((a, b) => b.confidence - a.confidence)
                    .filter((item, index, arr) => 
                        arr.findIndex(x => x.command === item.command && x.section === item.section) === index
                    );
            }
            
            async schedulePreload(command, section, options = {}) {
                const commandKey = `${command}.${section}`;
                
                // Check if already preloaded or in queue
                if (this.preloadedCommands.has(commandKey) || 
                    this.activePreloads.has(commandKey) ||
                    this.currentPreloads >= this.maxPreloadsPerSession) {
                    return;
                }
                
                const preloadItem = {
                    command,
                    section,
                    key: commandKey,
                    priority: options.priority || 'normal',
                    confidence: options.confidence || 0.5,
                    reason: options.reason || 'unknown',
                    scheduledAt: Date.now()
                };
                
                // Add to queue based on priority
                if (options.priority === 'high') {
                    this.preloadQueue.unshift(preloadItem);
                } else {
                    this.preloadQueue.push(preloadItem);
                }
                
                // Process queue
                this.processPreloadQueue();
            }
            
            async processPreloadQueue() {
                // Process one item at a time to avoid overwhelming the system
                if (this.preloadQueue.length === 0 || this.activePreloads.size >= 3) {
                    return;
                }
                
                const item = this.preloadQueue.shift();
                this.activePreloads.add(item.key);
                
                try {
                    const startTime = performance.now();
                    
                    // Preload the man page using low priority
                    await asyncDOMScheduler.scheduleTask(async () => {
                        await this.preloadManPage(item.command, item.section);
                    }, 'low');
                    
                    const preloadTime = performance.now() - startTime;
                    this.totalPreloadTime += preloadTime;
                    this.currentPreloads++;
                    
                    this.preloadedCommands.add(item.key);
                    
                    console.log(`🔮 Preloaded ${item.key} (${item.reason}, confidence: ${item.confidence.toFixed(2)}) in ${preloadTime.toFixed(2)}ms`);
                    
                } catch (error) {
                    console.warn(`Failed to preload ${item.key}:`, error);
                } finally {
                    this.activePreloads.delete(item.key);
                    
                    // Continue processing queue
                    setTimeout(() => {
                        this.processPreloadQueue();
                    }, 100);
                }
            }
            
            async preloadManPage(command, section) {
                const cacheKey = `${command}_${section}`;
                
                // Check if already cached
                if (performanceManager.caches.manPages.get(cacheKey)) {
                    return;
                }
                
                try {
                    const response = await fetch(`man_pages/${command}.${section}.txt`);
                    if (response.ok) {
                        const content = await response.text();
                        
                        // Store in cache with shorter TTL for preloaded content
                        performanceManager.caches.manPages.set(cacheKey, {
                            content: content,
                            timestamp: Date.now(),
                            preloaded: true
                        });
                        
                        this.preloadCache.set(cacheKey, content);
                        
                        // Manage cache size
                        if (this.preloadCache.size > this.maxCacheSize) {
                            const oldestKey = this.preloadCache.keys().next().value;
                            this.preloadCache.delete(oldestKey);
                        }
                    }
                } catch (error) {
                    throw error;
                }
            }
            
            preloadRelatedCommands(command, section) {
                // Find related commands based on patterns
                const relatedCommands = this.findRelatedCommands(command);
                
                relatedCommands.slice(0, 2).forEach(related => {
                    this.schedulePreload(related.command, related.section, {
                        reason: 'related_command',
                        confidence: related.confidence,
                        priority: 'normal'
                    });
                });
            }
            
            findRelatedCommands(command) {
                const related = [];
                
                // Same-category commands (based on command prefixes/suffixes)
                const commandPrefix = command.substring(0, Math.min(3, command.length));
                const commandSuffix = command.substring(Math.max(0, command.length - 3));
                
                for (const [commandKey, frequency] of this.commandFrequency) {
                    const [otherCommand] = commandKey.split('.');
                    
                    if (otherCommand !== command) {
                        let confidence = 0;
                        
                        // Prefix similarity
                        if (otherCommand.startsWith(commandPrefix)) {
                            confidence += 0.3;
                        }
                        
                        // Suffix similarity  
                        if (otherCommand.endsWith(commandSuffix)) {
                            confidence += 0.2;
                        }
                        
                        // Frequency-based confidence
                        confidence += Math.min(0.4, frequency / 20);
                        
                        if (confidence > 0.2) {
                            related.push({
                                command: otherCommand,
                                section: commandKey.split('.')[1],
                                confidence: confidence
                            });
                        }
                    }
                }
                
                return related.sort((a, b) => b.confidence - a.confidence);
            }
            
            performInitialPreloading() {
                // Preload most frequent commands
                const topCommands = Array.from(this.commandFrequency.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);
                
                topCommands.forEach(([commandKey, frequency]) => {
                    const [command, section] = commandKey.split('.');
                    this.schedulePreload(command, section, {
                        reason: 'frequent_command',
                        confidence: Math.min(0.8, frequency / 10),
                        priority: 'normal'
                    });
                });
                
                // Time-based preloading
                const currentHour = new Date().getHours();
                const hourKey = `hour_${currentHour}`;
                if (this.timeBasedPatterns.has(hourKey)) {
                    const hourCommands = Array.from(this.timeBasedPatterns.get(hourKey).entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);
                    
                    hourCommands.forEach(([commandKey, count]) => {
                        const [command, section] = commandKey.split('.');
                        this.schedulePreload(command, section, {
                            reason: 'time_pattern',
                            confidence: Math.min(0.7, count / 5),
                            priority: 'normal'
                        });
                    });
                }
            }
            
            processSessionAnalytics() {
                // Update search patterns
                this.userBehavior.searchQueries.forEach(searchItem => {
                    const query = searchItem.query;
                    
                    // Find commands accessed after this search
                    const relatedCommands = this.commandSequences.filter(cmd => 
                        cmd.timestamp > searchItem.timestamp && 
                        cmd.timestamp < searchItem.timestamp + 60000 // Within 1 minute
                    );
                    
                    if (relatedCommands.length > 0) {
                        if (!this.searchPatterns.has(query)) {
                            this.searchPatterns.set(query, []);
                        }
                        
                        relatedCommands.forEach(cmd => {
                            const [command, section] = cmd.command.split('.');
                            this.searchPatterns.get(query).push({ command, section });
                        });
                    }
                });
                
                // Clear session data
                this.userBehavior.searchQueries = [];
                this.commandSequences = [];
            }
            
            startAnalyticsProcessing() {
                // Periodic analytics processing
                this.analyticsInterval = setInterval(() => {
                    this.processSessionAnalytics();
                    this.saveAnalyticsData();
                }, 300000); // Every 5 minutes
            }
            
            // Get comprehensive statistics
            getIntelligenceStats() {
                const hitRate = this.preloadHits + this.preloadMisses > 0 ? 
                    (this.preloadHits / (this.preloadHits + this.preloadMisses) * 100).toFixed(1) : 0;
                
                return {
                    // Preloading performance
                    preloadHits: this.preloadHits,
                    preloadMisses: this.preloadMisses,
                    hitRate: hitRate + '%',
                    avgPreloadTime: this.currentPreloads > 0 ? 
                        (this.totalPreloadTime / this.currentPreloads).toFixed(2) + 'ms' : '0ms',
                    
                    // Cache status
                    preloadedCommands: this.preloadedCommands.size,
                    activePreloads: this.activePreloads.size,
                    queueLength: this.preloadQueue.length,
                    cacheSize: this.preloadCache.size,
                    
                    // Learning data
                    knownCommands: this.commandFrequency.size,
                    searchPatterns: this.searchPatterns.size,
                    timePatterns: this.timeBasedPatterns.size,
                    
                    // Session data
                    currentPreloads: this.currentPreloads,
                    maxPreloads: this.maxPreloadsPerSession
                };
            }
            
            // Clear analytics and reset learning
            clearAnalytics() {
                this.commandFrequency.clear();
                this.searchPatterns.clear();
                this.timeBasedPatterns.clear();
                this.preloadCache.clear();
                this.preloadedCommands.clear();
                this.preloadQueue = [];
                this.activePreloads.clear();
                
                localStorage.removeItem('intelligentPreloadingData');
                console.log('Intelligent preloading analytics cleared');
            }
            
            // Cleanup
            destroy() {
                // Clear all timers
                if (this.analyticsInterval) {
                    clearInterval(this.analyticsInterval);
                    this.analyticsInterval = null;
                }
                
                if (this.setupTimeout) {
                    clearTimeout(this.setupTimeout);
                    this.setupTimeout = null;
                }
                
                if (this.initialPreloadTimeout) {
                    clearTimeout(this.initialPreloadTimeout);
                    this.initialPreloadTimeout = null;
                }
                
                // Remove all event listeners
                this.eventListeners.forEach(({ element, event, handler }) => {
                    try {
                        element.removeEventListener(event, handler);
                    } catch (error) {
                        console.warn('Failed to remove event listener:', error);
                    }
                });
                this.eventListeners = [];
                
                // Process final analytics before cleanup
                this.processSessionAnalytics();
                this.saveAnalyticsData();
                
                // Restore original functions
                if (this.originalDisplayManPage) {
                    window.displayManPage = this.originalDisplayManPage;
                    this.originalDisplayManPage = null;
                }
                
                // Clear all data structures
                this.clearAnalytics();
                this.preloadQueue = [];
                this.activePreloads.clear();
                this.preloadCache.clear();
                this.preloadedCommands.clear();
                this.commandFrequency.clear();
                this.commandSequences = [];
                this.timeBasedPatterns.clear();
                this.searchPatterns.clear();
                
                console.log('IntelligentPreloadingManager destroyed and cleaned up');
            }
        }

        // Define themes array before initializing managers
        // Function to update CSS variables based on theme
        function updateThemeVariables(themeClass) {
            const root = document.documentElement;
            
            // Define theme-specific variables for shortcuts modal
            const themeVariables = {
                'ayu-mirage': {
                    '--shortcuts-bg': '#232834',
                    '--shortcuts-header-bg': '#1f2430',
                    '--shortcuts-border': '#2d3444',
                    '--shortcuts-title-color': '#ffcc66',
                    '--shortcuts-text': '#cccac2',
                    '--shortcuts-button-bg': 'rgba(45, 52, 68, 0.4)',
                    '--shortcuts-button-border': '#33415e',
                    '--shortcuts-button-hover-bg': 'rgba(255, 204, 102, 0.1)',
                    '--shortcuts-button-hover-color': '#ffcc66',
                    '--shortcuts-button-hover-border': '#ffcc66',
                    '--shortcuts-scrollbar-track': '#191e2a',
                    '--shortcuts-scrollbar-thumb': '#33415e',
                    '--shortcuts-section-bg': 'rgba(31, 36, 48, 0.6)',
                    '--shortcuts-section-border': '#2d3444',
                    '--shortcuts-section-title': '#cccac2',
                    '--shortcuts-accent': '#ffcc66',
                    '--shortcuts-item-border': 'rgba(51, 65, 94, 0.2)',
                    '--shortcuts-kbd-bg': 'rgba(115, 208, 255, 0.15)',
                    '--shortcuts-kbd-border': '#73d0ff',
                    '--shortcuts-kbd-color': '#73d0ff',
                    '--shortcuts-kbd-shadow': 'rgba(115, 208, 255, 0.2)',
                    '--shortcuts-plus-color': '#607080',
                    // Command token variables
                    '--token-command-bg': 'rgba(115, 208, 255, 0.15)',
                    '--token-command-color': '#73d0ff',
                    '--token-command-border': 'rgba(115, 208, 255, 0.3)',
                    '--token-subcommand-bg': 'rgba(255, 204, 102, 0.15)',
                    '--token-subcommand-color': '#ffcc66',
                    '--token-subcommand-border': 'rgba(255, 204, 102, 0.3)',
                    '--token-option-bg': 'rgba(242, 151, 142, 0.15)',
                    '--token-option-color': '#f29782',
                    '--token-option-border': 'rgba(242, 151, 142, 0.3)',
                    '--token-argument-bg': 'rgba(191, 201, 166, 0.15)',
                    '--token-argument-color': '#bfcfa6',
                    '--token-argument-border': 'rgba(191, 201, 166, 0.3)',
                    '--token-variable-bg': 'rgba(95, 175, 239, 0.15)',
                    '--token-variable-color': '#5fafef',
                    '--token-variable-border': 'rgba(95, 175, 239, 0.3)',
                    '--token-expansion-bg': 'rgba(255, 204, 102, 0.15)',
                    '--token-expansion-color': '#ffcc66',
                    '--token-expansion-border': 'rgba(255, 204, 102, 0.3)',
                    '--token-operator-bg': 'rgba(242, 151, 142, 0.15)',
                    '--token-operator-color': '#f29782',
                    '--token-operator-border': 'rgba(242, 151, 142, 0.3)',
                    '--token-redirect-bg': 'rgba(255, 51, 102, 0.15)',
                    '--token-redirect-color': '#ff3366',
                    '--token-redirect-border': 'rgba(255, 51, 102, 0.3)',
                    '--token-special-bg': 'rgba(204, 204, 194, 0.1)',
                    '--token-special-color': '#cccac2',
                    '--token-special-border': 'rgba(204, 204, 194, 0.2)'
                },
                'light': {
                    '--shortcuts-bg': '#ffffff',
                    '--shortcuts-header-bg': '#f8f9fa',
                    '--shortcuts-border': '#e0e0e0',
                    '--shortcuts-title-color': '#1a73e8',
                    '--shortcuts-text': '#333333',
                    '--shortcuts-button-bg': 'rgba(0, 0, 0, 0.05)',
                    '--shortcuts-button-border': '#ddd',
                    '--shortcuts-button-hover-bg': 'rgba(26, 115, 232, 0.1)',
                    '--shortcuts-button-hover-color': '#1a73e8',
                    '--shortcuts-button-hover-border': '#1a73e8',
                    '--shortcuts-scrollbar-track': '#f0f0f0',
                    '--shortcuts-scrollbar-thumb': '#c0c0c0',
                    '--shortcuts-section-bg': '#f8f9fa',
                    '--shortcuts-section-border': '#e0e0e0',
                    '--shortcuts-section-title': '#333333',
                    '--shortcuts-accent': '#1a73e8',
                    '--shortcuts-item-border': 'rgba(0, 0, 0, 0.08)',
                    '--shortcuts-kbd-bg': 'rgba(26, 115, 232, 0.1)',
                    '--shortcuts-kbd-border': '#1a73e8',
                    '--shortcuts-kbd-color': '#1a73e8',
                    '--shortcuts-kbd-shadow': 'rgba(26, 115, 232, 0.15)',
                    '--shortcuts-plus-color': '#666666',
                    // Command token variables
                    '--token-command-bg': '#e3f2fd',
                    '--token-command-color': '#1565c0',
                    '--token-command-border': '#bbdefb',
                    '--token-subcommand-bg': '#f3e5f5',
                    '--token-subcommand-color': '#7b1fa2',
                    '--token-subcommand-border': '#e1bee7',
                    '--token-option-bg': '#f3e5f5',
                    '--token-option-color': '#6a1b9a',
                    '--token-option-border': '#e1bee7',
                    '--token-argument-bg': '#e8f5e9',
                    '--token-argument-color': '#2e7d32',
                    '--token-argument-border': '#c8e6c9',
                    '--token-variable-bg': '#e1f5fe',
                    '--token-variable-color': '#0277bd',
                    '--token-variable-border': '#b3e5fc',
                    '--token-expansion-bg': '#fff3e0',
                    '--token-expansion-color': '#e65100',
                    '--token-expansion-border': '#ffe0b2',
                    '--token-operator-bg': '#fff3e0',
                    '--token-operator-color': '#e65100',
                    '--token-operator-border': '#ffe0b2',
                    '--token-redirect-bg': '#fce4ec',
                    '--token-redirect-color': '#c2185b',
                    '--token-redirect-border': '#f8bbd0',
                    '--token-special-bg': '#fafafa',
                    '--token-special-color': '#424242',
                    '--token-special-border': '#e0e0e0'
                },
                'dark': {
                    '--shortcuts-bg': '#1e1e1e',
                    '--shortcuts-header-bg': '#252526',
                    '--shortcuts-border': '#3e3e42',
                    '--shortcuts-title-color': '#4fc1ff',
                    '--shortcuts-text': '#cccccc',
                    '--shortcuts-button-bg': 'rgba(255, 255, 255, 0.1)',
                    '--shortcuts-button-border': '#3e3e42',
                    '--shortcuts-button-hover-bg': 'rgba(79, 193, 255, 0.2)',
                    '--shortcuts-button-hover-color': '#4fc1ff',
                    '--shortcuts-button-hover-border': '#4fc1ff',
                    '--shortcuts-scrollbar-track': '#1e1e1e',
                    '--shortcuts-scrollbar-thumb': '#3e3e42',
                    '--shortcuts-section-bg': 'rgba(37, 37, 40, 0.6)',
                    '--shortcuts-section-border': '#3e3e42',
                    '--shortcuts-section-title': '#cccccc',
                    '--shortcuts-accent': '#4fc1ff',
                    '--shortcuts-item-border': 'rgba(255, 255, 255, 0.08)',
                    '--shortcuts-kbd-bg': 'rgba(79, 193, 255, 0.15)',
                    '--shortcuts-kbd-border': '#4fc1ff',
                    '--shortcuts-kbd-color': '#4fc1ff',
                    '--shortcuts-kbd-shadow': 'rgba(79, 193, 255, 0.2)',
                    '--shortcuts-plus-color': '#808080',
                    // Command token variables
                    '--token-command-bg': 'rgba(79, 193, 255, 0.15)',
                    '--token-command-color': '#4fc1ff',
                    '--token-command-border': 'rgba(79, 193, 255, 0.3)',
                    '--token-subcommand-bg': 'rgba(156, 120, 255, 0.15)',
                    '--token-subcommand-color': '#9c78ff',
                    '--token-subcommand-border': 'rgba(156, 120, 255, 0.3)',
                    '--token-option-bg': 'rgba(255, 120, 198, 0.15)',
                    '--token-option-color': '#ff78c6',
                    '--token-option-border': 'rgba(255, 120, 198, 0.3)',
                    '--token-argument-bg': 'rgba(120, 255, 120, 0.15)',
                    '--token-argument-color': '#78ff78',
                    '--token-argument-border': 'rgba(120, 255, 120, 0.3)',
                    '--token-variable-bg': 'rgba(102, 187, 255, 0.15)',
                    '--token-variable-color': '#66bbff',
                    '--token-variable-border': 'rgba(102, 187, 255, 0.3)',
                    '--token-expansion-bg': 'rgba(255, 183, 77, 0.15)',
                    '--token-expansion-color': '#ffb74d',
                    '--token-expansion-border': 'rgba(255, 183, 77, 0.3)',
                    '--token-operator-bg': 'rgba(255, 167, 38, 0.15)',
                    '--token-operator-color': '#ffa726',
                    '--token-operator-border': 'rgba(255, 167, 38, 0.3)',
                    '--token-redirect-bg': 'rgba(240, 98, 146, 0.15)',
                    '--token-redirect-color': '#f06292',
                    '--token-redirect-border': 'rgba(240, 98, 146, 0.3)',
                    '--token-special-bg': 'rgba(189, 189, 189, 0.1)',
                    '--token-special-color': '#bdbdbd',
                    '--token-special-border': 'rgba(189, 189, 189, 0.2)'
                },
                'dracula': {
                    '--shortcuts-bg': '#282a36',
                    '--shortcuts-header-bg': '#21222c',
                    '--shortcuts-border': '#44475a',
                    '--shortcuts-title-color': '#bd93f9',
                    '--shortcuts-text': '#f8f8f2',
                    '--shortcuts-button-bg': 'rgba(68, 71, 90, 0.4)',
                    '--shortcuts-button-border': '#6272a4',
                    '--shortcuts-button-hover-bg': 'rgba(189, 147, 249, 0.1)',
                    '--shortcuts-button-hover-color': '#bd93f9',
                    '--shortcuts-button-hover-border': '#bd93f9',
                    '--shortcuts-scrollbar-track': '#21222c',
                    '--shortcuts-scrollbar-thumb': '#44475a',
                    '--shortcuts-section-bg': 'rgba(40, 42, 54, 0.6)',
                    '--shortcuts-section-border': '#44475a',
                    '--shortcuts-section-title': '#f8f8f2',
                    '--shortcuts-accent': '#bd93f9',
                    '--shortcuts-item-border': 'rgba(68, 71, 90, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(139, 233, 253, 0.15)',
                    '--shortcuts-kbd-border': '#8be9fd',
                    '--shortcuts-kbd-color': '#8be9fd',
                    '--shortcuts-kbd-shadow': 'rgba(139, 233, 253, 0.2)',
                    '--shortcuts-plus-color': '#6272a4',
                    // Command token variables
                    '--token-command-bg': 'rgba(139, 233, 253, 0.15)',
                    '--token-command-color': '#8be9fd',
                    '--token-command-border': 'rgba(139, 233, 253, 0.3)',
                    '--token-subcommand-bg': 'rgba(189, 147, 249, 0.15)',
                    '--token-subcommand-color': '#bd93f9',
                    '--token-subcommand-border': 'rgba(189, 147, 249, 0.3)',
                    '--token-option-bg': 'rgba(255, 121, 198, 0.15)',
                    '--token-option-color': '#ff79c6',
                    '--token-option-border': 'rgba(255, 121, 198, 0.3)',
                    '--token-argument-bg': 'rgba(80, 250, 123, 0.15)',
                    '--token-argument-color': '#50fa7b',
                    '--token-argument-border': 'rgba(80, 250, 123, 0.3)',
                    '--token-variable-bg': 'rgba(98, 114, 164, 0.2)',
                    '--token-variable-color': '#6272a4',
                    '--token-variable-border': 'rgba(98, 114, 164, 0.4)',
                    '--token-expansion-bg': 'rgba(241, 250, 140, 0.15)',
                    '--token-expansion-color': '#f1fa8c',
                    '--token-expansion-border': 'rgba(241, 250, 140, 0.3)',
                    '--token-operator-bg': 'rgba(255, 184, 108, 0.15)',
                    '--token-operator-color': '#ffb86c',
                    '--token-operator-border': 'rgba(255, 184, 108, 0.3)',
                    '--token-redirect-bg': 'rgba(255, 85, 85, 0.15)',
                    '--token-redirect-color': '#ff5555',
                    '--token-redirect-border': 'rgba(255, 85, 85, 0.3)',
                    '--token-special-bg': 'rgba(68, 71, 90, 0.2)',
                    '--token-special-color': '#f8f8f2',
                    '--token-special-border': 'rgba(68, 71, 90, 0.4)'
                },
                'monokai': {
                    '--shortcuts-bg': '#272822',
                    '--shortcuts-header-bg': '#1e1f1c',
                    '--shortcuts-border': '#414339',
                    '--shortcuts-title-color': '#f92672',
                    '--shortcuts-text': '#f8f8f2',
                    '--shortcuts-button-bg': 'rgba(65, 67, 57, 0.4)',
                    '--shortcuts-button-border': '#75715e',
                    '--shortcuts-button-hover-bg': 'rgba(249, 38, 114, 0.1)',
                    '--shortcuts-button-hover-color': '#f92672',
                    '--shortcuts-button-hover-border': '#f92672',
                    '--shortcuts-scrollbar-track': '#1e1f1c',
                    '--shortcuts-scrollbar-thumb': '#414339',
                    '--shortcuts-section-bg': 'rgba(39, 40, 34, 0.6)',
                    '--shortcuts-section-border': '#414339',
                    '--shortcuts-section-title': '#f8f8f2',
                    '--shortcuts-accent': '#f92672',
                    '--shortcuts-item-border': 'rgba(117, 113, 94, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(166, 226, 46, 0.15)',
                    '--shortcuts-kbd-border': '#a6e22e',
                    '--shortcuts-kbd-color': '#a6e22e',
                    '--shortcuts-kbd-shadow': 'rgba(166, 226, 46, 0.2)',
                    '--shortcuts-plus-color': '#75715e',
                    // Command token variables
                    '--token-command-bg': 'rgba(102, 217, 239, 0.15)',
                    '--token-command-color': '#66d9ef',
                    '--token-command-border': 'rgba(102, 217, 239, 0.3)',
                    '--token-subcommand-bg': 'rgba(174, 129, 255, 0.15)',
                    '--token-subcommand-color': '#ae81ff',
                    '--token-subcommand-border': 'rgba(174, 129, 255, 0.3)',
                    '--token-option-bg': 'rgba(249, 38, 114, 0.15)',
                    '--token-option-color': '#f92672',
                    '--token-option-border': 'rgba(249, 38, 114, 0.3)',
                    '--token-argument-bg': 'rgba(166, 226, 46, 0.15)',
                    '--token-argument-color': '#a6e22e',
                    '--token-argument-border': 'rgba(166, 226, 46, 0.3)',
                    '--token-variable-bg': 'rgba(253, 151, 31, 0.15)',
                    '--token-variable-color': '#fd971f',
                    '--token-variable-border': 'rgba(253, 151, 31, 0.3)',
                    '--token-expansion-bg': 'rgba(230, 219, 116, 0.15)',
                    '--token-expansion-color': '#e6db74',
                    '--token-expansion-border': 'rgba(230, 219, 116, 0.3)',
                    '--token-operator-bg': 'rgba(249, 38, 114, 0.15)',
                    '--token-operator-color': '#f92672',
                    '--token-operator-border': 'rgba(249, 38, 114, 0.3)',
                    '--token-redirect-bg': 'rgba(249, 38, 114, 0.15)',
                    '--token-redirect-color': '#f92672',
                    '--token-redirect-border': 'rgba(249, 38, 114, 0.3)',
                    '--token-special-bg': 'rgba(117, 113, 94, 0.1)',
                    '--token-special-color': '#75715e',
                    '--token-special-border': 'rgba(117, 113, 94, 0.2)'
                },
                'github-dark': {
                    '--shortcuts-bg': '#0d1117',
                    '--shortcuts-header-bg': '#010409',
                    '--shortcuts-border': '#30363d',
                    '--shortcuts-title-color': '#58a6ff',
                    '--shortcuts-text': '#c9d1d9',
                    '--shortcuts-button-bg': 'rgba(48, 54, 61, 0.4)',
                    '--shortcuts-button-border': '#30363d',
                    '--shortcuts-button-hover-bg': 'rgba(88, 166, 255, 0.1)',
                    '--shortcuts-button-hover-color': '#58a6ff',
                    '--shortcuts-button-hover-border': '#58a6ff',
                    '--shortcuts-scrollbar-track': '#010409',
                    '--shortcuts-scrollbar-thumb': '#30363d',
                    '--shortcuts-section-bg': 'rgba(13, 17, 23, 0.6)',
                    '--shortcuts-section-border': '#30363d',
                    '--shortcuts-section-title': '#c9d1d9',
                    '--shortcuts-accent': '#58a6ff',
                    '--shortcuts-item-border': 'rgba(48, 54, 61, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(88, 166, 255, 0.15)',
                    '--shortcuts-kbd-border': '#58a6ff',
                    '--shortcuts-kbd-color': '#58a6ff',
                    '--shortcuts-kbd-shadow': 'rgba(88, 166, 255, 0.2)',
                    '--shortcuts-plus-color': '#8b949e',
                    // Command token variables
                    '--token-command-bg': 'rgba(88, 166, 255, 0.15)',
                    '--token-command-color': '#58a6ff',
                    '--token-command-border': 'rgba(88, 166, 255, 0.3)',
                    '--token-subcommand-bg': 'rgba(121, 92, 255, 0.15)',
                    '--token-subcommand-color': '#795cff',
                    '--token-subcommand-border': 'rgba(121, 92, 255, 0.3)',
                    '--token-option-bg': 'rgba(242, 105, 201, 0.15)',
                    '--token-option-color': '#f269c9',
                    '--token-option-border': 'rgba(242, 105, 201, 0.3)',
                    '--token-argument-bg': 'rgba(63, 185, 80, 0.15)',
                    '--token-argument-color': '#3fb950',
                    '--token-argument-border': 'rgba(63, 185, 80, 0.3)',
                    '--token-variable-bg': 'rgba(139, 148, 158, 0.15)',
                    '--token-variable-color': '#8b949e',
                    '--token-variable-border': 'rgba(139, 148, 158, 0.3)',
                    '--token-expansion-bg': 'rgba(219, 154, 73, 0.15)',
                    '--token-expansion-color': '#db9a49',
                    '--token-expansion-border': 'rgba(219, 154, 73, 0.3)',
                    '--token-operator-bg': 'rgba(255, 125, 89, 0.15)',
                    '--token-operator-color': '#ff7d59',
                    '--token-operator-border': 'rgba(255, 125, 89, 0.3)',
                    '--token-redirect-bg': 'rgba(248, 81, 73, 0.15)',
                    '--token-redirect-color': '#f85149',
                    '--token-redirect-border': 'rgba(248, 81, 73, 0.3)',
                    '--token-special-bg': 'rgba(48, 54, 61, 0.2)',
                    '--token-special-color': '#c9d1d9',
                    '--token-special-border': 'rgba(48, 54, 61, 0.4)'
                },
                'solarized': {
                    '--shortcuts-bg': '#002b36',
                    '--shortcuts-header-bg': '#001f26',
                    '--shortcuts-border': '#073642',
                    '--shortcuts-title-color': '#b58900',
                    '--shortcuts-text': '#839496',
                    '--shortcuts-button-bg': 'rgba(7, 54, 66, 0.4)',
                    '--shortcuts-button-border': '#073642',
                    '--shortcuts-button-hover-bg': 'rgba(181, 137, 0, 0.1)',
                    '--shortcuts-button-hover-color': '#b58900',
                    '--shortcuts-button-hover-border': '#b58900',
                    '--shortcuts-scrollbar-track': '#001f26',
                    '--shortcuts-scrollbar-thumb': '#073642',
                    '--shortcuts-section-bg': 'rgba(0, 43, 54, 0.6)',
                    '--shortcuts-section-border': '#073642',
                    '--shortcuts-section-title': '#839496',
                    '--shortcuts-accent': '#b58900',
                    '--shortcuts-item-border': 'rgba(7, 54, 66, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(42, 161, 152, 0.15)',
                    '--shortcuts-kbd-border': '#2aa198',
                    '--shortcuts-kbd-color': '#2aa198',
                    '--shortcuts-kbd-shadow': 'rgba(42, 161, 152, 0.2)',
                    '--shortcuts-plus-color': '#586e75'
                },
                'nord': {
                    '--shortcuts-bg': '#2e3440',
                    '--shortcuts-header-bg': '#242933',
                    '--shortcuts-border': '#3b4252',
                    '--shortcuts-title-color': '#88c0d0',
                    '--shortcuts-text': '#eceff4',
                    '--shortcuts-button-bg': 'rgba(59, 66, 82, 0.4)',
                    '--shortcuts-button-border': '#4c566a',
                    '--shortcuts-button-hover-bg': 'rgba(136, 192, 208, 0.1)',
                    '--shortcuts-button-hover-color': '#88c0d0',
                    '--shortcuts-button-hover-border': '#88c0d0',
                    '--shortcuts-scrollbar-track': '#242933',
                    '--shortcuts-scrollbar-thumb': '#4c566a',
                    '--shortcuts-section-bg': 'rgba(46, 52, 64, 0.6)',
                    '--shortcuts-section-border': '#3b4252',
                    '--shortcuts-section-title': '#eceff4',
                    '--shortcuts-accent': '#88c0d0',
                    '--shortcuts-item-border': 'rgba(76, 86, 106, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(129, 161, 193, 0.15)',
                    '--shortcuts-kbd-border': '#81a1c1',
                    '--shortcuts-kbd-color': '#81a1c1',
                    '--shortcuts-kbd-shadow': 'rgba(129, 161, 193, 0.2)',
                    '--shortcuts-plus-color': '#4c566a'
                },
                'gruvbox': {
                    '--shortcuts-bg': '#282828',
                    '--shortcuts-header-bg': '#1d2021',
                    '--shortcuts-border': '#3c3836',
                    '--shortcuts-title-color': '#fe8019',
                    '--shortcuts-text': '#ebdbb2',
                    '--shortcuts-button-bg': 'rgba(60, 56, 54, 0.4)',
                    '--shortcuts-button-border': '#504945',
                    '--shortcuts-button-hover-bg': 'rgba(254, 128, 25, 0.1)',
                    '--shortcuts-button-hover-color': '#fe8019',
                    '--shortcuts-button-hover-border': '#fe8019',
                    '--shortcuts-scrollbar-track': '#1d2021',
                    '--shortcuts-scrollbar-thumb': '#504945',
                    '--shortcuts-section-bg': 'rgba(40, 40, 40, 0.6)',
                    '--shortcuts-section-border': '#3c3836',
                    '--shortcuts-section-title': '#ebdbb2',
                    '--shortcuts-accent': '#fe8019',
                    '--shortcuts-item-border': 'rgba(80, 73, 69, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(184, 187, 38, 0.15)',
                    '--shortcuts-kbd-border': '#b8bb26',
                    '--shortcuts-kbd-color': '#b8bb26',
                    '--shortcuts-kbd-shadow': 'rgba(184, 187, 38, 0.2)',
                    '--shortcuts-plus-color': '#928374'
                },
                'tokyo-night': {
                    '--shortcuts-bg': '#1a1b26',
                    '--shortcuts-header-bg': '#16161e',
                    '--shortcuts-border': '#444b6a',
                    '--shortcuts-title-color': '#7aa2f7',
                    '--shortcuts-text': '#a9b1d6',
                    '--shortcuts-button-bg': 'rgba(68, 75, 106, 0.4)',
                    '--shortcuts-button-border': '#444b6a',
                    '--shortcuts-button-hover-bg': 'rgba(122, 162, 247, 0.1)',
                    '--shortcuts-button-hover-color': '#7aa2f7',
                    '--shortcuts-button-hover-border': '#7aa2f7',
                    '--shortcuts-scrollbar-track': '#16161e',
                    '--shortcuts-scrollbar-thumb': '#444b6a',
                    '--shortcuts-section-bg': 'rgba(26, 27, 38, 0.6)',
                    '--shortcuts-section-border': '#444b6a',
                    '--shortcuts-section-title': '#a9b1d6',
                    '--shortcuts-accent': '#7aa2f7',
                    '--shortcuts-item-border': 'rgba(68, 75, 106, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(157, 124, 216, 0.15)',
                    '--shortcuts-kbd-border': '#9d7cd8',
                    '--shortcuts-kbd-color': '#9d7cd8',
                    '--shortcuts-kbd-shadow': 'rgba(157, 124, 216, 0.2)',
                    '--shortcuts-plus-color': '#565f89'
                },
                'one-dark': {
                    '--shortcuts-bg': '#282c34',
                    '--shortcuts-header-bg': '#21252b',
                    '--shortcuts-border': '#3e4451',
                    '--shortcuts-title-color': '#61afef',
                    '--shortcuts-text': '#abb2bf',
                    '--shortcuts-button-bg': 'rgba(62, 68, 81, 0.4)',
                    '--shortcuts-button-border': '#4b5263',
                    '--shortcuts-button-hover-bg': 'rgba(97, 175, 239, 0.1)',
                    '--shortcuts-button-hover-color': '#61afef',
                    '--shortcuts-button-hover-border': '#61afef',
                    '--shortcuts-scrollbar-track': '#21252b',
                    '--shortcuts-scrollbar-thumb': '#4b5263',
                    '--shortcuts-section-bg': 'rgba(40, 44, 52, 0.6)',
                    '--shortcuts-section-border': '#3e4451',
                    '--shortcuts-section-title': '#abb2bf',
                    '--shortcuts-accent': '#61afef',
                    '--shortcuts-item-border': 'rgba(75, 82, 99, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(224, 108, 117, 0.15)',
                    '--shortcuts-kbd-border': '#e06c75',
                    '--shortcuts-kbd-color': '#e06c75',
                    '--shortcuts-kbd-shadow': 'rgba(224, 108, 117, 0.2)',
                    '--shortcuts-plus-color': '#5c6370'
                },
                'material-design': {
                    '--shortcuts-bg': '#121212',
                    '--shortcuts-header-bg': '#000000',
                    '--shortcuts-border': '#1f1f1f',
                    '--shortcuts-title-color': '#bb86fc',
                    '--shortcuts-text': '#e1e1e1',
                    '--shortcuts-button-bg': 'rgba(31, 31, 31, 0.4)',
                    '--shortcuts-button-border': '#2c2c2c',
                    '--shortcuts-button-hover-bg': 'rgba(187, 134, 252, 0.1)',
                    '--shortcuts-button-hover-color': '#bb86fc',
                    '--shortcuts-button-hover-border': '#bb86fc',
                    '--shortcuts-scrollbar-track': '#000000',
                    '--shortcuts-scrollbar-thumb': '#2c2c2c',
                    '--shortcuts-section-bg': 'rgba(18, 18, 18, 0.6)',
                    '--shortcuts-section-border': '#1f1f1f',
                    '--shortcuts-section-title': '#e1e1e1',
                    '--shortcuts-accent': '#bb86fc',
                    '--shortcuts-item-border': 'rgba(44, 44, 44, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(3, 218, 198, 0.15)',
                    '--shortcuts-kbd-border': '#03dac6',
                    '--shortcuts-kbd-color': '#03dac6',
                    '--shortcuts-kbd-shadow': 'rgba(3, 218, 198, 0.2)',
                    '--shortcuts-plus-color': '#9e9e9e'
                },
                'catppuccin-mocha': {
                    '--shortcuts-bg': '#1e1e2e',
                    '--shortcuts-header-bg': '#181825',
                    '--shortcuts-border': '#313244',
                    '--shortcuts-title-color': '#cba6f7',
                    '--shortcuts-text': '#cdd6f4',
                    '--shortcuts-button-bg': 'rgba(49, 50, 68, 0.4)',
                    '--shortcuts-button-border': '#45475a',
                    '--shortcuts-button-hover-bg': 'rgba(203, 166, 247, 0.1)',
                    '--shortcuts-button-hover-color': '#cba6f7',
                    '--shortcuts-button-hover-border': '#cba6f7',
                    '--shortcuts-scrollbar-track': '#181825',
                    '--shortcuts-scrollbar-thumb': '#45475a',
                    '--shortcuts-section-bg': 'rgba(30, 30, 46, 0.6)',
                    '--shortcuts-section-border': '#313244',
                    '--shortcuts-section-title': '#cdd6f4',
                    '--shortcuts-accent': '#cba6f7',
                    '--shortcuts-item-border': 'rgba(69, 71, 90, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(137, 180, 250, 0.15)',
                    '--shortcuts-kbd-border': '#89b4fa',
                    '--shortcuts-kbd-color': '#89b4fa',
                    '--shortcuts-kbd-shadow': 'rgba(137, 180, 250, 0.2)',
                    '--shortcuts-plus-color': '#6c7086'
                },
                'synthwave-84': {
                    '--shortcuts-bg': '#261447',
                    '--shortcuts-header-bg': '#1a0e2e',
                    '--shortcuts-border': '#3d2663',
                    '--shortcuts-title-color': '#ff00ff',
                    '--shortcuts-text': '#f97e72',
                    '--shortcuts-button-bg': 'rgba(61, 38, 99, 0.4)',
                    '--shortcuts-button-border': '#4a3066',
                    '--shortcuts-button-hover-bg': 'rgba(255, 0, 255, 0.1)',
                    '--shortcuts-button-hover-color': '#ff00ff',
                    '--shortcuts-button-hover-border': '#ff00ff',
                    '--shortcuts-scrollbar-track': '#1a0e2e',
                    '--shortcuts-scrollbar-thumb': '#4a3066',
                    '--shortcuts-section-bg': 'rgba(38, 20, 71, 0.6)',
                    '--shortcuts-section-border': '#3d2663',
                    '--shortcuts-section-title': '#f97e72',
                    '--shortcuts-accent': '#ff00ff',
                    '--shortcuts-item-border': 'rgba(74, 48, 102, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(0, 255, 255, 0.15)',
                    '--shortcuts-kbd-border': '#00ffff',
                    '--shortcuts-kbd-color': '#00ffff',
                    '--shortcuts-kbd-shadow': 'rgba(0, 255, 255, 0.2)',
                    '--shortcuts-plus-color': '#bd48ff'
                },
                'palenight': {
                    '--shortcuts-bg': '#292d3e',
                    '--shortcuts-header-bg': '#1e2131',
                    '--shortcuts-border': '#3c435e',
                    '--shortcuts-title-color': '#82aaff',
                    '--shortcuts-text': '#a6accd',
                    '--shortcuts-button-bg': 'rgba(60, 67, 94, 0.4)',
                    '--shortcuts-button-border': '#4e5579',
                    '--shortcuts-button-hover-bg': 'rgba(130, 170, 255, 0.1)',
                    '--shortcuts-button-hover-color': '#82aaff',
                    '--shortcuts-button-hover-border': '#82aaff',
                    '--shortcuts-scrollbar-track': '#1e2131',
                    '--shortcuts-scrollbar-thumb': '#4e5579',
                    '--shortcuts-section-bg': 'rgba(41, 45, 62, 0.6)',
                    '--shortcuts-section-border': '#3c435e',
                    '--shortcuts-section-title': '#a6accd',
                    '--shortcuts-accent': '#82aaff',
                    '--shortcuts-item-border': 'rgba(78, 85, 121, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(199, 146, 234, 0.15)',
                    '--shortcuts-kbd-border': '#c792ea',
                    '--shortcuts-kbd-color': '#c792ea',
                    '--shortcuts-kbd-shadow': 'rgba(199, 146, 234, 0.2)',
                    '--shortcuts-plus-color': '#676e95'
                },
                'everforest': {
                    '--shortcuts-bg': '#2b3339',
                    '--shortcuts-header-bg': '#222b31',
                    '--shortcuts-border': '#404c56',
                    '--shortcuts-title-color': '#a7c080',
                    '--shortcuts-text': '#d3c6aa',
                    '--shortcuts-button-bg': 'rgba(64, 76, 86, 0.4)',
                    '--shortcuts-button-border': '#4e5a65',
                    '--shortcuts-button-hover-bg': 'rgba(167, 192, 128, 0.1)',
                    '--shortcuts-button-hover-color': '#a7c080',
                    '--shortcuts-button-hover-border': '#a7c080',
                    '--shortcuts-scrollbar-track': '#222b31',
                    '--shortcuts-scrollbar-thumb': '#4e5a65',
                    '--shortcuts-section-bg': 'rgba(43, 51, 57, 0.6)',
                    '--shortcuts-section-border': '#404c56',
                    '--shortcuts-section-title': '#d3c6aa',
                    '--shortcuts-accent': '#a7c080',
                    '--shortcuts-item-border': 'rgba(78, 90, 101, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(131, 191, 181, 0.15)',
                    '--shortcuts-kbd-border': '#83bfb5',
                    '--shortcuts-kbd-color': '#83bfb5',
                    '--shortcuts-kbd-shadow': 'rgba(131, 191, 181, 0.2)',
                    '--shortcuts-plus-color': '#748390'
                },
                'kanagawa': {
                    '--shortcuts-bg': '#1f1f28',
                    '--shortcuts-header-bg': '#16161d',
                    '--shortcuts-border': '#2a2a37',
                    '--shortcuts-title-color': '#957fb8',
                    '--shortcuts-text': '#dcd7ba',
                    '--shortcuts-button-bg': 'rgba(42, 42, 55, 0.4)',
                    '--shortcuts-button-border': '#363646',
                    '--shortcuts-button-hover-bg': 'rgba(149, 127, 184, 0.1)',
                    '--shortcuts-button-hover-color': '#957fb8',
                    '--shortcuts-button-hover-border': '#957fb8',
                    '--shortcuts-scrollbar-track': '#16161d',
                    '--shortcuts-scrollbar-thumb': '#363646',
                    '--shortcuts-section-bg': 'rgba(31, 31, 40, 0.6)',
                    '--shortcuts-section-border': '#2a2a37',
                    '--shortcuts-section-title': '#dcd7ba',
                    '--shortcuts-accent': '#957fb8',
                    '--shortcuts-item-border': 'rgba(54, 54, 70, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(114, 154, 155, 0.15)',
                    '--shortcuts-kbd-border': '#729a9b',
                    '--shortcuts-kbd-color': '#729a9b',
                    '--shortcuts-kbd-shadow': 'rgba(114, 154, 155, 0.2)',
                    '--shortcuts-plus-color': '#54546d'
                },
                'rose-pine': {
                    '--shortcuts-bg': '#191724',
                    '--shortcuts-header-bg': '#1f1d2e',
                    '--shortcuts-border': '#26233a',
                    '--shortcuts-title-color': '#ebbcba',
                    '--shortcuts-text': '#e0def4',
                    '--shortcuts-button-bg': 'rgba(38, 35, 58, 0.4)',
                    '--shortcuts-button-border': '#403d52',
                    '--shortcuts-button-hover-bg': 'rgba(235, 188, 186, 0.1)',
                    '--shortcuts-button-hover-color': '#ebbcba',
                    '--shortcuts-button-hover-border': '#ebbcba',
                    '--shortcuts-scrollbar-track': '#1f1d2e',
                    '--shortcuts-scrollbar-thumb': '#403d52',
                    '--shortcuts-section-bg': 'rgba(25, 23, 36, 0.6)',
                    '--shortcuts-section-border': '#26233a',
                    '--shortcuts-section-title': '#e0def4',
                    '--shortcuts-accent': '#ebbcba',
                    '--shortcuts-item-border': 'rgba(64, 61, 82, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(156, 207, 216, 0.15)',
                    '--shortcuts-kbd-border': '#9ccfd8',
                    '--shortcuts-kbd-color': '#9ccfd8',
                    '--shortcuts-kbd-shadow': 'rgba(156, 207, 216, 0.2)',
                    '--shortcuts-plus-color': '#6e6a86'
                },
                'ocean-depth': {
                    '--shortcuts-bg': '#0f172a',
                    '--shortcuts-header-bg': '#0a0f1f',
                    '--shortcuts-border': '#1e293b',
                    '--shortcuts-title-color': '#0ea5e9',
                    '--shortcuts-text': '#94a3b8',
                    '--shortcuts-button-bg': 'rgba(30, 41, 59, 0.4)',
                    '--shortcuts-button-border': '#334155',
                    '--shortcuts-button-hover-bg': 'rgba(14, 165, 233, 0.1)',
                    '--shortcuts-button-hover-color': '#0ea5e9',
                    '--shortcuts-button-hover-border': '#0ea5e9',
                    '--shortcuts-scrollbar-track': '#0a0f1f',
                    '--shortcuts-scrollbar-thumb': '#334155',
                    '--shortcuts-section-bg': 'rgba(15, 23, 42, 0.6)',
                    '--shortcuts-section-border': '#1e293b',
                    '--shortcuts-section-title': '#94a3b8',
                    '--shortcuts-accent': '#0ea5e9',
                    '--shortcuts-item-border': 'rgba(51, 65, 85, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(34, 211, 238, 0.15)',
                    '--shortcuts-kbd-border': '#22d3ee',
                    '--shortcuts-kbd-color': '#22d3ee',
                    '--shortcuts-kbd-shadow': 'rgba(34, 211, 238, 0.2)',
                    '--shortcuts-plus-color': '#475569'
                },
                'high-contrast': {
                    '--shortcuts-bg': '#000000',
                    '--shortcuts-header-bg': '#000000',
                    '--shortcuts-border': '#ffffff',
                    '--shortcuts-title-color': '#00ff00',
                    '--shortcuts-text': '#ffffff',
                    '--shortcuts-button-bg': 'rgba(255, 255, 255, 0.1)',
                    '--shortcuts-button-border': '#ffffff',
                    '--shortcuts-button-hover-bg': 'rgba(0, 255, 0, 0.2)',
                    '--shortcuts-button-hover-color': '#00ff00',
                    '--shortcuts-button-hover-border': '#00ff00',
                    '--shortcuts-scrollbar-track': '#000000',
                    '--shortcuts-scrollbar-thumb': '#ffffff',
                    '--shortcuts-section-bg': 'rgba(255, 255, 255, 0.1)',
                    '--shortcuts-section-border': '#ffffff',
                    '--shortcuts-section-title': '#ffffff',
                    '--shortcuts-accent': '#00ff00',
                    '--shortcuts-item-border': 'rgba(255, 255, 255, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(0, 255, 255, 0.2)',
                    '--shortcuts-kbd-border': '#00ffff',
                    '--shortcuts-kbd-color': '#00ffff',
                    '--shortcuts-kbd-shadow': 'rgba(0, 255, 255, 0.3)',
                    '--shortcuts-plus-color': '#cccccc'
                },
                'hotdog-stand': {
                    '--shortcuts-bg': '#ffffff',
                    '--shortcuts-header-bg': '#ff0000',
                    '--shortcuts-border': '#ff0000',
                    '--shortcuts-title-color': '#000000',
                    '--shortcuts-text': '#000000',
                    '--shortcuts-button-bg': '#ffff00',
                    '--shortcuts-button-border': '#ff0000',
                    '--shortcuts-button-hover-bg': '#ff0000',
                    '--shortcuts-button-hover-color': '#ffff00',
                    '--shortcuts-button-hover-border': '#ffff00',
                    '--shortcuts-scrollbar-track': '#ff0000',
                    '--shortcuts-scrollbar-thumb': '#ffff00',
                    '--shortcuts-section-bg': '#ffff00',
                    '--shortcuts-section-border': '#ff0000',
                    '--shortcuts-section-title': '#000000',
                    '--shortcuts-accent': '#ff0000',
                    '--shortcuts-item-border': '#ff0000',
                    '--shortcuts-kbd-bg': '#ff0000',
                    '--shortcuts-kbd-border': '#000000',
                    '--shortcuts-kbd-color': '#ffff00',
                    '--shortcuts-kbd-shadow': 'rgba(255, 0, 0, 0.5)',
                    '--shortcuts-plus-color': '#000000'
                },
                'neon-noir': {
                    '--shortcuts-bg': '#0a0a0a',
                    '--shortcuts-header-bg': '#000000',
                    '--shortcuts-border': '#ff00ff',
                    '--shortcuts-title-color': '#00ffff',
                    '--shortcuts-text': '#ff00ff',
                    '--shortcuts-button-bg': 'rgba(255, 0, 255, 0.1)',
                    '--shortcuts-button-border': '#ff00ff',
                    '--shortcuts-button-hover-bg': 'rgba(0, 255, 255, 0.2)',
                    '--shortcuts-button-hover-color': '#00ffff',
                    '--shortcuts-button-hover-border': '#00ffff',
                    '--shortcuts-scrollbar-track': '#000000',
                    '--shortcuts-scrollbar-thumb': '#ff00ff',
                    '--shortcuts-section-bg': 'rgba(255, 0, 255, 0.05)',
                    '--shortcuts-section-border': '#ff00ff',
                    '--shortcuts-section-title': '#ff00ff',
                    '--shortcuts-accent': '#00ffff',
                    '--shortcuts-item-border': 'rgba(255, 0, 255, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(0, 255, 255, 0.2)',
                    '--shortcuts-kbd-border': '#00ffff',
                    '--shortcuts-kbd-color': '#00ffff',
                    '--shortcuts-kbd-shadow': 'rgba(0, 255, 255, 0.5)',
                    '--shortcuts-plus-color': '#ff00ff'
                },
                'cyber-frost': {
                    '--shortcuts-bg': '#000b1e',
                    '--shortcuts-header-bg': '#000517',
                    '--shortcuts-border': '#0084ff',
                    '--shortcuts-title-color': '#00ffff',
                    '--shortcuts-text': '#00d4ff',
                    '--shortcuts-button-bg': 'rgba(0, 132, 255, 0.1)',
                    '--shortcuts-button-border': '#0084ff',
                    '--shortcuts-button-hover-bg': 'rgba(0, 255, 255, 0.2)',
                    '--shortcuts-button-hover-color': '#00ffff',
                    '--shortcuts-button-hover-border': '#00ffff',
                    '--shortcuts-scrollbar-track': '#000517',
                    '--shortcuts-scrollbar-thumb': '#0084ff',
                    '--shortcuts-section-bg': 'rgba(0, 132, 255, 0.05)',
                    '--shortcuts-section-border': '#0084ff',
                    '--shortcuts-section-title': '#00d4ff',
                    '--shortcuts-accent': '#00ffff',
                    '--shortcuts-item-border': 'rgba(0, 132, 255, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(0, 255, 255, 0.2)',
                    '--shortcuts-kbd-border': '#00ffff',
                    '--shortcuts-kbd-color': '#00ffff',
                    '--shortcuts-kbd-shadow': 'rgba(0, 255, 255, 0.5)',
                    '--shortcuts-plus-color': '#0099ff'
                },
                'miami-sunrise': {
                    '--shortcuts-bg': '#1a0033',
                    '--shortcuts-header-bg': '#0f001a',
                    '--shortcuts-border': '#ff006e',
                    '--shortcuts-title-color': '#ffb700',
                    '--shortcuts-text': '#ff006e',
                    '--shortcuts-button-bg': 'rgba(255, 0, 110, 0.1)',
                    '--shortcuts-button-border': '#ff006e',
                    '--shortcuts-button-hover-bg': 'rgba(255, 183, 0, 0.2)',
                    '--shortcuts-button-hover-color': '#ffb700',
                    '--shortcuts-button-hover-border': '#ffb700',
                    '--shortcuts-scrollbar-track': '#0f001a',
                    '--shortcuts-scrollbar-thumb': '#ff006e',
                    '--shortcuts-section-bg': 'rgba(255, 0, 110, 0.05)',
                    '--shortcuts-section-border': '#ff006e',
                    '--shortcuts-section-title': '#ff006e',
                    '--shortcuts-accent': '#ffb700',
                    '--shortcuts-item-border': 'rgba(255, 0, 110, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(255, 183, 0, 0.2)',
                    '--shortcuts-kbd-border': '#ffb700',
                    '--shortcuts-kbd-color': '#ffb700',
                    '--shortcuts-kbd-shadow': 'rgba(255, 183, 0, 0.5)',
                    '--shortcuts-plus-color': '#ff006e'
                },
                'retro-wave': {
                    '--shortcuts-bg': '#0c0c14',
                    '--shortcuts-header-bg': '#05050a',
                    '--shortcuts-border': '#f71fb1',
                    '--shortcuts-title-color': '#ffd400',
                    '--shortcuts-text': '#f71fb1',
                    '--shortcuts-button-bg': 'rgba(247, 31, 177, 0.1)',
                    '--shortcuts-button-border': '#f71fb1',
                    '--shortcuts-button-hover-bg': 'rgba(255, 212, 0, 0.2)',
                    '--shortcuts-button-hover-color': '#ffd400',
                    '--shortcuts-button-hover-border': '#ffd400',
                    '--shortcuts-scrollbar-track': '#05050a',
                    '--shortcuts-scrollbar-thumb': '#f71fb1',
                    '--shortcuts-section-bg': 'rgba(247, 31, 177, 0.05)',
                    '--shortcuts-section-border': '#f71fb1',
                    '--shortcuts-section-title': '#f71fb1',
                    '--shortcuts-accent': '#ffd400',
                    '--shortcuts-item-border': 'rgba(247, 31, 177, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(255, 212, 0, 0.2)',
                    '--shortcuts-kbd-border': '#ffd400',
                    '--shortcuts-kbd-color': '#ffd400',
                    '--shortcuts-kbd-shadow': 'rgba(255, 212, 0, 0.5)',
                    '--shortcuts-plus-color': '#f71fb1'
                },
                'forest-dawn': {
                    '--shortcuts-bg': '#1a1d1a',
                    '--shortcuts-header-bg': '#0f110f',
                    '--shortcuts-border': '#3e503e',
                    '--shortcuts-title-color': '#87c987',
                    '--shortcuts-text': '#a8cfa8',
                    '--shortcuts-button-bg': 'rgba(62, 80, 62, 0.4)',
                    '--shortcuts-button-border': '#4a5e4a',
                    '--shortcuts-button-hover-bg': 'rgba(135, 201, 135, 0.1)',
                    '--shortcuts-button-hover-color': '#87c987',
                    '--shortcuts-button-hover-border': '#87c987',
                    '--shortcuts-scrollbar-track': '#0f110f',
                    '--shortcuts-scrollbar-thumb': '#4a5e4a',
                    '--shortcuts-section-bg': 'rgba(26, 29, 26, 0.6)',
                    '--shortcuts-section-border': '#3e503e',
                    '--shortcuts-section-title': '#a8cfa8',
                    '--shortcuts-accent': '#87c987',
                    '--shortcuts-item-border': 'rgba(74, 94, 74, 0.3)',
                    '--shortcuts-kbd-bg': 'rgba(152, 217, 152, 0.15)',
                    '--shortcuts-kbd-border': '#98d998',
                    '--shortcuts-kbd-color': '#98d998',
                    '--shortcuts-kbd-shadow': 'rgba(152, 217, 152, 0.2)',
                    '--shortcuts-plus-color': '#6b8f6b'
                }
                // All themes now have proper shortcuts modal configurations
            };
            
            // Get variables for the current theme, fallback to ayu-mirage defaults
            const variables = themeVariables[themeClass] || themeVariables['ayu-mirage'];
            
            // Define default command token variables based on theme type
            const isLightTheme = themeClass === 'light' || themeClass === 'forest-dawn' || themeClass === 'hotdog-stand';
            const defaultTokenVariables = isLightTheme ? {
                '--token-command-bg': '#e3f2fd',
                '--token-command-color': '#1565c0',
                '--token-command-border': '#bbdefb',
                '--token-subcommand-bg': '#f3e5f5',
                '--token-subcommand-color': '#7b1fa2',
                '--token-subcommand-border': '#e1bee7',
                '--token-option-bg': '#f3e5f5',
                '--token-option-color': '#6a1b9a',
                '--token-option-border': '#e1bee7',
                '--token-argument-bg': '#e8f5e9',
                '--token-argument-color': '#2e7d32',
                '--token-argument-border': '#c8e6c9',
                '--token-variable-bg': '#e1f5fe',
                '--token-variable-color': '#0277bd',
                '--token-variable-border': '#b3e5fc',
                '--token-expansion-bg': '#fff3e0',
                '--token-expansion-color': '#e65100',
                '--token-expansion-border': '#ffe0b2',
                '--token-operator-bg': '#fff3e0',
                '--token-operator-color': '#e65100',
                '--token-operator-border': '#ffe0b2',
                '--token-redirect-bg': '#fce4ec',
                '--token-redirect-color': '#c2185b',
                '--token-redirect-border': '#f8bbd0',
                '--token-special-bg': '#fafafa',
                '--token-special-color': '#424242',
                '--token-special-border': '#e0e0e0'
            } : {
                '--token-command-bg': 'rgba(79, 193, 255, 0.15)',
                '--token-command-color': '#4fc1ff',
                '--token-command-border': 'rgba(79, 193, 255, 0.3)',
                '--token-subcommand-bg': 'rgba(156, 120, 255, 0.15)',
                '--token-subcommand-color': '#9c78ff',
                '--token-subcommand-border': 'rgba(156, 120, 255, 0.3)',
                '--token-option-bg': 'rgba(255, 120, 198, 0.15)',
                '--token-option-color': '#ff78c6',
                '--token-option-border': 'rgba(255, 120, 198, 0.3)',
                '--token-argument-bg': 'rgba(120, 255, 120, 0.15)',
                '--token-argument-color': '#78ff78',
                '--token-argument-border': 'rgba(120, 255, 120, 0.3)',
                '--token-variable-bg': 'rgba(102, 187, 255, 0.15)',
                '--token-variable-color': '#66bbff',
                '--token-variable-border': 'rgba(102, 187, 255, 0.3)',
                '--token-expansion-bg': 'rgba(255, 183, 77, 0.15)',
                '--token-expansion-color': '#ffb74d',
                '--token-expansion-border': 'rgba(255, 183, 77, 0.3)',
                '--token-operator-bg': 'rgba(255, 167, 38, 0.15)',
                '--token-operator-color': '#ffa726',
                '--token-operator-border': 'rgba(255, 167, 38, 0.3)',
                '--token-redirect-bg': 'rgba(240, 98, 146, 0.15)',
                '--token-redirect-color': '#f06292',
                '--token-redirect-border': 'rgba(240, 98, 146, 0.3)',
                '--token-special-bg': 'rgba(189, 189, 189, 0.1)',
                '--token-special-color': '#bdbdbd',
                '--token-special-border': 'rgba(189, 189, 189, 0.2)'
            };
            
            // Merge theme variables with defaults (theme-specific variables take precedence)
            const allVariables = { ...defaultTokenVariables, ...variables };
            
            // Apply variables to root element
            Object.entries(allVariables).forEach(([key, value]) => {
                root.style.setProperty(key, value);
            });
        }
        
        const themes = [
            { 
                name: 'Ayu Mirage', 
                class: 'ayu-mirage', 
                icon: '🌑', 
                file: 'themes/ayu-mirage.css',
                description: 'Warm colors with orange accents',
                categories: ['dark'],
                colors: { bg: '#1f2430', fg: '#cccac2', accent: '#ffcc66' }
            },
            { 
                name: 'Catppuccin Mocha', 
                class: 'catppuccin-mocha', 
                icon: '☕', 
                file: 'themes/catppuccin-mocha.css',
                description: 'Soothing pastel dark theme',
                categories: ['dark'],
                colors: { bg: '#1e1e2e', fg: '#cdd6f4', accent: '#f5e0dc' }
            },
            { 
                name: 'Cyber Frost', 
                class: 'cyber-frost', 
                icon: '❄️', 
                file: 'themes/cyber-frost.css',
                description: 'Cool blue cyberpunk aesthetics',
                categories: ['dark', 'vibrant'],
                colors: { bg: '#0a0e27', fg: '#e0e8ff', accent: '#00ffff' }
            },
            { 
                name: 'Dark', 
                class: 'dark-mode', 
                icon: '🌙', 
                file: 'themes/dark.css',
                description: 'Classic dark mode',
                categories: ['dark'],
                colors: { bg: '#1a1a1a', fg: '#e0e0e0', accent: '#4285f4' }
            },
            { 
                name: 'Dracula', 
                class: 'dracula', 
                icon: '🧛', 
                file: 'themes/dracula.css',
                description: 'Dark theme with purple accents',
                categories: ['dark'],
                colors: { bg: '#282a36', fg: '#f8f8f2', accent: '#bd93f9' }
            },
            { 
                name: 'Everforest', 
                class: 'everforest', 
                icon: '🌲', 
                file: 'themes/everforest.css',
                description: 'Natural green forest theme',
                categories: ['dark'],
                colors: { bg: '#2b3339', fg: '#d3c6aa', accent: '#a7c080' }
            },
            { 
                name: 'Forest Dawn', 
                class: 'forest-dawn', 
                icon: '🌲', 
                file: 'themes/forest-dawn.css',
                description: 'Natural green sunrise',
                categories: ['light'],
                colors: { bg: '#fffbef', fg: '#5c6a72', accent: '#8da101' }
            },
            { 
                name: 'GitHub Dark', 
                class: 'github-dark', 
                icon: '🐙', 
                file: 'themes/github-dark.css',
                description: 'GitHub\'s professional dark theme',
                categories: ['dark'],
                colors: { bg: '#0d1117', fg: '#f0f6fc', accent: '#2f81f7' }
            },
            { 
                name: 'Gruvbox', 
                class: 'gruvbox', 
                icon: '📦', 
                file: 'themes/gruvbox.css',
                description: 'Retro groove with warm colors',
                categories: ['dark'],
                colors: { bg: '#282828', fg: '#ebdbb2', accent: '#fabd2f' }
            },
            { 
                name: 'High Contrast', 
                class: 'high-contrast', 
                icon: '⚫', 
                file: 'themes/high-contrast.css',
                description: 'Maximum readability',
                categories: ['dark'],
                colors: { bg: '#000000', fg: '#ffffff', accent: '#ffff00' }
            },
            { 
                name: 'Hotdog Stand', 
                class: 'hotdog-stand', 
                icon: '🌭', 
                file: 'themes/hotdog-stand.css',
                description: 'Classic Windows 3.1 style',
                categories: ['vibrant'],
                colors: { bg: '#ff0000', fg: '#ffff00', accent: '#ffffff' }
            },
            { 
                name: 'Kanagawa', 
                class: 'kanagawa', 
                icon: '🌊', 
                file: 'themes/kanagawa.css',
                description: 'Japanese inspired dark theme',
                categories: ['dark'],
                colors: { bg: '#1f1f28', fg: '#dcd7ba', accent: '#7e9cd8' }
            },
            { 
                name: 'Light', 
                class: '', 
                icon: '☀️', 
                file: '',
                description: 'Clean light theme',
                categories: ['light'],
                colors: { bg: '#ffffff', fg: '#333333', accent: '#0066cc' }
            },
            { 
                name: 'Material Design', 
                class: 'material-design', 
                icon: '🎨', 
                file: 'themes/material-design.css',
                description: 'Google\'s Material Design',
                categories: ['light'],
                colors: { bg: '#fafafa', fg: '#212121', accent: '#2196f3' }
            },
            { 
                name: 'Miami Sunrise', 
                class: 'miami-sunrise', 
                icon: '🌅', 
                file: 'themes/miami-sunrise.css',
                description: 'Vibrant sunset colors',
                categories: ['vibrant'],
                colors: { bg: '#2d1b69', fg: '#f8f8f2', accent: '#ff79c6' }
            },
            { 
                name: 'Monokai', 
                class: 'monokai', 
                icon: '🎮', 
                file: 'themes/monokai.css',
                description: 'Popular coding theme',
                categories: ['dark'],
                colors: { bg: '#272822', fg: '#f8f8f2', accent: '#a6e22e' }
            },
            { 
                name: 'Neon Noir', 
                class: 'neon-noir', 
                icon: '🔮', 
                file: 'themes/neon-noir.css',
                description: 'Cyberpunk neon aesthetics',
                categories: ['dark', 'vibrant'],
                colors: { bg: '#0a0a0a', fg: '#ffffff', accent: '#ff0080' }
            },
            { 
                name: 'Nord', 
                class: 'nord', 
                icon: '🏔️', 
                file: 'themes/nord.css',
                description: 'Arctic inspired palette',
                categories: ['dark'],
                colors: { bg: '#2e3440', fg: '#d8dee9', accent: '#5e81ac' }
            },
            { 
                name: 'Ocean Depth', 
                class: 'ocean-depth', 
                icon: '🌊', 
                file: 'themes/ocean-depth.css',
                description: 'Deep sea exploration',
                categories: ['dark'],
                colors: { bg: '#0f111a', fg: '#8f93a2', accent: '#84ffff' }
            },
            { 
                name: 'One Dark', 
                class: 'one-dark', 
                icon: '🌑', 
                file: 'themes/one-dark.css',
                description: 'Atom\'s signature dark theme',
                categories: ['dark'],
                colors: { bg: '#282c34', fg: '#abb2bf', accent: '#61afef' }
            },
            { 
                name: 'Palenight', 
                class: 'palenight', 
                icon: '🌌', 
                file: 'themes/palenight.css',
                description: 'Material theme with purple tint',
                categories: ['dark'],
                colors: { bg: '#292d3e', fg: '#a6accd', accent: '#c792ea' }
            },
            { 
                name: 'Retro Wave', 
                class: 'retro-wave', 
                icon: '🌴', 
                file: 'themes/retro-wave.css',
                description: '80s synthwave aesthetics',
                categories: ['dark', 'vibrant'],
                colors: { bg: '#1a1a2e', fg: '#ff6b6b', accent: '#f72585' }
            },
            { 
                name: 'Rose Pine', 
                class: 'rose-pine', 
                icon: '🌹', 
                file: 'themes/rose-pine.css',
                description: 'Soho vibes with rose tones',
                categories: ['dark'],
                colors: { bg: '#191724', fg: '#e0def4', accent: '#ebbcba' }
            },
            { 
                name: 'Solarized', 
                class: 'solarized-dark', 
                icon: '🌅', 
                file: 'themes/solarized-dark.css',
                description: 'Precision colors for readability',
                categories: ['dark'],
                colors: { bg: '#002b36', fg: '#839496', accent: '#268bd2' }
            },
            { 
                name: 'Synthwave \'84', 
                class: 'synthwave-84', 
                icon: '🌠', 
                file: 'themes/synthwave-84.css',
                description: 'Neon-soaked retro future',
                categories: ['dark', 'vibrant'],
                colors: { bg: '#262335', fg: '#ffffff', accent: '#ff7edb' }
            },
            { 
                name: 'Tokyo Night', 
                class: 'tokyo-night', 
                icon: '🌃', 
                file: 'themes/tokyo-night.css',
                description: 'Tokyo city lights at night',
                categories: ['dark'],
                colors: { bg: '#1a1b26', fg: '#a9b1d6', accent: '#7aa2f7' }
            }
        ];
        
        // Make themes available globally for performance managers
        window.themes = themes;

        // Initialize managers
        const asyncDOMScheduler = new AsyncDOMScheduler();
        const elementPool = new ElementRecyclingPool();
        const domBatchUpdater = new DOMBatchUpdater();
        const loadingStateManager = new LoadingStateManager();
        const smartSearchManager = new SmartSearchManager();
        const progressiveIndexLoader = new ProgressiveIndexLoader();
        const themePerformanceManager = new ThemePerformanceManager();
        const intelligentPreloadingManager = new IntelligentPreloadingManager();
        
        // Expose performance managers to window for testing and debugging
        window.asyncDOMScheduler = asyncDOMScheduler;
        window.elementPool = elementPool;
        window.domBatchUpdater = domBatchUpdater;
        window.loadingStateManager = loadingStateManager;
        window.smartSearchManager = smartSearchManager;
        window.progressiveIndexLoader = progressiveIndexLoader;
        window.themePerformanceManager = themePerformanceManager;
        window.intelligentPreloadingManager = intelligentPreloadingManager;
        
        // Initialize virtual search manager after DOM is ready
        let virtualSearchManager = null;

        // Cleanup on page unload to prevent memory leaks
        // Add flag to prevent cleanup during theme switches
        let isThemeSwitching = false;
        
        window.addEventListener('beforeunload', (e) => {
            // Don't cleanup if we're just switching themes
            if (isThemeSwitching) {
                console.log('Theme switching detected, skipping cleanup');
                return;
            }
            
            console.log('Page unloading, cleaning up resources...');
            elementPool.destroy();
            domBatchUpdater.clear();
            smartSearchManager.cancelCurrentSearch();
            if (virtualSearchManager) virtualSearchManager.destroy();
            themePerformanceManager.destroy();
            intelligentPreloadingManager.destroy();
            performanceManager.destroy();
        });

        // Also cleanup on visibility change (mobile browsers)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                domBatchUpdater.clear();
                smartSearchManager.cancelCurrentSearch();
                if (virtualSearchManager) virtualSearchManager.disable(); // Clear virtual items but don't destroy
                performanceManager.performMemoryCleanup();
            }
        });

        // Enable performance monitoring in development
        if (window.location.hostname === 'localhost') {
            domBatchUpdater.enableMeasurement(true);
            
            // Log element recycling stats periodically
            setInterval(() => {
                const stats = elementPool.getStats();
                console.log('Element Pool Stats:', stats);
            }, 60000); // Every minute
        }

        // DOM elements
        const container = document.getElementById('container');
        const searchInput = document.getElementById('searchInput');
        const sectionSelect = document.getElementById('sectionSelect');
        const searchButton = document.getElementById('searchButton');
        const suggestions = document.getElementById('suggestions');
        
        // Initialize virtual search manager for the suggestions container
        virtualSearchManager = new VirtualSearchManager(suggestions);
        const contentWrapper = document.getElementById('contentWrapper');
        const manPageContainer = document.getElementById('manPageContainer');
        const manPageTitle = document.getElementById('manPageTitle');
        const manPageContent = document.getElementById('manPageContent');
        const closeButton = document.getElementById('closeButton');
        const status = document.getElementById('status');
        const sectionNav = document.getElementById('sectionNav');
        const sectionNavList = document.getElementById('sectionNavList');
        const relatedCommands = document.getElementById('relatedCommands');
        const relatedCommandsList = document.getElementById('relatedCommandsList');
        const sidePanel = document.getElementById('sidePanel');
        const historyContent = document.getElementById('historyContent');
        const bookmarksContent = document.getElementById('bookmarksContent');
        const bookmarkBtn = document.getElementById('bookmarkBtn');
        const shortcutsHelp = document.getElementById('shortcutsHelp');
        const overlay = document.getElementById('overlay');
        const tldrSection = document.getElementById('tldrSection');
        const tldrContent = document.getElementById('tldrContent');
        const tldrJumpBtn = document.getElementById('tldrJumpBtn');

        // Load saved data from localStorage
        function loadSavedData() {
            try {
                const savedHistory = localStorage.getItem('manPageHistory');
                if (savedHistory) {
                    history = JSON.parse(savedHistory);
                }
                const savedBookmarks = localStorage.getItem('manPageBookmarks');
                if (savedBookmarks) {
                    bookmarks = JSON.parse(savedBookmarks);
                }
            } catch (e) {
                console.error('Failed to load saved data:', e);
            }
        }

        // Save data to localStorage
        function saveHistory() {
            try {
                localStorage.setItem('manPageHistory', JSON.stringify(history.slice(0, 50))); // Keep last 50
            } catch (e) {
                console.error('Failed to save history:', e);
            }
        }

        function saveBookmarks() {
            try {
                localStorage.setItem('manPageBookmarks', JSON.stringify(bookmarks));
            } catch (e) {
                console.error('Failed to save bookmarks:', e);
            }
        }

        // Show status message with smooth fade animation
        function showStatus(message, duration = 3000) {
            status.textContent = message;
            
            // Clear any existing timeout
            if (window.statusTimeout) {
                clearTimeout(window.statusTimeout);
            }
            
            // Show with fade-in animation
            status.classList.add('show');
            
            // Auto-hide with fade-out animation after duration
            window.statusTimeout = setTimeout(() => {
                status.classList.remove('show');
            }, duration);
        }

        // Process pre-formatted .txt man pages
        function processTextManPage(content) {
            // .txt files are already formatted, just need to:
            // 1. Reformat to reduce excessive spacing
            // 2. Make section headers recognizable
            // 3. Add syntax highlighting
            
            // Escape HTML entities
            content = content.replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');
            
            // Remove multiple consecutive blank lines (keep max 1 blank line)
            content = content.replace(/\n\s*\n\s*\n+/g, '\n\n');
            
            // Join lines that are continuations (lines that don't end with period/colon)
            // This helps with wrapped text in man pages
            content = content.replace(/([^\.\:\n])\n\s+([a-z])/g, '$1 $2');
            
            // Convert section headers (lines that are all caps at the start)
            content = content.replace(/^([A-Z][A-Z\s]+)$/gm, '<span class="section-header">$1</span>');
            
            // Bold formatting for options (e.g., -a, --all)
            content = content.replace(/(\s|^)(-{1,2}[a-zA-Z0-9-]+)(\s|,|;|$)/g, '$1<strong>$2</strong>$3');
            
            // Make cross-references clickable (e.g., ls(1), chmod(2))
            content = content.replace(/\b([a-z0-9_-]+)\((\d)\)/gi, function(match, cmd, section) {
                return '<span class="cross-ref" data-command="' + cmd + '" data-section="' + section + '">' + match + '</span>';
            });
            
            // Convert line breaks to <br> for proper formatting
            // But first, wrap option descriptions in divs for better formatting
            content = content.replace(/^(\s+)(-{1,2}[^<\n]+)$/gm, '<div class="indent">$2</div>');
            
            // Convert remaining line breaks
            content = content.replace(/\n/g, '<br>\n');
            
            return content;
        }


        // Enhanced man page loading with performance optimization
        async function loadManPageSection(command, section) {
            const cacheKey = `${command}_${section}`;
            
            // Check enhanced cache first
            const cached = performanceManager.caches.manPages.get(cacheKey);
            if (cached) {
                console.log(`Returning cached man page for ${command}(${section})`);
                return cached;
            }
            
            try {
                const response = await fetch(`man_pages/${command}.${section}.txt`);
                if (response.ok) {
                    const content = await response.text();
                    const data = {
                        section: section,
                        content: processTextManPage(content),
                        raw: content
                    };
                    
                    // Cache using enhanced cache system
                    performanceManager.caches.manPages.set(cacheKey, data);
                    
                    return data;
                }
            } catch (error) {
                console.error(`Error loading ${command}(${section}):`, error);
            }
            
            return null;
        }

        async function loadAllManPages(command) {
            const results = [];
            
            // Find all sections for this command in the search index
            const entries = window.searchIndex.filter(item => 
                (item.command || item.name) === command
            );
            
            // Sort by section number (lowest first)
            entries.sort((a, b) => {
                // Extract numeric part of section for sorting
                const getNumericSection = (section) => {
                    const match = String(section).match(/^(\d+)/);
                    return match ? parseInt(match[1]) : 999;
                };
                return getNumericSection(a.section) - getNumericSection(b.section);
            });
            
            // Return section metadata for lazy loading
            for (const entry of entries) {
                results.push({
                    section: entry.section,
                    description: entry.description,
                    content: null, // Content will be loaded on demand
                    command: command,
                    loaded: false
                });
            }
            
            if (results.length === 0) {
                throw new Error(`No man pages found for command: ${command}`);
            }
            
            return results;
        }

        // Process and enhance man page content
        function processManPageContent(content) {
            // LinuxCommandLibrary data contains HTML formatting that we need to preserve
            // while still protecting against XSS attacks
            
            // Step 1: Escape potentially dangerous characters except for safe HTML tags
            // We'll use a more selective approach
            
            // First, protect script tags and other dangerous elements
            content = content.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
            content = content.replace(/<iframe[^>]*>[\s\S]*?<\/iframe>/gi, '');
            content = content.replace(/<object[^>]*>[\s\S]*?<\/object>/gi, '');
            content = content.replace(/<embed[^>]*>/gi, '');
            
            // Step 2: Process custom tags from LinuxCommandLibrary
            // These appear to be already HTML with custom classes
            content = content.replace(/<command>/g, '<span class="command">');
            content = content.replace(/<\/command>/g, '</span>');
            content = content.replace(/<option>/g, '<span class="option">');
            content = content.replace(/<\/option>/g, '</span>');
            
            // Step 3: Remove TLDR sections from the man page content
            // We display a better formatted TLDR at the bottom from the TLDR pages project
            // Match TLDR followed by everything until the next all-caps section header
            content = content.replace(/TLDR\n[\s\S]*?(?=\n[A-Z][A-Z\s]+\n)/g, '');
            
            // Step 4: Process section headers
            // LinuxCommandLibrary uses plain text headers, so we need to identify them
            content = content.replace(/^([A-Z][A-Z\s]+)$/gm, function(match) {
                // Don't process if it's already in HTML tags
                if (match.includes('<') || match.includes('>')) {
                    return match;
                }
                return '<span class="section-header">' + match + '</span>';
            });
            
            // Step 5: Highlight commands in backticks (LinuxCommandLibrary format)
            content = content.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Step 6: Process square brackets as placeholders
            content = content.replace(/\[([^\]]+)\]/g, '<span class="placeholder">[$1]</span>');
            
            // Step 7: Make cross-references clickable (e.g., ls(1), chmod(2))
            content = content.replace(/\b([a-z0-9_-]+)\((\d)\)/gi, function(match, cmd, section) {
                return '<span class="cross-ref" data-command="' + cmd + '" data-section="' + section + '">' + match + '</span>';
            });
            
            // Step 8: Ensure line breaks are preserved
            // LinuxCommandLibrary content already has <br> tags, so we don't need to add more
            // Just ensure newlines are converted where needed
            content = content.replace(/\n/g, function(match, offset) {
                // Check if we're already in an HTML context
                const before = content.substring(Math.max(0, offset - 10), offset);
                const after = content.substring(offset, Math.min(content.length, offset + 10));
                
                // Don't add <br> if we're already near a <br> tag
                if (before.includes('<br>') || after.includes('<br>')) {
                    return match;
                }
                
                // Don't add <br> inside HTML tags
                if (before.includes('<') && !before.includes('>')) {
                    return match;
                }
                
                return '<br>\n';
            });
            
            // Step 9: Clean up any double escaping that might have occurred
            content = content.replace(/&amp;lt;/g, '&lt;');
            content = content.replace(/&amp;gt;/g, '&gt;');
            content = content.replace(/&amp;amp;/g, '&amp;');
            
            return content;
        }

        // Extract sections from man page content
        function extractSections(content) {
            const sections = [];
            const lines = content.split('\n');
            let currentSection = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                // Check if this is a section header (all caps, at start of line)
                if (/^[A-Z][A-Z\s]+$/.test(line.trim()) && line.trim().length > 2) {
                    const sectionName = line.trim();
                    // Skip TLDR section since we display it separately at the bottom
                    if (sectionName === 'TLDR') {
                        continue;
                    }
                    currentSection = {
                        name: sectionName,
                        line: i,
                        id: sectionName.toLowerCase().replace(/\s+/g, '-')
                    };
                    sections.push(currentSection);
                }
            }
            
            return sections;
        }
        
        // Extract sections from HTML content
        function extractSectionsFromContent(htmlContent) {
            const sections = [];
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            
            // Find all section headers
            const headers = tempDiv.querySelectorAll('.section-header');
            headers.forEach(header => {
                const sectionName = header.textContent.trim();
                if (sectionName && sectionName !== 'TLDR') {
                    sections.push({
                        name: sectionName,
                        id: sectionName.toLowerCase().replace(/\s+/g, '-')
                    });
                }
            });
            
            return sections;
        }
        
        // Scroll to section within a specific man page section
        function scrollToSectionInContent(manSection, sectionName) {
            const targetSection = document.querySelector(`.man-section[data-section="${manSection}"]`);
            if (!targetSection) return;
            
            const content = targetSection.querySelector('.man-page-content');
            if (!content) return;
            
            // Find the section header
            const headers = content.querySelectorAll('.section-header');
            for (const header of headers) {
                if (header.textContent.trim() === sectionName) {
                    header.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    return;
                }
            }
        }

        // Build section navigation
        function buildSectionNav(sections) {
            sectionNavList.innerHTML = '';
            
            sections.forEach(section => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#' + section.id;
                a.textContent = section.name;
                a.dataset.line = section.line;
                
                a.addEventListener('click', (e) => {
                    e.preventDefault();
                    scrollToSection(section.id);
                    
                    // Update active state
                    document.querySelectorAll('.section-nav a').forEach(link => {
                        link.classList.remove('active');
                    });
                    a.classList.add('active');
                });
                
                li.appendChild(a);
                sectionNavList.appendChild(li);
            });
        }
        
        // Build navigation for all man page sections
        function buildNavigationForAllSections(allSections) {
            sectionNavList.innerHTML = '';
            
            allSections.forEach((sectionData, sectionIndex) => {
                // Create section group
                const sectionGroup = document.createElement('li');
                
                // Section header
                const sectionHeader = document.createElement('div');
                sectionHeader.className = 'nav-section-header';
                if (sectionIndex === 0) {
                    sectionHeader.classList.add('active');
                }
                
                // Extract section number for icon
                const sectionNum = String(sectionData.section).match(/^\d+/) ? String(sectionData.section).match(/^\d+/)[0] : sectionData.section;
                
                sectionHeader.innerHTML = `
                    <span class="nav-section-icon">${sectionNum}</span>
                    ${sectionData.command}(${sectionData.section})
                `;
                
                // Click on section header to expand/collapse that section
                sectionHeader.addEventListener('click', () => {
                    // Update active state
                    document.querySelectorAll('.nav-section-header').forEach(h => h.classList.remove('active'));
                    sectionHeader.classList.add('active');
                    
                    // Toggle sub-navigation
                    const subList = sectionGroup.querySelector('.nav-sub-list');
                    if (subList) {
                        document.querySelectorAll('.nav-sub-list').forEach(list => list.classList.remove('active'));
                        subList.classList.add('active');
                    }
                    
                    // Toggle the main section
                    const targetSection = document.querySelector(`.man-section[data-section="${sectionData.section}"]`);
                    if (targetSection) {
                        // Collapse all sections first
                        document.querySelectorAll('.man-section').forEach(section => {
                            section.classList.add('collapsed');
                            const contentDiv = section.querySelector('.man-section-content');
                            if (contentDiv) {
                                contentDiv.style.maxHeight = '0';
                            }
                        });
                        
                        // Expand the clicked section
                        targetSection.classList.remove('collapsed');
                        const contentDiv = targetSection.querySelector('.man-section-content');
                        if (contentDiv) {
                            contentDiv.style.maxHeight = contentDiv.scrollHeight + 'px';
                            setTimeout(() => {
                                contentDiv.style.maxHeight = 'none';
                            }, 300);
                        }
                        
                        // Scroll to section
                        targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
                
                sectionGroup.appendChild(sectionHeader);
                
                // Extract sections from content
                const sections = extractSectionsFromContent(sectionData.content);
                
                // Create sub-navigation
                if (sections.length > 0) {
                    const subList = document.createElement('ul');
                    subList.className = 'nav-sub-list';
                    if (sectionIndex === 0) {
                        subList.classList.add('active');
                    }
                    
                    sections.forEach(section => {
                        const li = document.createElement('li');
                        const a = document.createElement('a');
                        a.href = '#';
                        a.textContent = section.name;
                        
                        a.addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            // First, ensure the section is expanded
                            const targetSection = document.querySelector(`.man-section[data-section="${sectionData.section}"]`);
                            if (targetSection && targetSection.classList.contains('collapsed')) {
                                // Click the header to expand it
                                sectionHeader.click();
                            }
                            
                            // Then scroll to the specific section
                            setTimeout(() => {
                                scrollToSectionInContent(sectionData.section, section.name);
                                
                                // Update active state
                                document.querySelectorAll('.nav-sub-list a').forEach(link => {
                                    link.classList.remove('active');
                                });
                                a.classList.add('active');
                            }, targetSection && targetSection.classList.contains('collapsed') ? 350 : 0);
                        });
                        
                        li.appendChild(a);
                        subList.appendChild(li);
                    });
                    
                    sectionGroup.appendChild(subList);
                }
                
                sectionNavList.appendChild(sectionGroup);
            });
        }

        // Scroll to section
        function scrollToSection(sectionId) {
            // First try to find section headers with class
            const sectionHeaders = manPageContent.querySelectorAll('.section-header');
            for (const header of sectionHeaders) {
                if (header.textContent.toLowerCase().replace(/\s+/g, '-') === sectionId) {
                    header.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    return;
                }
            }
            
            // Fallback: Search in text content
            const content = manPageContent.textContent;
            const lines = content.split('\n');
            let targetLine = -1;
            
            // Find the line containing the section header
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Handle both proper headers and malformed ones
                if (line.toLowerCase().replace(/\s+/g, '-') === sectionId && /^[A-Z][A-Z\s]+$/.test(line)) {
                    targetLine = i;
                    break;
                }
                // Also check for the malformed section headers (e.g., "section-header>NAME")
                if (line.includes('section-header>')) {
                    const headerText = line.replace('section-header>', '').trim();
                    if (headerText.toLowerCase().replace(/\s+/g, '-') === sectionId) {
                        targetLine = i;
                        break;
                    }
                }
            }
            
            if (targetLine >= 0) {
                // Calculate position based on line number
                const totalLines = lines.length;
                const percentage = targetLine / totalLines;
                
                // Get the content element's position relative to the page
                const contentRect = manPageContent.getBoundingClientRect();
                const contentTop = contentRect.top + window.pageYOffset;
                
                // Calculate target scroll position
                const targetScrollPosition = contentTop + (manPageContent.offsetHeight * percentage) - 100;
                
                // Scroll the window
                window.scrollTo({
                    top: targetScrollPosition,
                    behavior: 'smooth'
                });
            }
        }

        // Find related commands
        function findRelatedCommands(command, content) {
            const related = new Set();
            
            // Extract from SEE ALSO section
            const seeAlsoMatch = content.match(/SEE ALSO[\s\S]*?(?=^[A-Z]|\n\n|$)/mi);
            if (seeAlsoMatch) {
                const matches = seeAlsoMatch[0].matchAll(/\b([a-z0-9_-]+)\((\d)\)/gi);
                for (const match of matches) {
                    if (match[1].toLowerCase() !== command.toLowerCase()) {
                        related.add({ command: match[1], section: match[2] });
                    }
                }
            }
            
            // Extract from cross-references in content
            const crossRefs = content.matchAll(/\b([a-z0-9_-]+)\((\d)\)/gi);
            for (const match of crossRefs) {
                if (match[1].toLowerCase() !== command.toLowerCase() && related.size < 10) {
                    related.add({ command: match[1], section: match[2] });
                }
            }
            
            return Array.from(related);
        }

        // Display related commands
        function displayRelatedCommands(relatedCmds) {
            if (relatedCmds.length === 0) {
                relatedCommands.style.display = 'none';
                return;
            }
            
            relatedCommandsList.innerHTML = '';
            relatedCmds.forEach(cmd => {
                const link = document.createElement('a');
                link.className = 'related-command';
                link.textContent = `${cmd.command}(${cmd.section})`;
                link.href = '#';
                
                performanceManager.addManagedEventListener(link, 'click', (e) => {
                    e.preventDefault();
                    // Just display the command, it will show all sections
                    displayManPage(cmd.command, cmd.section);
                });
                
                relatedCommandsList.appendChild(link);
            });
            
            relatedCommands.style.display = 'block';
        }

        // Enhanced TLDR Functions with caching
        async function fetchTLDR(command) {
            const cacheKey = `tldr_${command}`;
            
            // Check enhanced cache first
            const cached = performanceManager.caches.tldr.get(cacheKey);
            if (cached) {
                console.log(`Returning cached TLDR for ${command}`);
                return cached;
            }
            
            // Check if TLDR index is loaded
            if (!window.tldrIndex) {
                console.error('TLDR index not loaded');
                return null;
            }
            
            // Try common and linux platforms
            const platforms = ['common', 'linux'];
            
            for (const platform of platforms) {
                // Check if command exists in this platform
                if (window.tldrIndex[platform] && window.tldrIndex[platform].includes(command)) {
                    try {
                        const url = `tldr_pages/${platform}/${command}.md`;
                        const response = await fetch(url);
                        
                        if (response.ok) {
                            const content = await response.text();
                            
                            // Cache the TLDR content
                            performanceManager.caches.tldr.set(cacheKey, content);
                            
                            return content;
                        }
                    } catch (error) {
                        console.error(`Failed to fetch TLDR for ${command} from ${platform}:`, error);
                    }
                }
            }
            
            return null;
        }

        function parseTLDRMarkdown(markdown) {
            const lines = markdown.split('\n');
            const tldr = {
                command: '',
                description: '',
                examples: []
            };
            
            let currentExample = null;
            
            for (const line of lines) {
                // Command name
                if (line.startsWith('# ')) {
                    tldr.command = line.slice(2).trim();
                }
                // Description
                else if (line.startsWith('> ')) {
                    const descLine = line.slice(2).trim();
                    // Skip "More information:" lines completely
                    if (!descLine.startsWith('More information:')) {
                        tldr.description += descLine + ' ';
                    }
                }
                // Example description
                else if (line.startsWith('- ')) {
                    if (currentExample) {
                        tldr.examples.push(currentExample);
                    }
                    currentExample = {
                        description: line.slice(2).trim(),
                        code: ''
                    };
                }
                // Code block
                else if (line.startsWith('`') && line.endsWith('`') && line.length > 2) {
                    if (currentExample) {
                        currentExample.code = line.slice(1, -1);
                    }
                }
            }
            
            if (currentExample) {
                tldr.examples.push(currentExample);
            }
            
            tldr.description = tldr.description.trim();
            return tldr;
        }

        function highlightTLDRCode(code) {
            // Highlight placeholders {{example}}
            code = code.replace(/\{\{([^}]+)\}\}/g, '<span class="tldr-placeholder">$1</span>');
            
            // Highlight options
            code = code.replace(/(\s|^)(-{1,2}[a-zA-Z0-9-]+)/g, '$1<span class="tldr-option">$2</span>');
            
            return code;
        }

        function renderTLDR(tldr) {
            const htmlParts = [];
            
            if (tldr.description) {
                htmlParts.push(`<p class="tldr-description">${tldr.description}</p>`);
            }
            
            if (tldr.examples.length > 0) {
                htmlParts.push('<div class="tldr-examples">');
                htmlParts.push('<h5>Quick Examples:</h5>');
                
                for (const example of tldr.examples) {
                    htmlParts.push('<div class="tldr-example">');
                    htmlParts.push(`<p class="example-description">${example.description}</p>`);
                    htmlParts.push(`<pre class="example-code">${highlightTLDRCode(example.code)}</pre>`);
                    htmlParts.push('</div>');
                }
                
                htmlParts.push('</div>');
            }
            
            return htmlParts.join('');
        }

        async function displayTLDR(command) {
            tldrSection.style.display = 'block';
            
            // Clear content efficiently
            while (tldrContent.firstChild) {
                tldrContent.removeChild(tldrContent.firstChild);
            }
            
            // Create loading message
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'tldr-loading';
            loadingDiv.textContent = 'Loading TLDR summary...';
            tldrContent.appendChild(loadingDiv);
            
            try {
                // Ensure TLDR index is loaded
                const tldrIndexLoaded = await ensureTldrIndex();
                if (!tldrIndexLoaded) {
                    throw new Error('Failed to load TLDR index');
                }
                const markdown = await fetchTLDR(command);
                
                // Clear loading message safely
                if (loadingDiv.parentNode === tldrContent) {
                    tldrContent.removeChild(loadingDiv);
                }
                
                if (markdown) {
                    const tldr = parseTLDRMarkdown(markdown);
                    // Use innerHTML here since renderTLDR returns safe, controlled HTML
                    tldrContent.innerHTML = renderTLDR(tldr);
                } else {
                    const noTldrDiv = document.createElement('div');
                    noTldrDiv.className = 'no-tldr';
                    noTldrDiv.textContent = 'No TLDR summary available for this command.';
                    tldrContent.appendChild(noTldrDiv);
                }
            } catch (error) {
                console.error('Error displaying TLDR:', error);
                // Clear any existing content
                while (tldrContent.firstChild) {
                    tldrContent.removeChild(tldrContent.firstChild);
                }
                const errorDiv = document.createElement('div');
                errorDiv.className = 'no-tldr';
                errorDiv.textContent = 'Failed to load TLDR summary.';
                tldrContent.appendChild(errorDiv);
            }
        }

        // Add to history
        function addToHistory(command, section) {
            const entry = {
                command,
                section,
                timestamp: new Date().toISOString()
            };
            
            // Remove if already exists
            history = history.filter(h => !(h.command === command && h.section === section));
            
            // Add to beginning
            history.unshift(entry);
            
            // Keep only last 50
            if (history.length > 50) {
                history = history.slice(0, 50);
            }
            
            saveHistory();
            updateHistoryPanel();
        }

        // Update history panel
        function updateHistoryPanel() {
            historyContent.innerHTML = '';
            
            if (history.length === 0) {
                historyContent.innerHTML = '<p style="text-align: center; color: #999;">No history yet</p>';
                return;
            }
            
            history.forEach(item => {
                const div = document.createElement('div');
                div.className = 'side-panel-item';
                div.innerHTML = `
                    <div class="side-panel-item-command">${item.command}(${item.section})</div>
                    <div class="side-panel-item-meta">${new Date(item.timestamp).toLocaleDateString()}</div>
                `;
                
                performanceManager.addManagedEventListener(div, 'click', () => {
                    displayManPage(item.command, item.section);
                    sidePanel.classList.remove('open');
                });
                
                historyContent.appendChild(div);
            });
        }

        // Update bookmarks panel
        function updateBookmarksPanel() {
            bookmarksContent.innerHTML = '';
            
            if (bookmarks.length === 0) {
                bookmarksContent.innerHTML = '<p style="text-align: center; color: #999;">No bookmarks yet</p>';
                return;
            }
            
            bookmarks.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'side-panel-item';
                div.innerHTML = `
                    <div class="side-panel-item-command">${item.command}(${item.section})</div>
                    <div class="side-panel-item-meta">
                        ${item.description}
                        <button class="action-button" style="float: right; padding: 2px 6px; font-size: 12px;" onclick="removeBookmark(${index})">Remove</button>
                    </div>
                `;
                
                performanceManager.addManagedEventListener(div, 'click', (e) => {
                    if (!e.target.matches('button')) {
                        displayManPage(item.command, item.section);
                        sidePanel.classList.remove('open');
                    }
                });
                
                bookmarksContent.appendChild(div);
            });
        }

        // Toggle bookmark
        function toggleBookmark() {
            if (!currentManPage) return;
            
            const exists = bookmarks.findIndex(b => 
                b.command === currentManPage.command && b.section === currentManPage.section
            );
            
            if (exists >= 0) {
                bookmarks.splice(exists, 1);
                bookmarkBtn.classList.remove('active');
                showStatus('Bookmark removed');
            } else {
                const entry = window.searchIndex.find(cmd => 
                    cmd.command === currentManPage.command && cmd.section === currentManPage.section
                );
                if (entry) {
                    bookmarks.unshift({
                        command: currentManPage.command,
                        section: currentManPage.section,
                        description: entry.description
                    });
                    bookmarkBtn.classList.add('active');
                    showStatus('Bookmark added');
                }
            }
            
            saveBookmarks();
            updateBookmarksPanel();
        }

        // Remove bookmark
        window.removeBookmark = function(index) {
            bookmarks.splice(index, 1);
            saveBookmarks();
            updateBookmarksPanel();
            
            // Update bookmark button if current page
            if (currentManPage) {
                const exists = bookmarks.find(b => 
                    b.command === currentManPage.command && b.section === currentManPage.section
                );
                bookmarkBtn.classList.toggle('active', !!exists);
            }
        };


        // Full-text search in content
        async function searchInContent(query, section = '') {
            if (!query || query.length < 2) {
                return [];
            }

            const results = [];
            const lowerQuery = query.toLowerCase();
            const sectionFilter = section ? parseInt(section) : null;

            showStatus('Searching in all man pages...', 5000);

            // Content search is disabled in the new architecture
            // Each man page is loaded on-demand, so searching content would require loading all files
            showStatus('Content search is not available with on-demand loading', 3000);
            return [];
        }

        // Performance-optimized search function with cancellation support
        async function searchManPages(query, options = {}) {
            const { section = '', signal, requestId } = options;
            
            if (!query || query.length < 1) {
                return [];
            }

            // Check if request was cancelled before we start
            if (signal && signal.aborted) {
                throw new DOMException('Search aborted', 'AbortError');
            }

            // Create cache key from query and section
            const cacheKey = `${query.toLowerCase()}_${section || 'all'}`;
            
            // Check enhanced cache first
            const cachedResult = performanceManager.caches.search.get(cacheKey);
            if (cachedResult) {
                console.log(`Returning cached results for: "${query}", section: ${section || 'all'}`);
                return cachedResult;
            }

            // Check cancellation before expensive operations
            if (signal && signal.aborted) {
                throw new DOMException('Search aborted', 'AbortError');
            }

            // Ensure search index is loaded and build optimized indexes
            const indexLoaded = await ensureSearchIndex();
            if (!indexLoaded || typeof window.searchIndex === 'undefined') {
                console.error('Failed to load search index');
                showStatus('Failed to load search data', 3000);
                return [];
            }

            // Check cancellation after async operation
            if (signal && signal.aborted) {
                throw new DOMException('Search aborted', 'AbortError');
            }

            // Build optimized search indexes if not already built
            await performanceManager.buildSearchIndexes();

            // Final cancellation check before search
            if (signal && signal.aborted) {
                throw new DOMException('Search aborted', 'AbortError');
            }

            // Use the performance manager's optimized search
            const results = performanceManager.performOptimizedSearch(query, section, 10);
            
            // Group results by command name for UI display
            const groupedResults = [];
            const commandGroups = new Map();
            
            for (const entry of results) {
                // Check for cancellation during processing
                if (signal && signal.aborted) {
                    throw new DOMException('Search aborted', 'AbortError');
                }
                
                const commandName = entry.command || entry.name;
                if (!commandGroups.has(commandName)) {
                    commandGroups.set(commandName, {
                        ...entry,
                        command: commandName,
                        sections: [entry.section]
                    });
                } else {
                    const existing = commandGroups.get(commandName);
                    existing.sections.push(entry.section);
                    if (entry.section < existing.section) {
                        commandGroups.set(commandName, {
                            ...entry,
                            command: commandName,
                            sections: existing.sections
                        });
                    }
                }
            }
            
            const finalResults = Array.from(commandGroups.values());
            
            // Cache the results using the enhanced cache (only if not cancelled)
            if (!signal || !signal.aborted) {
                performanceManager.caches.search.set(cacheKey, finalResults);
            }
            
            return finalResults;
        }

        // Display suggestions with keyboard navigation
        let selectedSuggestionIndex = -1;
        
        function displaySuggestions(results) {
            console.log(`displaySuggestions called with ${results.length} results`);
            
            // Clear suggestions efficiently
            while (suggestions.firstChild) {
                suggestions.removeChild(suggestions.firstChild);
            }
            selectedSuggestionIndex = -1;
            
            if (results.length === 0) {
                suggestions.style.display = 'none';
                console.log('No results to display, hiding suggestions');
                return;
            }

            // Use DocumentFragment for batch DOM operations
            const fragment = document.createDocumentFragment();

            results.forEach((result, index) => {
                const suggestion = document.createElement('div');
                suggestion.className = 'suggestion';
                suggestion.dataset.index = index;
                
                // Create suggestion info container
                const suggestionInfo = document.createElement('div');
                suggestionInfo.className = 'suggestion-info';
                
                // Create command element
                const commandElement = document.createElement('div');
                commandElement.className = 'suggestion-command';
                commandElement.textContent = result.command || '';
                
                // Create description element
                const descElement = document.createElement('div');
                descElement.className = 'suggestion-desc';
                descElement.textContent = result.description || 'No description available';
                
                // Create section area
                const sectionArea = document.createElement('div');
                sectionArea.className = 'section-area';
                
                if (result.sections && result.sections.length > 1) {
                    // Multiple sections - create individual clickable spans
                    const sortedSections = result.sections.sort((a, b) => a - b);
                    sortedSections.forEach(sectionNum => {
                        const sectionBtn = document.createElement('span');
                        sectionBtn.className = 'section-badge section-clickable';
                        sectionBtn.textContent = `Section ${sectionNum}`;
                        sectionBtn.dataset.command = result.command;
                        sectionBtn.dataset.section = sectionNum;
                        sectionBtn.onclick = (e) => {
                            e.stopPropagation();
                            displayManPage(result.command, sectionNum);
                            suggestions.style.display = 'none';
                        };
                        sectionArea.appendChild(sectionBtn);
                    });
                } else {
                    // Single section - show badge
                    const sectionBadge = document.createElement('span');
                    sectionBadge.className = 'section-badge';
                    sectionBadge.textContent = `Section ${result.section}`;
                    sectionArea.appendChild(sectionBadge);
                }
                
                // Assemble structure
                suggestionInfo.appendChild(commandElement);
                suggestionInfo.appendChild(descElement);
                suggestion.appendChild(suggestionInfo);
                suggestion.appendChild(sectionArea);
                
                // Store data on the element for event delegation
                suggestion.dataset.command = result.command;
                suggestion.dataset.section = result.section;
                
                // Add to fragment instead of directly to DOM
                fragment.appendChild(suggestion);
            });
            
            // Single DOM operation to add all suggestions
            suggestions.appendChild(fragment);
            suggestions.style.display = 'block';
        }

        function updateSelectedSuggestion(newIndex) {
            const suggestionElements = suggestions.querySelectorAll('.suggestion');
            
            suggestionElements.forEach((el, index) => {
                el.classList.toggle('selected', index === newIndex);
            });
            
            selectedSuggestionIndex = newIndex;
            
            if (suggestionElements[newIndex]) {
                suggestionElements[newIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        // Display man page
        async function displayManPage(command, section) {
            // Update state
            currentState = 'viewing';
            container.classList.add('search-active');
            suggestions.style.display = 'none';
            contentWrapper.style.display = 'flex';
            
            // Show loading state with skeleton
            manPageTitle.textContent = command;
            loadingStateManager.showManPageLoading(manPageContent);
            
            // Store current page info
            currentManPage = { command, section: section };
            
            // Check if any section is bookmarked
            const isBookmarked = bookmarks.find(b => b.command === command);
            bookmarkBtn.classList.toggle('active', !!isBookmarked);
            
            try {
                // Load all man pages for this command
                showStatus(`Loading all sections for ${command}...`);
                const allSections = await loadAllManPages(command);
                
                // Hide loading skeleton and prepare for content
                loadingStateManager.hideLoading(manPageContent);
                manPageContent.innerHTML = '';
                manPageContent.className = 'man-page-content man-sections-container';
                
                // Display each section in a collapsible container
                allSections.forEach((sectionData, index) => {
                    const isFirstSection = index === 0;
                    const sectionDiv = document.createElement('div');
                    sectionDiv.className = `man-section ${isFirstSection ? '' : 'collapsed'}`;
                    sectionDiv.dataset.section = sectionData.section;
                    sectionDiv.dataset.command = command;
                    
                    // Create header
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'man-section-header';
                    headerDiv.innerHTML = `
                        <div class="man-section-info">
                            <span class="man-section-title">${command}(${sectionData.section})</span>
                            <span class="section-badge">Section ${sectionData.section}</span>
                            ${!isFirstSection ? '<span class="unloaded-indicator" title="Content will be loaded on first click">●</span>' : ''}
                        </div>
                        <span class="collapse-icon">▼</span>
                    `;
                    
                    // Create content container
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'man-section-content';
                    
                    // Create inner content wrapper for padding
                    const innerContent = document.createElement('div');
                    innerContent.className = 'man-page-content';
                    
                    // For the first section, load content immediately
                    if (isFirstSection) {
                        const loadingId = loadingStateManager.showSpinner(innerContent, 'Loading content...');
                        loadManPageSection(command, sectionData.section).then(data => {
                            loadingStateManager.hideLoading(loadingId);
                            if (data) {
                                innerContent.innerHTML = data.content;
                                sectionData.content = data.content;
                                sectionData.loaded = true;
                                
                                // Remove unloaded indicator
                                const indicator = headerDiv.querySelector('.unloaded-indicator');
                                if (indicator) {
                                    indicator.remove();
                                }
                                
                                // Add cross-reference click handlers with memory management
                                innerContent.querySelectorAll('.cross-ref').forEach(ref => {
                                    performanceManager.addManagedEventListener(ref, 'click', (e) => {
                                        e.stopPropagation();
                                        const refCommand = ref.dataset.command;
                                        const refSection = ref.dataset.section;
                                        displayManPage(refCommand, refSection);
                                    });
                                });
                                
                                // Find related commands from first section
                                const relatedCmds = findRelatedCommands(command, data.content);
                                displayRelatedCommands(relatedCmds);
                            } else {
                                innerContent.innerHTML = '<div class="error">Failed to load content</div>';
                            }
                        });
                    } else {
                        // For other sections, show placeholder
                        innerContent.innerHTML = '<div class="loading-placeholder">Click to load content...</div>';
                    }
                    
                    contentDiv.appendChild(innerContent);
                    
                    // Add click handler to header
                    performanceManager.addManagedEventListener(headerDiv, 'click', async () => {
                        // If expanding and content not loaded, load it first
                        if (sectionDiv.classList.contains('collapsed') && !sectionData.loaded) {
                            const loadingId = loadingStateManager.showSpinner(innerContent, 'Loading section...');
                            
                            const data = await loadManPageSection(command, sectionData.section);
                            loadingStateManager.hideLoading(loadingId);
                            
                            if (data) {
                                innerContent.innerHTML = data.content;
                                sectionData.content = data.content;
                                sectionData.loaded = true;
                                
                                // Remove unloaded indicator
                                const indicator = headerDiv.querySelector('.unloaded-indicator');
                                if (indicator) {
                                    indicator.remove();
                                }
                                
                                // Add cross-reference click handlers with memory management
                                innerContent.querySelectorAll('.cross-ref').forEach(ref => {
                                    performanceManager.addManagedEventListener(ref, 'click', (e) => {
                                        e.stopPropagation();
                                        const refCommand = ref.dataset.command;
                                        const refSection = ref.dataset.section;
                                        displayManPage(refCommand, refSection);
                                    });
                                });
                            } else {
                                innerContent.innerHTML = '<div class="error">Failed to load content</div>';
                            }
                        }
                        
                        sectionDiv.classList.toggle('collapsed');
                        
                        // If expanding this section, we need to set max-height for animation
                        if (!sectionDiv.classList.contains('collapsed')) {
                            contentDiv.style.maxHeight = contentDiv.scrollHeight + 'px';
                            setTimeout(() => {
                                contentDiv.style.maxHeight = 'none';
                            }, 300);
                        } else {
                            contentDiv.style.maxHeight = contentDiv.scrollHeight + 'px';
                            setTimeout(() => {
                                contentDiv.style.maxHeight = '0';
                            }, 10);
                        }
                    });
                    
                    sectionDiv.appendChild(headerDiv);
                    sectionDiv.appendChild(contentDiv);
                    manPageContent.appendChild(sectionDiv);
                    
                    // Set initial max-height for first section
                    if (isFirstSection) {
                        contentDiv.style.maxHeight = 'none';
                    }
                });
                
                // Show section navigation
                sectionNav.style.display = 'block';
                
                // Build navigation for all sections
                buildNavigationForAllSections(allSections);
                
                // Related commands will be loaded after first section content loads
                
                // Display TLDR summary
                displayTLDR(command);
                
                // Add to history (just the command, not specific section)
                addToHistory(command, allSections[0].section);
                
                // Update URL hash for direct linking
                if (window.location.hash !== '#' + command) {
                    isSettingHash = true;
                    window.location.hash = command;
                }
                
                // Scroll to top
                manPageContent.scrollTop = 0;
                
            } catch (error) {
                console.error('Error loading man pages:', error);
                loadingStateManager.hideLoading(manPageContent);
                manPageContent.innerHTML = `<div class="error">Error loading man pages: ${error.message}</div>`;
            }
        }

        // Enhanced close man page with memory cleanup
        function closeManPage() {
            contentWrapper.style.display = 'none';
            currentState = 'search';
            currentManPage = null;
            searchInput.focus();
            window.location.hash = '';
            
            // Clean up DOM content to prevent memory leaks
            manPageContent.innerHTML = '';
            relatedCommands.style.display = 'none';
            relatedCommandsList.innerHTML = '';
            tldrSection.style.display = 'none';
            tldrContent.innerHTML = '';
            
            // Clear suggestions container
            while (suggestions.firstChild) {
                suggestions.removeChild(suggestions.firstChild);
            }
            
            // Trigger cleanup of cached cross-references
            performanceManager.caches.crossRefs.cleanup();
            
            console.log('Man page closed and cleaned up');
        }

        // Keyboard event handlers
        // Function to close all modals
        function closeAllModals() {
            // Close theme modal
            if (themeModal.style.display === 'block') {
                closeThemeModal();
            }
            
            // Close shortcuts help
            if (shortcutsHelp.style.display === 'block') {
                shortcutsHelp.style.display = 'none';
            }
            
            // Close command explainer
            if (commandExplainerModal.style.display === 'block') {
                closeCommandExplainer();
            }
            
            // Close side panel
            if (sidePanel.classList.contains('open')) {
                sidePanel.classList.remove('open');
            }
            
            // Hide overlay if no modals need it
            if (overlay.style.display === 'block') {
                overlay.style.display = 'none';
            }
        }

        document.addEventListener('keydown', (e) => {
            // Global keyboard shortcuts
            if (e.key === '/' && !e.ctrlKey && !e.metaKey && 
                e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                searchInput.focus();
                searchInput.select();
            }
            
            // Enhanced ESC key handling for all modals
            if (e.key === 'Escape') {
                let somethingWasClosed = false;
                
                // Check all modals in order of priority
                if (commandExplainerModal.style.display === 'block') {
                    closeCommandExplainer();
                    somethingWasClosed = true;
                } else if (themeModal.style.display === 'block') {
                    closeThemeModal();
                    somethingWasClosed = true;
                } else if (shortcutsHelp.style.display === 'block') {
                    shortcutsHelp.style.display = 'none';
                    overlay.style.display = 'none';
                    somethingWasClosed = true;
                } else if (sidePanel.classList.contains('open')) {
                    sidePanel.classList.remove('open');
                    somethingWasClosed = true;
                } else if (currentState === 'viewing') {
                    closeManPage();
                    somethingWasClosed = true;
                } else if (suggestions.style.display === 'block') {
                    suggestions.style.display = 'none';
                    somethingWasClosed = true;
                }
                
                // If nothing was closed but overlay is visible, hide it
                if (!somethingWasClosed && overlay.style.display === 'block') {
                    overlay.style.display = 'none';
                }
            }
            
            if (e.key === '?' && e.shiftKey && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                closeAllModals();
                populateShortcuts();
                shortcutsHelp.style.display = 'block';
                overlay.style.display = 'block';
            }
            
            if (e.key === 'h' && !e.ctrlKey && !e.metaKey && 
                e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                // Close other modals before toggling side panel
                if (themeModal.style.display === 'block' || 
                    shortcutsHelp.style.display === 'block' || 
                    commandExplainerModal.style.display === 'block') {
                    closeAllModals();
                }
                sidePanel.classList.toggle('open');
            }
            
            // Theme toggle shortcut
            if (e.key === 't' && !e.ctrlKey && !e.metaKey && 
                e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                closeAllModals();
                openThemeModal();
            }
            
            // Command explainer shortcut
            if (e.key === 'e' && !e.ctrlKey && !e.metaKey && 
                e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                closeAllModals();
                commandExplainerModal.style.display = 'block';
                overlay.style.display = 'block';
                commandInput.focus();
            }
            
            
            if (e.ctrlKey && e.key === 'b' && currentState === 'viewing') {
                e.preventDefault();
                toggleBookmark();
            }
        });

        // Search input keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            const suggestionElements = suggestions.querySelectorAll('.suggestion');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (suggestionElements.length > 0) {
                    updateSelectedSuggestion(
                        Math.min(selectedSuggestionIndex + 1, suggestionElements.length - 1)
                    );
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (suggestionElements.length > 0) {
                    updateSelectedSuggestion(Math.max(selectedSuggestionIndex - 1, 0));
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                let targetSuggestion = null;
                
                if (selectedSuggestionIndex >= 0 && suggestionElements[selectedSuggestionIndex]) {
                    targetSuggestion = suggestionElements[selectedSuggestionIndex];
                } else if (suggestionElements.length > 0) {
                    targetSuggestion = suggestionElements[0];
                }
                
                if (targetSuggestion) {
                    const command = targetSuggestion.dataset.command;
                    const section = targetSuggestion.dataset.section;
                    if (command && section) {
                        displayManPage(command, section);
                    }
                }
            }
        });

        // Set up event delegation for suggestions container
        suggestions.addEventListener('click', (e) => {
            // Find the clicked suggestion element (handles clicks on child elements)
            const suggestion = e.target.closest('.suggestion');
            if (suggestion) {
                const command = suggestion.dataset.command;
                const section = suggestion.dataset.section;
                if (command && section) {
                    displayManPage(command, section);
                }
            }
        });

        // Enhanced search input handling with smart debouncing and cancellation
        async function handleSmartSearch(query, options) {
            const { signal, requestId } = options;
            
            // Update UI state based on query
            if (query.length > 0 && currentState === 'initial') {
                currentState = 'search';
                container.classList.add('search-active');
            } else if (query.length === 0) {
                // Clear suggestions immediately when query is empty
                suggestions.style.display = 'none';
                loadingStateManager.hideLoading(suggestions);
                if (currentState === 'search') {
                    currentState = 'initial';
                    container.classList.remove('search-active');
                }
                return [];
            }
            
            // Show loading skeleton for longer queries
            if (query.length >= 2) {
                loadingStateManager.showSearchLoading(suggestions);
            }
            
            try {
                // Perform the search with cancellation support
                const results = await searchManPages(query, {
                    section: sectionSelect.value,
                    signal: signal,
                    requestId: requestId
                });
                
                // Only display results if search wasn't cancelled
                if (!signal.aborted && results) {
                    // Create results using batched DOM operations
                    await displaySearchResultsBatched(results);
                    
                    // Hide loading state
                    loadingStateManager.hideLoading(suggestions);
                    
                    return results;
                }
                
                return null;
            } catch (error) {
                // Hide loading on error
                loadingStateManager.hideLoading(suggestions);
                
                if (error.name === 'AbortError') {
                    // Search was cancelled - this is normal, don't show error
                    return null;
                } else {
                    console.error('Search error:', error);
                    suggestions.style.display = 'none';
                    showStatus('Search failed. Please try again.', 3000);
                    return [];
                }
            }
        }
        
        // Batched search results display with element recycling, async scheduling, and virtual scrolling for optimal performance
        async function displaySearchResultsBatched(results) {
            // Reset selected index for new results
            selectedSuggestionIndex = -1;
            
            if (results.length === 0) {
                // Disable virtual scrolling and hide suggestions
                virtualSearchManager.disable();
                await domBatchUpdater.updateElement(suggestions, {
                    style: { display: 'none' }
                });
                return;
            }
            
            // Choose rendering strategy based on result count
            if (results.length > 50) {
                // Very large result sets: use virtual scrolling for best performance
                const isVirtual = await virtualSearchManager.setSearchResults(results);
                
                if (isVirtual) {
                    // Virtual scrolling is handling the display
                    suggestions.style.display = 'block';
                    console.log(`Virtual scrolling enabled for ${results.length} results`);
                    return;
                }
                // If virtual scrolling failed, fall through to regular rendering
            }
            
            // Disable virtual scrolling for regular rendering
            virtualSearchManager.disable();
            
            // Clear suggestions with recycling (reclaim elements for reuse)
            await elementPool.clearSuggestionsWithRecycling(suggestions);
            
            // Use async DOM scheduling for medium-large result sets to prevent blocking
            let suggestionElements;
            if (results.length <= 20) {
                // Small result sets: process synchronously for immediate response
                suggestionElements = results.map((result, index) => {
                    return elementPool.createSuggestionElement(result, index);
                });
            } else {
                // Medium-large result sets: use async scheduling to prevent UI blocking
                suggestionElements = await asyncDOMScheduler.scheduleHeavyDOMWork(
                    results.map((result, index) => ({ result, index })),
                    ({ result, index }) => elementPool.createSuggestionElement(result, index),
                    'high' // High priority for search results
                );
            }
            
            // Batch append all elements at once + show container
            await domBatchUpdater.batch([
                {
                    type: 'write',
                    operation: () => {
                        // Append all suggestions in one operation
                        const fragment = document.createDocumentFragment();
                        suggestionElements.forEach(el => fragment.appendChild(el));
                        suggestions.appendChild(fragment);
                    }
                },
                {
                    type: 'write',
                    operation: () => {
                        // Show suggestions container
                        suggestions.style.display = 'block';
                    }
                }
            ]);
        }
        
        // Legacy function now uses element pool for backward compatibility
        function createSuggestionElement(result, index) {
            // Delegate to element pool for recycling benefits
            return elementPool.createSuggestionElement(result, index);
        }
        
        // Keep legacy function for backward compatibility (but mark as deprecated)
        function createSuggestionsFragment(results) {
            console.warn('createSuggestionsFragment is deprecated, use displaySearchResultsBatched instead');
            const fragment = document.createDocumentFragment();
            results.forEach((result, index) => {
                fragment.appendChild(createSuggestionElement(result, index));
            });
            selectedSuggestionIndex = -1;
            return fragment;
        }
        
        // Set up smart search with the new manager
        smartSearchManager.setupSearchInput(searchInput, handleSmartSearch);

        searchButton.addEventListener('click', async () => {
            const query = searchInput.value;
            
            if (query) {
                try {
                    // Cancel any existing search first
                    smartSearchManager.cancelCurrentSearch();
                    
                    // Perform immediate search (bypassing debouncing)
                    const results = await searchManPages(query, {
                        section: sectionSelect.value
                    });
                    
                    if (results && results.length > 0) {
                        displayManPage(results[0].command, results[0].section);
                    } else {
                        showStatus('No results found for your search.', 3000);
                    }
                    
                    // Update UI state
                    if (query.length > 0 && currentState === 'initial') {
                        currentState = 'search';
                        container.classList.add('search-active');
                    }
                } catch (error) {
                    console.error('Manual search error:', error);
                    showStatus('Search failed. Please try again.', 3000);
                }
            }
        });

        closeButton.addEventListener('click', closeManPage);


        // Bookmark button
        bookmarkBtn.addEventListener('click', toggleBookmark);
        
        // TLDR jump button
        tldrJumpBtn.addEventListener('click', () => {
            if (tldrSection && tldrSection.style.display !== 'none') {
                tldrSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                showStatus('TLDR section is not available for this command');
            }
        });

        // Side panel event listeners
        document.getElementById('historyFab').addEventListener('click', () => {
            // Close other modals before toggling side panel
            if (themeModal.style.display === 'block' || 
                shortcutsHelp.style.display === 'block' || 
                commandExplainerModal.style.display === 'block') {
                closeAllModals();
            }
            sidePanel.classList.toggle('open');
            updateHistoryPanel();
            updateBookmarksPanel();
        });
        
        document.getElementById('sidePanelClose').addEventListener('click', () => {
            sidePanel.classList.remove('open');
        });
        
        // Tab switching
        document.querySelectorAll('.side-panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                document.querySelectorAll('.side-panel-tab').forEach(t => {
                    t.classList.remove('active');
                });
                tab.classList.add('active');
                
                if (tabName === 'history') {
                    historyContent.style.display = 'block';
                    bookmarksContent.style.display = 'none';
                } else {
                    historyContent.style.display = 'none';
                    bookmarksContent.style.display = 'block';
                }
            });
        });

        // Shortcuts data structure
        const shortcutsData = [
            {
                category: 'navigation',
                title: 'Navigation',
                icon: '🧭',
                shortcuts: [
                    {
                        keys: ['↑', '↓'],
                        description: 'Navigate through search suggestions',
                        context: 'When search dropdown is open'
                    },
                    {
                        keys: ['Enter'],
                        description: 'Select highlighted suggestion or search result',
                        context: 'In search or suggestions'
                    },
                    {
                        keys: ['Esc'],
                        description: 'Close current view or modal',
                        context: 'Any modal or popup'
                    },
                    {
                        keys: ['Tab'],
                        description: 'Navigate between focusable elements',
                        context: 'Throughout the app'
                    }
                ]
            },
            {
                category: 'search',
                title: 'Search & Discovery',
                icon: '🔍',
                shortcuts: [
                    {
                        keys: ['/'],
                        description: 'Focus on search input',
                        context: 'From anywhere in the app',
                        highlight: true
                    },
                    {
                        keys: ['Ctrl', 'F'],
                        description: 'Search within current man page',
                        context: 'When viewing a man page',
                        modifier: true
                    },
                    {
                        keys: ['Ctrl', 'K'],
                        description: 'Quick command search',
                        context: 'Global',
                        modifier: true,
                        badge: 'pro'
                    }
                ]
            },
            {
                category: 'features',
                title: 'Features & Tools',
                icon: '🛠️',
                shortcuts: [
                    {
                        keys: ['E'],
                        description: 'Open command explainer',
                        context: 'Analyze complex commands',
                        badge: 'new'
                    },
                    {
                        keys: ['T'],
                        description: 'Toggle theme selector',
                        context: 'Change visual theme'
                    },
                    {
                        keys: ['?'],
                        description: 'Show keyboard shortcuts',
                        context: 'This help menu'
                    }
                ]
            },
            {
                category: 'productivity',
                title: 'Productivity',
                icon: '⚡',
                shortcuts: [
                    {
                        keys: ['Ctrl', 'B'],
                        description: 'Bookmark current man page',
                        context: 'When viewing a man page',
                        modifier: true
                    },
                    {
                        keys: ['H'],
                        description: 'Toggle history & bookmarks panel',
                        context: 'View recent pages'
                    },
                    {
                        keys: ['Ctrl', 'H'],
                        description: 'Clear history',
                        context: 'In history panel',
                        modifier: true
                    },
                    {
                        keys: ['Ctrl', 'Shift', 'D'],
                        description: 'Download current man page',
                        context: 'Export as PDF',
                        modifier: true,
                        badge: 'pro'
                    }
                ]
            }
        ];
        
        // Populate shortcuts modal with clean section layout
        function populateShortcuts() {
            const grid = document.getElementById('shortcutsGrid');
            grid.innerHTML = '';
            
            shortcutsData.forEach(section => {
                const sectionEl = document.createElement('div');
                sectionEl.className = 'shortcut-section';
                
                const headerEl = document.createElement('div');
                headerEl.className = 'shortcut-section-header';
                headerEl.innerHTML = `
                    <span class="shortcut-section-icon">${section.icon}</span>
                    <span class="shortcut-section-title">${section.title}</span>
                `;
                
                sectionEl.appendChild(headerEl);
                
                section.shortcuts.forEach(shortcut => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'shortcut-item';
                    
                    const descEl = document.createElement('div');
                    descEl.className = 'shortcut-description';
                    descEl.textContent = shortcut.description;
                    
                    const keysEl = document.createElement('div');
                    keysEl.className = 'shortcut-keys';
                    
                    shortcut.keys.forEach((key, index) => {
                        const kbd = document.createElement('kbd');
                        kbd.textContent = key;
                        keysEl.appendChild(kbd);
                        
                        if (index < shortcut.keys.length - 1) {
                            const plus = document.createElement('span');
                            plus.className = 'shortcut-plus';
                            plus.textContent = '+';
                            keysEl.appendChild(plus);
                        }
                    });
                    
                    itemEl.appendChild(descEl);
                    itemEl.appendChild(keysEl);
                    
                    sectionEl.appendChild(itemEl);
                });
                
                grid.appendChild(sectionEl);
            });
        }
        
        
        // Initialize shortcuts modal
        const shortcutsClose = document.getElementById('shortcutsClose');
        
        // Help button - simple show/hide
        document.getElementById('helpFab').addEventListener('click', () => {
            closeAllModals();
            populateShortcuts();
            shortcutsHelp.style.display = 'block';
            overlay.style.display = 'block';
        });
        
        // Close button
        shortcutsClose.addEventListener('click', () => {
            shortcutsHelp.style.display = 'none';
            overlay.style.display = 'none';
        });
        
        // Removed - consolidated with the overlay handler below

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                suggestions.style.display = 'none';
            }
        });

        // Theme toggle handling with enhanced metadata
        let currentThemeIndex = 0; // Ayu Mirage as default
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = themeToggle.querySelector('.theme-icon');
        
        // Theme name tooltip removed - using modal instead
        
        // Theme loading cache to avoid duplicate requests
        const themeCache = new Map();
        let currentLoadedTheme = null;
        
        // Search result cache to avoid redundant searches
        const searchResultCache = new Map();
        const SEARCH_CACHE_MAX_SIZE = 100; // Limit cache size to prevent memory issues
        const SEARCH_CACHE_TTL = 5 * 60 * 1000; // 5 minutes TTL
        
        // Clear search cache utility
        function clearSearchCache() {
            searchResultCache.clear();
            console.log('Search result cache cleared');
        }
        
        // Get cache statistics for debugging
        function getSearchCacheStats() {
            let totalAge = 0;
            let expiredCount = 0;
            const now = Date.now();
            
            for (const [key, value] of searchResultCache.entries()) {
                const age = now - value.timestamp;
                totalAge += age;
                if (age >= SEARCH_CACHE_TTL) {
                    expiredCount++;
                }
            }
            
            return {
                size: searchResultCache.size,
                avgAge: searchResultCache.size > 0 ? Math.round(totalAge / searchResultCache.size / 1000) : 0,
                expiredCount,
                maxSize: SEARCH_CACHE_MAX_SIZE,
                ttl: SEARCH_CACHE_TTL / 1000
            };
        }

        async function loadThemeCSS(theme) {
            if (!theme.file) {
                // Light theme - no CSS file needed
                return '';
            }

            // Check cache first
            if (themeCache.has(theme.file)) {
                return themeCache.get(theme.file);
            }

            try {
                const response = await fetch(theme.file);
                if (!response.ok) {
                    throw new Error(`Failed to load ${theme.file}: ${response.status}`);
                }
                
                const css = await response.text();
                themeCache.set(theme.file, css);
                return css;
            } catch (error) {
                console.error('Error loading theme CSS:', error);
                return '';
            }
        }

        // Enhanced theme application using ThemePerformanceManager
        async function applyTheme(index, options = {}) {
            try {
                // Set flag to prevent cleanup during theme switch
                isThemeSwitching = true;
                
                // Use the optimized theme performance manager
                await themePerformanceManager.switchTheme(index, options);
                
                // Update current theme tracking
                if (themes[index]) {
                    currentLoadedTheme = themes[index].file;
                    console.log(`Theme applied: ${themes[index].name}, body classes: ${document.body.className}`);
                }
            } catch (error) {
                console.error('Error applying theme:', error);
            } finally {
                // Always reset the flag
                setTimeout(() => {
                    isThemeSwitching = false;
                }, 100);
            }
        }
        
        // Legacy theme application (fallback)
        async function applyThemeLegacy(index) {
            const theme = themes[index];
            const themeStylesElement = document.getElementById('theme-styles');
            
            try {
                // Set flag to prevent cleanup during theme switch
                isThemeSwitching = true;
                
                // Load theme CSS dynamically
                const css = await loadThemeCSS(theme);
                
                // Replace theme styles
                themeStylesElement.textContent = css;
                currentLoadedTheme = theme.file;
                
                // Remove all theme classes from body
                themes.forEach(t => {
                    if (t.class) {
                        document.body.classList.remove(t.class);
                    }
                });
                
                // Add the new theme class to body
                if (theme.class) {
                    document.body.classList.add(theme.class);
                }
                
                // Update icon
                const themeIcon = document.querySelector('.theme-icon');
                if (themeIcon) {
                    themeIcon.textContent = theme.icon;
                }
                
                // Save preference
                localStorage.setItem('theme', theme.class || '');
                
                // Update theme CSS variables
                updateThemeVariables(theme.class || '');
                
                console.log(`Theme applied: ${theme.name}, body classes: ${document.body.className}`);
            } catch (error) {
                console.error('Error applying theme:', error);
            } finally {
                // Always reset the flag
                setTimeout(() => {
                    isThemeSwitching = false;
                }, 100);
            }
        }
        
        // Load saved theme or apply default after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Ensure side panel is closed on load
            const sidePanel = document.getElementById('sidePanel');
            if (sidePanel) {
                sidePanel.classList.remove('open');
                // Force visibility hidden just in case
                sidePanel.style.visibility = 'hidden';
                sidePanel.style.right = '-320px';
                // Reset after a moment to allow CSS transitions
                setTimeout(() => {
                    sidePanel.style.visibility = '';
                    sidePanel.style.right = '';
                }, 100);
            }
            
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                const themeIndex = themes.findIndex(t => t.class === savedTheme);
                if (themeIndex !== -1) {
                    currentThemeIndex = themeIndex;
                    applyTheme(currentThemeIndex);
                } else {
                    // Saved theme not found, apply default
                    applyTheme(currentThemeIndex);
                }
            } else {
                // No saved theme, apply default
                applyTheme(currentThemeIndex);
            }
            
            // Ensure theme variables are set initially
            const currentTheme = themes[currentThemeIndex];
            updateThemeVariables(currentTheme.class || '');
        });
        
        // Theme modal elements
        const themeModal = document.getElementById('themeModal');
        const themeModalClose = document.getElementById('themeModalClose');
        const themeOptions = document.getElementById('themeOptions');
        
        // Populate theme options
        // Theme filtering state
        let currentFilter = 'all';
        let searchQuery = '';
        
        function populateThemeOptions() {
            themeOptions.innerHTML = '';
            
            // Filter themes based on search and category
            const filteredThemes = themes.filter((theme, index) => {
                const matchesSearch = theme.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                                    theme.description.toLowerCase().includes(searchQuery.toLowerCase());
                const matchesCategory = currentFilter === 'all' || theme.categories.includes(currentFilter);
                return matchesSearch && matchesCategory;
            });
            
            filteredThemes.forEach((theme) => {
                const index = themes.indexOf(theme);
                const option = document.createElement('div');
                option.className = 'theme-option';
                if (index === currentThemeIndex) {
                    option.classList.add('active');
                }
                
                // Header with icon and info
                const header = document.createElement('div');
                header.className = 'theme-option-header';
                
                const icon = document.createElement('div');
                icon.className = 'theme-option-icon';
                icon.textContent = theme.icon;
                
                const info = document.createElement('div');
                info.className = 'theme-option-info';
                
                const name = document.createElement('div');
                name.className = 'theme-option-name';
                name.textContent = theme.name;
                
                const description = document.createElement('div');
                description.className = 'theme-option-description';
                description.textContent = theme.description;
                
                info.appendChild(name);
                info.appendChild(description);
                header.appendChild(icon);
                header.appendChild(info);
                
                // Live terminal preview
                const preview = document.createElement('div');
                preview.className = 'theme-preview-terminal';
                preview.innerHTML = createLiveTerminalPreview(theme);
                
                // Tags
                const tags = document.createElement('div');
                tags.className = 'theme-tags';
                theme.categories.forEach(cat => {
                    const tag = document.createElement('span');
                    tag.className = 'theme-tag';
                    tag.textContent = cat;
                    tags.appendChild(tag);
                });
                
                option.appendChild(header);
                option.appendChild(preview);
                option.appendChild(tags);
                
                option.addEventListener('click', () => {
                    currentThemeIndex = index;
                    applyTheme(currentThemeIndex);
                    populateThemeOptions(); // Update active state
                    closeThemeModal();
                });
                
                themeOptions.appendChild(option);
            });
            
            if (filteredThemes.length === 0) {
                const noResults = document.createElement('div');
                noResults.style.textAlign = 'center';
                noResults.style.padding = '40px';
                noResults.style.color = '#666';
                noResults.textContent = 'No themes match your search';
                themeOptions.appendChild(noResults);
            }
        }
        
        function applyThemeCardStyle(card, theme) {
            const cardStyles = {
                '': {
                    background: '#ffffff',
                    color: '#333333',
                    border: '2px solid #e0e0e0'
                },
                'dark-mode': {
                    background: '#1e1e1e',
                    color: '#e0e0e0',
                    border: '2px solid #444'
                },
                'nord': {
                    background: '#3b4252',
                    color: '#eceff4',
                    border: '2px solid #4c566a'
                },
                'one-dark': {
                    background: '#282c34',
                    color: '#abb2bf',
                    border: '2px solid #3e4451'
                },
                'tokyo-night': {
                    background: '#24283b',
                    color: '#c0caf5',
                    border: '2px solid #3b4261'
                },
                'gruvbox': {
                    background: '#3c3836',
                    color: '#ebdbb2',
                    border: '2px solid #665c54'
                },
                'solarized-dark': {
                    background: '#002b36',
                    color: '#93a1a1',
                    border: '2px solid #073642'
                },
                'dracula': {
                    background: '#282a36',
                    color: '#f8f8f2',
                    border: '2px solid #44475a'
                },
                'monokai': {
                    background: '#272822',
                    color: '#f8f8f2',
                    border: '2px solid #3e3d32'
                },
                'high-contrast': {
                    background: '#000000',
                    color: '#ffffff',
                    border: '2px solid #ffffff'
                },
                'neon-noir': {
                    background: '#1a1a24',
                    color: '#e4e4f0',
                    border: '2px solid #ea00d9'
                },
                'cyber-frost': {
                    background: '#ffffff',
                    color: '#1a1f36',
                    border: '2px solid #00d4ff'
                },
                'retro-wave': {
                    background: '#1a0b2e',
                    color: '#ffeef8',
                    border: '2px solid #f222ff'
                },
                'miami-sunrise': {
                    background: '#fff5f8',
                    color: '#2d1b69',
                    border: '2px solid #ff71ce'
                },
                'forest-dawn': {
                    background: '#fefef9',
                    color: '#2b3e1f',
                    border: '2px solid #90a955'
                },
                'ocean-depth': {
                    background: '#14273e',
                    color: '#e9f5f2',
                    border: '2px solid #0a9396'
                },
                'catppuccin-mocha': {
                    background: '#1e1e2e',
                    color: '#cdd6f4',
                    border: '2px solid #89b4fa'
                },
                'github-dark': {
                    background: '#0d1117',
                    color: '#f0f6fc',
                    border: '2px solid #30363d'
                },
                'hotdog-stand': {
                    background: '#ff0000',
                    color: '#ffff00',
                    border: '2px solid #ffff00'
                },
                'material-design': {
                    background: '#1c1b1f',
                    color: '#e6e1e5',
                    border: '2px solid #6750a4'
                },
                'rose-pine': {
                    background: '#191724',
                    color: '#e0def4',
                    border: '2px solid #c4a7e7'
                }
            };
            
            const style = cardStyles[theme.class] || cardStyles[''];
            Object.assign(card.style, style);
        }
        
        function createThemePreview(theme) {
            const previewHTML = {
                '': `
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #4285f4; font-weight: bold;">SECTION</div>
                        <div style="color: #333;">man <span style="color: #0066cc;">command</span></div>
                    </div>
                `,
                'dark-mode': `
                    <div style="background: #2d2d2d; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #4a9eff; font-weight: bold;">SECTION</div>
                        <div style="color: #d4d4d4;">man <span style="color: #79b8ff;">command</span></div>
                    </div>
                `,
                'nord': `
                    <div style="background: #2e3440; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #88c0d0; font-weight: bold;">SECTION</div>
                        <div style="color: #d8dee9;">man <span style="color: #81a1c1;">command</span></div>
                    </div>
                `,
                'one-dark': `
                    <div style="background: #21252b; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #61afef; font-weight: bold;">SECTION</div>
                        <div style="color: #abb2bf;">man <span style="color: #61afef;">command</span></div>
                    </div>
                `,
                'tokyo-night': `
                    <div style="background: #1f2335; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #7aa2f7; font-weight: bold;">SECTION</div>
                        <div style="color: #a9b1d6;">man <span style="color: #7dcfff;">command</span></div>
                    </div>
                `,
                'gruvbox': `
                    <div style="background: #282828; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #b8bb26; font-weight: bold;">SECTION</div>
                        <div style="color: #ebdbb2;">man <span style="color: #83a598;">command</span></div>
                    </div>
                `,
                'solarized-dark': `
                    <div style="background: #073642; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #268bd2; font-weight: bold;">SECTION</div>
                        <div style="color: #93a1a1;">man <span style="color: #2aa198;">command</span></div>
                    </div>
                `,
                'dracula': `
                    <div style="background: #44475a; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #bd93f9; font-weight: bold;">SECTION</div>
                        <div style="color: #f8f8f2;">man <span style="color: #8be9fd;">command</span></div>
                    </div>
                `,
                'monokai': `
                    <div style="background: #3e3d32; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #a6e22e; font-weight: bold;">SECTION</div>
                        <div style="color: #f8f8f2;">man <span style="color: #66d9ef;">command</span></div>
                    </div>
                `,
                'high-contrast': `
                    <div style="background: #000; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; border: 1px solid #fff;">
                        <div style="color: #ffff00; font-weight: bold;">SECTION</div>
                        <div style="color: #ffffff;">man <span style="color: #00ff00;">command</span></div>
                    </div>
                `,
                'neon-noir': `
                    <div style="background: #0a0a0f; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; box-shadow: 0 0 10px rgba(234, 0, 217, 0.3);">
                        <div style="color: #00ffff; font-weight: bold; text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);">SECTION</div>
                        <div style="color: #e4e4f0;">man <span style="color: #0abdc6; text-shadow: 0 0 3px rgba(10, 189, 198, 0.3);">command</span></div>
                    </div>
                `,
                'cyber-frost': `
                    <div style="background: #ffffff; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; border: 1px solid #00d4ff;">
                        <div style="color: #00bcd4; font-weight: bold; text-shadow: 0 0 5px rgba(0, 188, 212, 0.2);">SECTION</div>
                        <div style="color: #1a1f36;">man <span style="color: #4fc3f7; font-weight: 500;">command</span></div>
                    </div>
                `,
                'retro-wave': `
                    <div style="background: #0f0613; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; box-shadow: 0 0 15px rgba(255, 41, 117, 0.3);">
                        <div style="color: #01cdfe; font-weight: bold; text-shadow: 0 0 10px rgba(1, 205, 254, 0.6);">SECTION</div>
                        <div style="color: #ffeef8;">man <span style="color: #00bfff; text-shadow: 0 0 5px rgba(0, 191, 255, 0.5);">command</span></div>
                    </div>
                `,
                'miami-sunrise': `
                    <div style="background: #ffffff; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; border: 1px solid #ff71ce;">
                        <div style="color: #00d4cc; font-weight: bold;">SECTION</div>
                        <div style="color: #2d1b69;">man <span style="color: #01cdfe; font-weight: 500;">command</span></div>
                    </div>
                `,
                'forest-dawn': `
                    <div style="background: #f9f7f1; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #2d5016; font-weight: bold;">SECTION</div>
                        <div style="color: #2b3e1f;">man <span style="color: #4a6741; font-weight: 500;">command</span></div>
                    </div>
                `,
                'ocean-depth': `
                    <div style="background: #0a1628; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; box-shadow: 0 0 10px rgba(0, 212, 204, 0.2);">
                        <div style="color: #00d4cc; font-weight: bold; text-shadow: 0 0 10px rgba(0, 212, 204, 0.4);">SECTION</div>
                        <div style="color: #e9f5f2;">man <span style="color: #41b3ff; text-shadow: 0 0 5px rgba(65, 179, 255, 0.3);">command</span></div>
                    </div>
                `,
                'catppuccin-mocha': `
                    <div style="background: #181825; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #94e2d5; font-weight: bold;">SECTION</div>
                        <div style="color: #cdd6f4;">man <span style="color: #89b4fa;">command</span></div>
                    </div>
                `,
                'github-dark': `
                    <div style="background: #161b22; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; border: 1px solid #30363d;">
                        <div style="color: #2f81f7; font-weight: bold;">SECTION</div>
                        <div style="color: #f0f6fc;">man <span style="color: #2f81f7;">command</span></div>
                    </div>
                `,
                'hotdog-stand': `
                    <div style="background: #ff0000; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px; border: 2px solid #ffff00;">
                        <div style="color: #ffff00; font-weight: bold; text-shadow: 1px 1px 0px #000000;">SECTION</div>
                        <div style="color: #ffff00;">man <span style="color: #ffffff; font-weight: bold;">command</span></div>
                    </div>
                `,
                'material-design': `
                    <div style="background: #211f26; padding: 8px; border-radius: 8px; font-family: monospace; font-size: 11px;">
                        <div style="color: #6750a4; font-weight: bold;">SECTION</div>
                        <div style="color: #e6e1e5;">man <span style="color: #2196f3;">command</span></div>
                    </div>
                `,
                'rose-pine': `
                    <div style="background: #1f1d2e; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 11px;">
                        <div style="color: #f6c177; font-weight: bold;">SECTION</div>
                        <div style="color: #e0def4;">man <span style="color: #9ccfd8;">command</span></div>
                    </div>
                `
            };
            
            return previewHTML[theme.class] || previewHTML[''];
        }
        
        function createLiveTerminalPreview(theme) {
            const colors = theme.colors;
            
            return `
                <div class="preview-terminal-header" style="background: ${colors.bg}; border-bottom: 1px solid ${adjustBrightness(colors.bg, 20)};">
                    <div class="preview-terminal-dots">
                        <span class="preview-dot" style="background: #ff5f56;"></span>
                        <span class="preview-dot" style="background: #ffbd2e;"></span>
                        <span class="preview-dot" style="background: #27c93f;"></span>
                    </div>
                    <span style="color: ${colors.fg}; margin-left: auto; font-size: 10px; opacity: 0.7;">bash</span>
                </div>
                <div class="preview-terminal-content" style="background: ${colors.bg}; color: ${colors.fg};">
                    <div class="preview-prompt">
                        <span style="color: ${colors.accent};">$</span> <span class="preview-command" style="color: ${colors.accent};">man</span> <span style="color: ${adjustBrightness(colors.accent, -20)};">ls</span>
                    </div>
                    <div class="preview-section" style="color: ${colors.accent};">NAME</div>
                    <div style="margin-left: 16px;">ls - list directory contents</div>
                    
                    <div class="preview-section" style="color: ${colors.accent}; margin-top: 8px;">SYNOPSIS</div>
                    <div style="margin-left: 16px;">
                        <span style="font-weight: 600;">ls</span> [<span style="color: ${adjustBrightness(colors.accent, -20)};">OPTION</span>]... [<span style="color: ${adjustBrightness(colors.accent, -20)};">FILE</span>]...
                    </div>
                    
                    <div class="preview-section" style="color: ${colors.accent}; margin-top: 8px;">OPTIONS</div>
                    <div class="preview-option">
                        <span style="color: ${adjustBrightness(colors.accent, -10)}; font-weight: 600;">-l</span> 
                        <span class="preview-description">use a long listing format</span>
                    </div>
                    <div class="preview-option">
                        <span style="color: ${adjustBrightness(colors.accent, -10)}; font-weight: 600;">-a</span> 
                        <span class="preview-description">do not ignore hidden files</span>
                    </div>
                </div>
            `;
        }
        
        // Helper function to adjust color brightness
        function adjustBrightness(color, percent) {
            // Convert hex to RGB
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }
        
        function openThemeModal() {
            closeAllModals();
            populateThemeOptions();
            themeModal.style.display = 'block';
            overlay.style.display = 'block';
        }
        
        function closeThemeModal() {
            themeModal.style.display = 'none';
            overlay.style.display = 'none';
        }
        
        themeToggle.addEventListener('click', openThemeModal);
        
        themeModalClose.addEventListener('click', closeThemeModal);
        
        // Theme search and filter functionality
        const themeSearchInput = document.getElementById('themeSearchInput');
        const themeFilterBtns = document.querySelectorAll('.theme-filter-btn');
        
        // Handle theme search
        if (themeSearchInput) {
            themeSearchInput.addEventListener('input', (e) => {
                searchQuery = e.target.value.trim();
                populateThemeOptions();
            });
        }
        
        // Handle theme category filters
        themeFilterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active state
                themeFilterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update filter and repopulate
                currentFilter = btn.dataset.category;
                populateThemeOptions();
            });
        });

        // Command Explainer functionality
        const explainerFab = document.getElementById('explainerFab');
        const commandExplainerModal = document.getElementById('commandExplainerModal');
        const commandExplainerClose = document.getElementById('commandExplainerClose');
        const commandInput = document.getElementById('commandInput');
        const commandBreakdown = document.getElementById('commandBreakdown');
        const commandExplanations = document.getElementById('commandExplanations');

        // Use generated command options database if available, fallback to basic set
        if (typeof window.commandOptions === 'undefined') {
            window.commandOptions = {
            'ls': {
                description: 'List directory contents',
                options: {
                    '-a': { long: '--all', description: 'do not ignore entries starting with .', argType: 'none' },
                    '-l': { description: 'use a long listing format', argType: 'none' },
                    '-h': { long: '--human-readable', description: 'with -l, print sizes in human readable format', argType: 'none' },
                    '-r': { long: '--reverse', description: 'reverse order while sorting', argType: 'none' },
                    '-t': { description: 'sort by modification time, newest first', argType: 'none' },
                    '-S': { description: 'sort by file size, largest first', argType: 'none' },
                    '-R': { long: '--recursive', description: 'list subdirectories recursively', argType: 'none' },
                    '-d': { long: '--directory', description: 'list directories themselves, not their contents', argType: 'none' },
                    '--color': { description: 'colorize the output', argType: 'optional', argValues: ['always', 'auto', 'never'] }
                }
            },
            'grep': {
                description: 'Search for patterns in files',
                options: {
                    '-i': { long: '--ignore-case', description: 'ignore case distinctions', argType: 'none' },
                    '-v': { long: '--invert-match', description: 'select non-matching lines', argType: 'none' },
                    '-n': { long: '--line-number', description: 'print line number with output lines', argType: 'none' },
                    '-c': { long: '--count', description: 'print only a count of matching lines', argType: 'none' },
                    '-r': { long: '--recursive', description: 'recursively search directories', argType: 'none' },
                    '-l': { long: '--files-with-matches', description: 'print only names of files containing matches', argType: 'none' },
                    '-H': { long: '--with-filename', description: 'print the filename for each match', argType: 'none' },
                    '-E': { long: '--extended-regexp', description: 'interpret pattern as extended regular expression', argType: 'none' },
                    '-e': { long: '--regexp', description: 'use pattern for matching', argType: 'required' },
                    '-f': { long: '--file', description: 'obtain patterns from file', argType: 'required' },
                    '-A': { long: '--after-context', description: 'print NUM lines of trailing context', argType: 'required' },
                    '-B': { long: '--before-context', description: 'print NUM lines of leading context', argType: 'required' },
                    '--color': { description: 'highlight matching text', argType: 'optional', argValues: ['always', 'auto', 'never'] }
                }
            },
            'cat': {
                description: 'Concatenate and display files',
                options: {
                    '-n': { long: '--number', description: 'number all output lines', argType: 'none' },
                    '-b': { long: '--number-nonblank', description: 'number non-empty output lines', argType: 'none' },
                    '-s': { long: '--squeeze-blank', description: 'suppress repeated empty output lines', argType: 'none' },
                    '-T': { long: '--show-tabs', description: 'display TAB characters as ^I', argType: 'none' },
                    '-E': { long: '--show-ends', description: 'display $ at end of each line', argType: 'none' },
                    '-v': { long: '--show-nonprinting', description: 'use ^ and M- notation, except for LFD and TAB', argType: 'none' },
                    '-A': { long: '--show-all', description: 'equivalent to -vET', argType: 'none' }
                }
            },
            'find': {
                description: 'Search for files and directories',
                options: {
                    '-name': { description: 'search by filename pattern', argType: 'required' },
                    '-type': { description: 'search by file type', argType: 'required', argValues: ['f', 'd', 'l', 'b', 'c', 'p', 's'] },
                    '-size': { description: 'search by file size', argType: 'required' },
                    '-mtime': { description: 'modified time (days)', argType: 'required' },
                    '-atime': { description: 'access time (days)', argType: 'required' },
                    '-ctime': { description: 'status change time (days)', argType: 'required' },
                    '-perm': { description: 'search by file permissions', argType: 'required' },
                    '-user': { description: 'search by file owner', argType: 'required' },
                    '-group': { description: 'search by group', argType: 'required' },
                    '-maxdepth': { description: 'maximum directory depth', argType: 'required' },
                    '-mindepth': { description: 'minimum directory depth', argType: 'required' },
                    '-exec': { description: 'execute command on found files', argType: 'required' },
                    '-print': { description: 'print found files (default)', argType: 'none' },
                    '-delete': { description: 'delete found files', argType: 'none' },
                    '-empty': { description: 'find empty files and directories', argType: 'none' }
                }
            },
            'tar': {
                description: 'Archive files',
                options: {
                    '-c': { long: '--create', description: 'create a new archive', argType: 'none' },
                    '-x': { long: '--extract', description: 'extract files from an archive', argType: 'none' },
                    '-t': { long: '--list', description: 'list the contents of an archive', argType: 'none' },
                    '-v': { long: '--verbose', description: 'verbose output', argType: 'none' },
                    '-f': { long: '--file', description: 'use archive file', argType: 'required' },
                    '-z': { long: '--gzip', description: 'compress/decompress with gzip', argType: 'none' },
                    '-j': { long: '--bzip2', description: 'compress/decompress with bzip2', argType: 'none' },
                    '-J': { long: '--xz', description: 'compress/decompress with xz', argType: 'none' },
                    '-C': { long: '--directory', description: 'change to directory', argType: 'required' },
                    '-p': { long: '--preserve-permissions', description: 'preserve file permissions', argType: 'none' },
                    '--exclude': { description: 'exclude files matching pattern', argType: 'required' }
                }
            }
            };
        }

        // Fallback function for hardcoded command options
        if (typeof window.hardcodedCommandOptions === 'undefined') {
            window.hardcodedCommandOptions = function() {
                return window.commandOptions || {};
            };
        }

        // Improved Command Parser for complex Linux commands
        class CommandParser {
            constructor() {
                this.tokens = [];
                this.commandOptions = {};
            }
            
            // Update options when they're loaded
            updateOptions() {
                this.commandOptions = window.commandOptions || {};
            }

            parse(input) {
                this.tokens = [];
                
                // First, tokenize the input properly
                const rawTokens = this.advancedTokenize(input);
                
                // Then, parse the tokens into semantic units
                this.parseTokens(rawTokens);
                
                return this.tokens;
            }

            // Advanced tokenizer that handles complex shell syntax
            advancedTokenize(input) {
                const tokens = [];
                let current = '';
                let i = 0;
                
                while (i < input.length) {
                    const char = input[i];
                    const nextChar = input[i + 1];
                    const prevChar = input[i - 1];
                    
                    // Handle quotes
                    if ((char === '"' || char === "'") && prevChar !== '\\') {
                        const quote = char;
                        let quoted = '';
                        i++; // Skip opening quote
                        
                        while (i < input.length && input[i] !== quote) {
                            if (input[i] === '\\' && input[i + 1] === quote) {
                                quoted += quote;
                                i += 2;
                            } else {
                                quoted += input[i];
                                i++;
                            }
                        }
                        
                        if (current) {
                            tokens.push({ type: 'word', value: current });
                            current = '';
                        }
                        tokens.push({ type: 'quoted', value: quoted, quote: quote });
                        i++; // Skip closing quote
                        continue;
                    }
                    
                    // Handle shell variables, command substitution, and arithmetic expansion
                    if (char === '$') {
                        // ANSI-C quoting $'...'
                        if (nextChar === "'") {
                            if (current) {
                                tokens.push({ type: 'word', value: current });
                                current = '';
                            }
                            
                            let ansiString = "$'";
                            i += 2; // Skip $'
                            
                            while (i < input.length && input[i] !== "'") {
                                if (input[i] === '\\' && i + 1 < input.length) {
                                    ansiString += input[i] + input[i + 1];
                                    i += 2;
                                } else {
                                    ansiString += input[i];
                                    i++;
                                }
                            }
                            
                            if (i < input.length && input[i] === "'") {
                                ansiString += "'";
                                i++;
                            }
                            
                            tokens.push({ type: 'ansi-c-quote', value: ansiString });
                            continue;
                        }
                        // Command substitution $() or arithmetic expansion $(())
                        else if (nextChar === '(') {
                            if (current) {
                                tokens.push({ type: 'word', value: current });
                                current = '';
                            }
                            
                            // Check if it's arithmetic expansion $(())
                            if (i + 2 < input.length && input[i + 2] === '(') {
                                let arithmetic = '';
                                i += 3; // Skip $((
                                let depth = 2;
                                
                                while (i < input.length && depth > 0) {
                                    if (input[i] === '(') depth++;
                                    else if (input[i] === ')') depth--;
                                    
                                    if (depth > 1 || (depth === 1 && input[i] !== ')')) {
                                        arithmetic += input[i];
                                    }
                                    i++;
                                }
                                
                                tokens.push({ type: 'arithmetic', value: arithmetic });
                                continue;
                            }
                            // Regular command substitution $()
                            else {
                                let depth = 1;
                                let substitution = '';
                                i += 2; // Skip $(
                                
                                while (i < input.length && depth > 0) {
                                    if (input[i] === '(') depth++;
                                    else if (input[i] === ')') depth--;
                                    
                                    if (depth > 0) substitution += input[i];
                                    i++;
                                }
                                
                                tokens.push({ type: 'substitution', value: substitution });
                                continue;
                            }
                        }
                        // Shell variable ${VAR} or $VAR
                        else {
                            if (current) {
                                tokens.push({ type: 'word', value: current });
                                current = '';
                            }
                            
                            let varName = '$';
                            i++; // Skip $
                            
                            // Handle ${VAR} syntax
                            if (i < input.length && input[i] === '{') {
                                varName += '{';
                                i++; // Skip {
                                while (i < input.length && input[i] !== '}') {
                                    varName += input[i];
                                    i++;
                                }
                                if (i < input.length && input[i] === '}') {
                                    varName += '}';
                                    i++;
                                }
                            }
                            // Handle $VAR syntax
                            else {
                                // Special single-character variables
                                if (i < input.length && '?$!#*@-0123456789'.includes(input[i])) {
                                    varName += input[i];
                                    i++;
                                }
                                // Regular variable names
                                else {
                                    while (i < input.length && input[i].match(/[A-Za-z0-9_]/)) {
                                        varName += input[i];
                                        i++;
                                    }
                                }
                            }
                            
                            tokens.push({ type: 'variable', value: varName });
                            continue;
                        }
                    }
                    
                    // Handle backticks (old-style command substitution)
                    if (char === '`') {
                        if (current) {
                            tokens.push({ type: 'word', value: current });
                            current = '';
                        }
                        
                        let substitution = '';
                        i++; // Skip opening backtick
                        
                        while (i < input.length && input[i] !== '`') {
                            substitution += input[i];
                            i++;
                        }
                        
                        tokens.push({ type: 'substitution', value: substitution });
                        i++; // Skip closing backtick
                        continue;
                    }
                    
                    // Handle process substitution
                    if ((char === '<' || char === '>') && nextChar === '(') {
                        if (current) {
                            tokens.push({ type: 'word', value: current });
                            current = '';
                        }
                        
                        const direction = char; // < or >
                        let depth = 1;
                        let substitution = '';
                        i += 2; // Skip <( or >(
                        
                        while (i < input.length && depth > 0) {
                            if (input[i] === '(') depth++;
                            else if (input[i] === ')') depth--;
                            
                            if (depth > 0) substitution += input[i];
                            i++;
                        }
                        
                        tokens.push({ 
                            type: 'process-substitution', 
                            value: substitution,
                            direction: direction
                        });
                        continue;
                    }
                    
                    // Handle operators (order matters - longer operators first)
                    const operators = [
                        { op: '<<<', type: 'here-string' },
                        { op: '<<-', type: 'here-doc-indent' },
                        { op: '<<', type: 'here-doc' },
                        { op: '<>', type: 'redirect-read-write' },
                        { op: '&&', type: 'and' },
                        { op: '||', type: 'or' },
                        { op: ';;', type: 'case-end' },
                        { op: ';', type: 'semicolon' },
                        { op: '|&', type: 'pipe-both' },
                        { op: '|', type: 'pipe' },
                        { op: '&>>', type: 'redirect-both-append' },
                        { op: '&>', type: 'redirect-both' },
                        { op: '>|', type: 'redirect-force' },
                        { op: '>>', type: 'redirect-append' },
                        { op: '>', type: 'redirect-out' },
                        { op: '2>>', type: 'redirect-err-append' },
                        { op: '2>&1', type: 'redirect-err-to-out' },
                        { op: '1>&2', type: 'redirect-out-to-err' },
                        { op: '2>', type: 'redirect-err' },
                        { op: '<', type: 'redirect-in' },
                        { op: '&', type: 'background' }
                    ];
                    
                    let foundOperator = false;
                    for (const { op, type } of operators) {
                        if (input.substr(i, op.length) === op) {
                            if (current) {
                                tokens.push({ type: 'word', value: current });
                                current = '';
                            }
                            tokens.push({ type: type, value: op });
                            i += op.length;
                            foundOperator = true;
                            break;
                        }
                    }
                    
                    if (foundOperator) continue;
                    
                    // Handle whitespace
                    if (char === ' ' || char === '\t' || char === '\n') {
                        if (current) {
                            tokens.push({ type: 'word', value: current });
                            current = '';
                        }
                        i++;
                        continue;
                    }
                    
                    // Handle special single characters
                    if ('(){}[]'.includes(char)) {
                        if (current) {
                            tokens.push({ type: 'word', value: current });
                            current = '';
                        }
                        tokens.push({ type: 'special', value: char });
                        i++;
                        continue;
                    }
                    
                    // Handle tilde expansion
                    if (char === '~' && (i === 0 || input[i - 1] === ' ' || input[i - 1] === ':')) {
                        if (current) {
                            tokens.push({ type: 'word', value: current });
                            current = '';
                        }
                        
                        let tildeExpr = '~';
                        i++;
                        
                        // Check for special tilde expansions
                        if (i < input.length && (input[i] === '+' || input[i] === '-')) {
                            tildeExpr += input[i];
                            i++;
                        }
                        // Check for username expansion
                        else {
                            while (i < input.length && input[i].match(/[A-Za-z0-9_-]/) && input[i] !== '/') {
                                tildeExpr += input[i];
                                i++;
                            }
                        }
                        
                        tokens.push({ type: 'tilde', value: tildeExpr });
                        continue;
                    }
                    
                    // Regular character
                    current += char;
                    i++;
                }
                
                // Don't forget the last token
                if (current) {
                    tokens.push({ type: 'word', value: current });
                }
                
                return tokens;
            }

            // Parse tokens into semantic units
            parseTokens(rawTokens) {
                let i = 0;
                let currentCommand = null;
                let expectingCommand = true;
                let lastOperator = null;
                
                while (i < rawTokens.length) {
                    const token = rawTokens[i];
                    
                    // Skip special tokens for now
                    if (token.type === 'special') {
                        this.tokens.push({
                            value: token.value,
                            type: 'special',
                            description: this.getSpecialDescription(token.value)
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle operators
                    if (this.isOperator(token.type)) {
                        this.tokens.push({
                            value: token.value,
                            type: token.type,
                            description: this.getOperatorDescription(token.type)
                        });
                        
                        // After operators, we usually expect a new command
                        if (['pipe', 'pipe-both', 'and', 'or', 'semicolon', 'background'].includes(token.type)) {
                            expectingCommand = true;
                            currentCommand = null;
                        }
                        
                        lastOperator = token.type;
                        i++;
                        continue;
                    }
                    
                    // Handle command substitution
                    if (token.type === 'substitution') {
                        this.tokens.push({
                            value: `$(${token.value})`,
                            type: 'substitution',
                            description: 'Command substitution - execute command and use its output'
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle arithmetic expansion
                    if (token.type === 'arithmetic') {
                        this.tokens.push({
                            value: `$((${token.value}))`,
                            type: 'arithmetic',
                            description: 'Arithmetic expansion - evaluate mathematical expression'
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle ANSI-C quoting
                    if (token.type === 'ansi-c-quote') {
                        this.tokens.push({
                            value: token.value,
                            type: 'ansi-c-quote',
                            description: 'ANSI-C quoted string - allows escape sequences'
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle tilde expansion
                    if (token.type === 'tilde') {
                        let description = 'Home directory';
                        if (token.value === '~') {
                            description = 'Current user home directory';
                        } else if (token.value === '~+') {
                            description = 'Current working directory ($PWD)';
                        } else if (token.value === '~-') {
                            description = 'Previous working directory ($OLDPWD)';
                        } else if (token.value.startsWith('~')) {
                            const username = token.value.substring(1);
                            description = `Home directory of user '${username}'`;
                        }
                        this.tokens.push({
                            value: token.value,
                            type: 'tilde',
                            description: description
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle process substitution
                    if (token.type === 'process-substitution') {
                        const desc = token.direction === '<' ? 
                            'Process substitution - use command output as input file' :
                            'Process substitution - use command input as output file';
                        this.tokens.push({
                            value: `${token.direction}(${token.value})`,
                            type: 'process-substitution',
                            description: desc
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle quoted strings
                    if (token.type === 'quoted') {
                        this.tokens.push({
                            value: `${token.quote}${token.value}${token.quote}`,
                            type: 'argument',
                            description: token.quote === '"' ? 
                                'Double-quoted string (variables expanded)' : 
                                'Single-quoted string (literal)'
                        });
                        i++;
                        continue;
                    }
                    
                    // Handle words (commands, options, arguments)
                    if (token.type === 'word') {
                        const word = token.value;
                        
                        // Check if it's a variable assignment
                        if (word.includes('=') && !word.startsWith('-') && expectingCommand) {
                            const [varName, varValue] = word.split('=', 2);
                            if (varName.match(/^[A-Za-z_][A-Za-z0-9_]*$/)) {
                                this.tokens.push({
                                    value: word,
                                    type: 'variable-assignment',
                                    description: `Set environment variable ${varName}`
                                });
                                i++;
                                continue;
                            }
                        }
                        
                        // Check if it's a shell keyword
                        if (this.isShellKeyword(word)) {
                            this.tokens.push({
                                value: word,
                                type: 'keyword',
                                description: this.getShellKeywordDescription(word)
                            });
                            
                            // Some keywords expect commands after them
                            if (['do', 'then', 'else', 'elif'].includes(word)) {
                                expectingCommand = true;
                                currentCommand = null;
                            }
                        }
                        // Check if we're expecting a command
                        else if (expectingCommand && !word.startsWith('-')) {
                            currentCommand = word;
                            const commandInfo = this.commandOptions[word];
                            
                            this.tokens.push({
                                value: word,
                                type: 'command',
                                description: commandInfo?.description || this.getCommandDescription(word)
                            });
                            
                            // Check if this is a command wrapper
                            if (this.isCommandWrapper(word)) {
                                expectingCommand = true; // Keep expecting another command
                            } else {
                                expectingCommand = false;
                            }
                            
                            // Check for subcommands
                            if (this.hasSubcommands(word) && i + 1 < rawTokens.length) {
                                const nextToken = rawTokens[i + 1];
                                if (nextToken.type === 'word' && !nextToken.value.startsWith('-')) {
                                    i++;
                                    const subcommand = nextToken.value;
                                    
                                    this.tokens.push({
                                        value: subcommand,
                                        type: 'subcommand',
                                        description: this.getSubcommandDescription(word, subcommand)
                                    });
                                    
                                    // Update current command context for options
                                    currentCommand = `${word}_${subcommand}`;
                                    
                                    // Check if this subcommand expects another command
                                    if (this.expectsCommandAfterSubcommand(word, subcommand)) {
                                        expectingCommand = true;
                                    }
                                }
                            }
                        }
                        // Check if it's an option
                        else if (word.startsWith('-') && currentCommand) {
                            const optionInfo = this.parseOption(word, currentCommand);
                            
                            // If it's a grouped option like -latr, break it out
                            if (optionInfo.isGrouped && optionInfo.individualOptions) {
                                // Add each individual option as a separate token
                                optionInfo.individualOptions.forEach((opt, index) => {
                                    const individualOptionInfo = this.findOption(currentCommand, opt);
                                    this.tokens.push({
                                        value: opt,
                                        type: 'option',
                                        description: individualOptionInfo?.description || `Unknown option ${opt}`,
                                        command: currentCommand,
                                        fromGrouped: word
                                    });
                                });
                            } else {
                                // Single option or long option
                                optionInfo.command = currentCommand;
                                this.tokens.push(optionInfo);
                            }
                            
                            // Check if this option expects an argument
                            if (optionInfo.expectsArg && i + 1 < rawTokens.length) {
                                const nextToken = rawTokens[i + 1];
                                if (nextToken.type === 'word' && !nextToken.value.startsWith('-')) {
                                    i++;
                                    this.tokens.push({
                                        value: nextToken.value,
                                        type: 'argument',
                                        description: `Argument for ${word}`
                                    });
                                }
                            }
                        }
                        // Otherwise it's an argument
                        else {
                            // Special handling for filenames after redirections
                            if (lastOperator && lastOperator.includes('redirect')) {
                                this.tokens.push({
                                    value: word,
                                    type: 'filename',
                                    description: this.getRedirectionTargetDescription(lastOperator)
                                });
                                lastOperator = null;
                            } else {
                                this.tokens.push({
                                    value: word,
                                    type: 'argument',
                                    description: this.getArgumentDescription(word, currentCommand)
                                });
                            }
                        }
                    }
                    
                    // Handle shell variables
                    if (token.type === 'variable') {
                        this.tokens.push({
                            value: token.value,
                            type: 'variable',
                            description: this.getVariableDescription(token.value)
                        });
                        i++;
                        continue;
                    }
                    
                    i++;
                }
            }

            // List of command wrappers that take other commands as arguments
            isCommandWrapper(cmd) {
                const wrappers = [
                    // System utilities
                    'sudo', 'su', 'doas', 'runas', 'pkexec',
                    // Time and resource utilities
                    'time', 'timeout', 'nice', 'nohup', 'ionice', 'chrt', 'taskset', 'numactl',
                    // Debugging and tracing
                    'strace', 'ltrace', 'gdb', 'valgrind', 'perf', 'dtrace', 'dtruss', 'ktrace',
                    // Network tools
                    'proxychains', 'proxychains4', 'torify', 'torsocks', 'socksify', 'tsocks',
                    // Container and virtualization
                    'docker', 'podman', 'kubectl', 'rkt', 'lxc', 'systemd-nspawn', 'firejail',
                    // Shell utilities
                    'xargs', 'watch', 'script', 'env', 'exec', 'command', 'builtin',
                    // Process management
                    'start-stop-daemon', 'daemon', 'daemonize', 'run-parts',
                    // Other wrappers
                    'caffeinate', 'unbuffer', 'chronic', 'setsid', 'fakeroot', 'fakechroot',
                    // Development tools
                    'bundle', 'yarn', 'npx', 'pipenv', 'poetry',
                    // Screen/tmux utilities
                    'screen', 'tmux'
                ];
                return wrappers.includes(cmd);
            }

            // Check if a command expects another command after specific subcommands
            expectsCommandAfterSubcommand(cmd, subcmd) {
                const patterns = {
                    'docker': ['run', 'exec'],
                    'podman': ['run', 'exec'],
                    'kubectl': ['exec', 'run'],
                    'ssh': true, // SSH always expects a command after the host
                    'git': ['bisect']
                };
                
                if (patterns[cmd] === true) return true;
                return patterns[cmd]?.includes(subcmd) || false;
            }

            // Helper methods
            isOperator(type) {
                return [
                    'pipe', 'pipe-both', 'and', 'or', 'semicolon',
                    'redirect-out', 'redirect-append', 'redirect-in',
                    'redirect-err', 'redirect-err-append', 'redirect-err-to-out',
                    'redirect-both', 'redirect-both-append', 'background',
                    'here-doc', 'here-doc-indent', 'here-string', 'case-end',
                    'redirect-read-write', 'redirect-force', 'redirect-out-to-err'
                ].includes(type);
            }

            getOperatorDescription(type) {
                const descriptions = {
                    'pipe': 'Pipe - send output to next command',
                    'pipe-both': 'Pipe both stdout and stderr',
                    'and': 'AND - run next command only if previous succeeds',
                    'or': 'OR - run next command only if previous fails',
                    'semicolon': 'Command separator - run commands sequentially',
                    'redirect-out': 'Redirect output to file (overwrite)',
                    'redirect-append': 'Redirect output to file (append)',
                    'redirect-in': 'Read input from file',
                    'redirect-err': 'Redirect error output to file',
                    'redirect-err-append': 'Redirect error output to file (append)',
                    'redirect-err-to-out': 'Redirect stderr to stdout',
                    'redirect-both': 'Redirect both stdout and stderr to file',
                    'redirect-both-append': 'Redirect both stdout and stderr (append)',
                    'background': 'Run command in background',
                    'here-doc': 'Here document - multi-line input',
                    'here-doc-indent': 'Here document - ignore leading tabs',
                    'here-string': 'Here string - single line input',
                    'case-end': 'End of case pattern',
                    'redirect-read-write': 'Open file for reading and writing',
                    'redirect-force': 'Force overwrite (ignore noclobber)',
                    'redirect-out-to-err': 'Redirect stdout to stderr'
                };
                return descriptions[type] || 'Unknown operator';
            }

            getSpecialDescription(char) {
                const descriptions = {
                    '(': 'Start subshell or command group',
                    ')': 'End subshell or command group',
                    '{': 'Start command block',
                    '}': 'End command block',
                    '[': 'Start test expression or array index',
                    ']': 'End test expression or array index'
                };
                return descriptions[char] || 'Special character';
            }

            getRedirectionTargetDescription(redirectType) {
                if (redirectType.includes('err')) return 'Error output file';
                if (redirectType.includes('in')) return 'Input file';
                return 'Output file';
            }

            parseOption(option, command) {
                // Handle long options with values
                if (option.startsWith('--') && option.includes('=')) {
                    const [optName, optValue] = option.split('=', 2);
                    const optionInfo = this.findOption(command, optName);
                    
                    return {
                        value: option,
                        type: 'option',
                        description: optionInfo?.description || `Long option with value: ${optValue}`,
                        expectsArg: false
                    };
                }
                
                // Handle long options
                if (option.startsWith('--')) {
                    const optionInfo = this.findOption(command, option);
                    return {
                        value: option,
                        type: 'option',
                        description: optionInfo?.description || 'Unknown long option',
                        expectsArg: optionInfo?.argType === 'required'
                    };
                }
                
                // Handle short options (can be combined)
                if (option.startsWith('-') && option.length > 1) {
                    const options = option.substring(1).split('');
                    const descriptions = [];
                    let expectsArg = false;
                    
                    for (let i = 0; i < options.length; i++) {
                        const opt = '-' + options[i];
                        const optionInfo = this.findOption(command, opt);
                        
                        if (optionInfo) {
                            descriptions.push(`${opt}: ${optionInfo.description}`);
                            // Only the last option in a group can take an argument
                            if (i === options.length - 1 && optionInfo.argType === 'required') {
                                expectsArg = true;
                            }
                        } else {
                            descriptions.push(`${opt}: Unknown option`);
                        }
                    }
                    
                    return {
                        value: option,
                        type: 'option',
                        description: 'Options combined: ' + descriptions.join(', '),
                        expectsArg: expectsArg,
                        isGrouped: true,
                        individualOptions: options.map(opt => '-' + opt)
                    };
                }
                
                return {
                    value: option,
                    type: 'option',
                    description: 'Unknown option',
                    expectsArg: false
                };
            }

            findOption(command, option) {
                const cmdOptions = this.commandOptions[command]?.options || {};
                
                // Direct lookup
                if (cmdOptions[option]) {
                    return cmdOptions[option];
                }
                
                // Check if it's a long option matching a short option
                for (const [key, value] of Object.entries(cmdOptions)) {
                    if (value.long === option) {
                        return value;
                    }
                }
                
                // Hardcoded fallback for common grep options that might be missing
                if (command === 'grep') {
                    const grepFallbacks = {
                        '-C': { description: 'Print NUM lines of context around matches', argType: 'required' },
                        '-A': { description: 'Print NUM lines of trailing context after matches', argType: 'required' },
                        '-B': { description: 'Print NUM lines of leading context before matches', argType: 'required' },
                        '-c': { description: 'Count matching lines instead of printing them', argType: 'none' },
                        '-i': { description: 'Ignore case distinctions', argType: 'none' },
                        '-v': { description: 'Invert match - select non-matching lines', argType: 'none' },
                        '-n': { description: 'Show line numbers', argType: 'none' },
                        '-l': { description: 'Print only file names containing matches', argType: 'none' },
                        '-L': { description: 'Print only file names not containing matches', argType: 'none' },
                        '-r': { description: 'Recursively search directories', argType: 'none' },
                        '-R': { description: 'Recursively search directories (follow symlinks)', argType: 'none' },
                        '-w': { description: 'Match whole words only', argType: 'none' },
                        '-x': { description: 'Match whole lines only', argType: 'none' },
                        '-m': { description: 'Stop after NUM matches', argType: 'required' },
                        '-o': { description: 'Print only matched parts of lines', argType: 'none' },
                        '-q': { description: 'Quiet mode - suppress output', argType: 'none' },
                        '-s': { description: 'Suppress error messages', argType: 'none' },
                        '-H': { description: 'Print filename for each match', argType: 'none' },
                        '-h': { description: 'Suppress filename prefix', argType: 'none' },
                        '-e': { description: 'Specify pattern to match', argType: 'required' },
                        '-f': { description: 'Read patterns from file', argType: 'required' },
                        '-E': { description: 'Use extended regular expressions', argType: 'none' },
                        '-F': { description: 'Treat patterns as fixed strings', argType: 'none' },
                        '-G': { description: 'Use basic regular expressions', argType: 'none' },
                        '-P': { description: 'Use Perl regular expressions', argType: 'none' }
                    };
                    
                    if (grepFallbacks[option]) {
                        return grepFallbacks[option];
                    }
                }
                
                return null;
            }
            
            hasSubcommands(command) {
                const subcommandCommands = [
                    'git', 'docker', 'npm', 'yarn', 'cargo', 'pip', 'gem',
                    'kubectl', 'aws', 'az', 'gcloud', 'apt', 'apt-get', 
                    'systemctl', 'journalctl', 'ip', 'nmcli', 'snap', 'flatpak',
                    'brew', 'sudo', 'virsh', 'podman', 'buildah', 'skopeo'
                ];
                return subcommandCommands.includes(command);
            }

            getCommandDescription(command) {
                // Common commands not in database
                const commonDescriptions = {
                    'cd': 'Change directory',
                    'pwd': 'Print working directory',
                    'echo': 'Display a line of text',
                    'export': 'Set environment variable',
                    'source': 'Execute commands from file in current shell',
                    'alias': 'Create command alias',
                    'unalias': 'Remove command alias',
                    'history': 'Display command history',
                    'which': 'Locate a command',
                    'type': 'Display command type',
                    'eval': 'Execute arguments as shell command',
                    'exec': 'Replace shell with command',
                    'exit': 'Exit the shell',
                    'test': 'Evaluate conditional expression',
                    '[': 'Evaluate conditional expression (synonym for test)'
                };
                
                return commonDescriptions[command] || 'Unknown command';
            }
            
            isShellKeyword(word) {
                const keywords = [
                    'if', 'then', 'else', 'elif', 'fi',
                    'for', 'in', 'do', 'done',
                    'while', 'until',
                    'case', 'esac',
                    'function',
                    'select',
                    'time',
                    'coproc'
                ];
                return keywords.includes(word);
            }
            
            getShellKeywordDescription(keyword) {
                const descriptions = {
                    'if': 'Conditional statement start',
                    'then': 'Execute commands if condition is true',
                    'else': 'Execute commands if condition is false',
                    'elif': 'Else-if condition',
                    'fi': 'End of if statement',
                    'for': 'Loop over items',
                    'in': 'Specify items to iterate over',
                    'do': 'Start loop body',
                    'done': 'End loop body',
                    'while': 'Loop while condition is true',
                    'until': 'Loop until condition is true',
                    'case': 'Pattern matching statement',
                    'esac': 'End of case statement',
                    'function': 'Define shell function',
                    'select': 'Generate menu',
                    'time': 'Time command execution',
                    'coproc': 'Create coprocess'
                };
                return descriptions[keyword] || 'Shell keyword';
            }
            
            getSubcommandDescription(command, subcommand) {
                // Extended subcommand descriptions
                const descriptions = {
                    'git': {
                        'add': 'Add file contents to the index',
                        'commit': 'Record changes to the repository',
                        'push': 'Update remote refs along with associated objects',
                        'pull': 'Fetch from and integrate with another repository',
                        'clone': 'Clone a repository into a new directory',
                        'checkout': 'Switch branches or restore working tree files',
                        'branch': 'List, create, or delete branches',
                        'merge': 'Join two or more development histories together',
                        'status': 'Show the working tree status',
                        'log': 'Show commit logs',
                        'diff': 'Show changes between commits',
                        'reset': 'Reset current HEAD to the specified state',
                        'stash': 'Stash changes in a dirty working directory',
                        'fetch': 'Download objects and refs from another repository',
                        'rebase': 'Reapply commits on top of another base tip',
                        'tag': 'Create, list, delete or verify tags',
                        'remote': 'Manage set of tracked repositories',
                        'config': 'Get and set repository or global options',
                        'init': 'Create an empty Git repository',
                        'mv': 'Move or rename a file or directory',
                        'rm': 'Remove files from the working tree and index'
                    },
                    'docker': {
                        'run': 'Run a command in a new container',
                        'build': 'Build an image from a Dockerfile',
                        'pull': 'Pull an image or repository from a registry',
                        'push': 'Push an image or repository to a registry',
                        'ps': 'List containers',
                        'images': 'List images',
                        'exec': 'Run a command in a running container',
                        'stop': 'Stop one or more running containers',
                        'start': 'Start one or more stopped containers',
                        'restart': 'Restart one or more containers',
                        'rm': 'Remove one or more containers',
                        'rmi': 'Remove one or more images',
                        'logs': 'Fetch the logs of a container',
                        'inspect': 'Return low-level information',
                        'network': 'Manage networks',
                        'volume': 'Manage volumes',
                        'compose': 'Docker Compose operations',
                        'cp': 'Copy files between containers and filesystem',
                        'commit': 'Create a new image from container changes',
                        'tag': 'Create a tag for an image',
                        'save': 'Save images to a tar archive',
                        'load': 'Load images from a tar archive'
                    },
                    'kubectl': {
                        'get': 'Display one or many resources',
                        'describe': 'Show details of a specific resource',
                        'create': 'Create a resource from a file or stdin',
                        'apply': 'Apply a configuration to a resource',
                        'delete': 'Delete resources',
                        'edit': 'Edit a resource on the server',
                        'scale': 'Set a new size for a deployment',
                        'expose': 'Expose a resource as a new service',
                        'run': 'Run a particular image on the cluster',
                        'set': 'Set specific features on objects',
                        'rollout': 'Manage the rollout of a resource',
                        'logs': 'Print the logs for a container',
                        'exec': 'Execute a command in a container',
                        'port-forward': 'Forward ports to a pod',
                        'proxy': 'Run a proxy to the Kubernetes API server',
                        'version': 'Print client and server version',
                        'config': 'Modify kubeconfig files',
                        'cluster-info': 'Display cluster info'
                    },
                    'systemctl': {
                        'start': 'Start (activate) one or more units',
                        'stop': 'Stop (deactivate) one or more units',
                        'restart': 'Restart one or more units',
                        'reload': 'Reload one or more units',
                        'status': 'Show runtime status of units',
                        'enable': 'Enable one or more unit files',
                        'disable': 'Disable one or more unit files',
                        'is-active': 'Check if units are active',
                        'is-enabled': 'Check if unit files are enabled',
                        'list-units': 'List loaded units',
                        'list-unit-files': 'List installed unit files',
                        'daemon-reload': 'Reload systemd manager configuration',
                        'mask': 'Mask one or more units',
                        'unmask': 'Unmask one or more units',
                        'show': 'Show properties of units',
                        'cat': 'Show unit file contents',
                        'edit': 'Edit unit files',
                        'kill': 'Send signal to processes of a unit'
                    },
                    'npm': {
                        'install': 'Install a package',
                        'uninstall': 'Remove a package',
                        'update': 'Update a package',
                        'run': 'Run a script defined in package.json',
                        'start': 'Start a package',
                        'test': 'Test a package',
                        'init': 'Create a package.json file',
                        'publish': 'Publish a package',
                        'list': 'List installed packages',
                        'audit': 'Run a security audit',
                        'ci': 'Install a project with a clean slate'
                    },
                    'apt': {
                        'install': 'Install new packages',
                        'remove': 'Remove packages',
                        'update': 'Update package list',
                        'upgrade': 'Upgrade all upgradable packages',
                        'search': 'Search for packages',
                        'show': 'Show package details',
                        'list': 'List packages based on package names',
                        'autoremove': 'Remove automatically all unused packages',
                        'purge': 'Remove packages and config files'
                    }
                };
                
                return descriptions[command]?.[subcommand] || 
                       `${command} ${subcommand} - ${subcommand} operation`;
            }

            getArgumentDescription(arg, command) {
                // Handle placeholders
                if (arg.match(/^<[^>]+>$/)) {
                    const placeholder = arg.slice(1, -1).toLowerCase();
                    const placeholderDescriptions = {
                        'file': 'Path to a file',
                        'filename': 'Name of a file',
                        'dir': 'Path to a directory',
                        'directory': 'Path to a directory',
                        'path': 'File or directory path',
                        'url': 'URL address',
                        'host': 'Hostname or IP address',
                        'port': 'Port number',
                        'user': 'Username',
                        'command': 'Command to execute',
                        'string': 'Text string',
                        'pattern': 'Search pattern',
                        'number': 'Numeric value',
                        'count': 'Number of items',
                        'size': 'Size specification',
                        'time': 'Time value',
                        'date': 'Date value',
                        'email': 'Email address',
                        'key': 'Key name',
                        'value': 'Value to set',
                        'name': 'Name identifier',
                        'id': 'Unique identifier',
                        'pid': 'Process ID',
                        'signal': 'Signal name or number'
                    };
                    return placeholderDescriptions[placeholder] || `Placeholder for ${placeholder}`;
                }
                
                // Handle optional parameters [optional]
                if (arg.match(/^\[.+\]$/)) {
                    return 'Optional parameter';
                }
                
                // Handle choice parameters {option1|option2|...}
                if (arg.match(/^\{[^}]+\}$/)) {
                    const choices = arg.slice(1, -1);
                    return `Choose one: ${choices}`;
                }
                
                // Handle brace expansion patterns
                if (arg.match(/\{[^}]*,[^}]*\}/) || arg.match(/\{\d+\.\.\d+\}/)) {
                    if (arg.match(/\{\d+\.\.\d+\}/)) {
                        return 'Brace expansion - numeric range';
                    }
                    return 'Brace expansion - multiple values';
                }
                
                // Handle remote SSH commands (user@host)
                if (arg.match(/^[a-zA-Z0-9\-\_\.]+@[a-zA-Z0-9\-\_\.]+$/)) {
                    return 'SSH connection: user@hostname';
                }
                
                // Pattern-based descriptions
                if (arg.match(/^[~\/].*$/)) return 'File or directory path';
                if (arg.match(/^\.\/.*$/)) return 'Relative path';
                if (arg.match(/^\.\.\/.*$/)) return 'Parent directory path';
                
                // Enhanced glob pattern descriptions
                if (arg.match(/^\*\.(.*?)$/)) {
                    const ext = arg.match(/^\*\.(.*?)$/)[1];
                    return `Glob pattern - all .${ext} files`;
                }
                if (arg === '*') return 'Glob pattern - all files';
                if (arg === '**') return 'Glob pattern - all files recursively';
                if (arg.match(/^\*.*\*$/)) return 'Glob pattern - files matching pattern';
                if (arg.match(/\?/)) return 'Glob pattern - ? matches single character';
                if (arg.match(/\[.*\]/)) return 'Glob pattern - character class';
                
                if (arg.match(/^[0-9]+$/)) return 'Numeric value';
                if (arg.match(/^[A-Z_]+=/)) return 'Environment variable assignment';
                if (arg.match(/^-?[0-9]+$/)) return 'Integer value';
                if (arg.match(/^[0-9]+\.[0-9]+$/)) return 'Decimal value';
                if (arg.match(/^0x[0-9a-fA-F]+$/)) return 'Hexadecimal value';
                if (arg.match(/^0[0-7]+$/)) return 'Octal value';
                
                if (arg.match(/^https?:\/\//)) return 'HTTP/HTTPS URL';
                if (arg.match(/^ftp:\/\//)) return 'FTP URL';
                if (arg.match(/^ssh:\/\//)) return 'SSH URL';
                if (arg.match(/^git(@|:\/\/)/)) return 'Git repository URL';
                if (arg.match(/^[a-f0-9]{40}$/)) return 'Git commit SHA';
                if (arg.match(/^[a-f0-9]{7,8}$/)) return 'Short Git commit SHA';
                if (arg === '-') return 'Read from stdin / previous directory';
                if (arg === '--') return 'End of options marker';
                if (arg === '.') return 'Current directory';
                if (arg === '..') return 'Parent directory';
                
                // Command-specific patterns
                if (command === 'chmod' && arg.match(/^[0-7]{3,4}$/)) {
                    return 'Octal permission mode';
                }
                if (command === 'chmod' && arg.match(/^[ugoa]*([-+=]([rwxXst]*|[ugo]))+$/)) {
                    return 'Symbolic permission mode';
                }
                if (command === 'chown' && arg.includes(':')) {
                    return 'User:group specification';
                }
                if ((command === 'find' || command === 'grep') && arg.match(/^[+-]\d+$/)) {
                    return 'Numeric comparison value';
                }
                if (command === 'kill' && arg.match(/^-[0-9]+$/)) {
                    return 'Process ID with signal';
                }
                if (command === 'tar' && arg.match(/\.(tar|gz|bz2|xz|zip)$/)) {
                    return 'Archive file';
                }
                
                // Regex patterns for grep, sed, awk, perl
                if (['grep', 'egrep', 'fgrep', 'rg', 'ag'].includes(command) && !arg.startsWith('-')) {
                    if (arg.match(/[\\.^$*+?()[\]{}|]/)) {
                        return 'Regular expression pattern';
                    }
                    return 'Search pattern';
                }
                
                if (command === 'sed' && !arg.startsWith('-')) {
                    if (arg.match(/^s[/#|].+[/#|].*/)) {
                        return 'Substitution expression';
                    }
                    if (arg.match(/^[0-9]+[dpcai]/)) {
                        return 'Line address with command';
                    }
                    return 'Sed expression';
                }
                
                if (command === 'awk' && !arg.startsWith('-')) {
                    if (arg.includes('{') && arg.includes('}')) {
                        return 'AWK program';
                    }
                    return 'AWK pattern/program';
                }
                
                if (command === 'find') {
                    if (arg === '-name' || arg === '-iname') return 'Find by filename';
                    if (arg === '-type') return 'Find by file type';
                    if (arg === '-size') return 'Find by file size';
                    if (arg === '-mtime' || arg === '-atime' || arg === '-ctime') return 'Find by time';
                    if (arg === '-perm') return 'Find by permissions';
                    if (arg === '-user' || arg === '-group') return 'Find by ownership';
                    if (arg === '-exec' || arg === '-execdir') return 'Execute command on results';
                }
                
                // File type recognition by extension
                const fileExtensions = {
                    // Archives
                    'tar': 'TAR archive',
                    'gz': 'Gzip compressed file',
                    'zip': 'ZIP archive',
                    'bz2': 'Bzip2 compressed file',
                    'xz': 'XZ compressed file',
                    '7z': '7-Zip archive',
                    'rar': 'RAR archive',
                    // Code files
                    'js': 'JavaScript file',
                    'py': 'Python script',
                    'sh': 'Shell script',
                    'bash': 'Bash script',
                    'rb': 'Ruby script',
                    'go': 'Go source file',
                    'rs': 'Rust source file',
                    'java': 'Java source file',
                    'c': 'C source file',
                    'cpp': 'C++ source file',
                    'h': 'C/C++ header file',
                    // Data files
                    'json': 'JSON data file',
                    'xml': 'XML file',
                    'yaml': 'YAML configuration',
                    'yml': 'YAML configuration',
                    'csv': 'CSV data file',
                    'sql': 'SQL script',
                    // Documents
                    'txt': 'Text file',
                    'md': 'Markdown document',
                    'pdf': 'PDF document',
                    'doc': 'Word document',
                    'docx': 'Word document',
                    // Config files
                    'conf': 'Configuration file',
                    'cfg': 'Configuration file',
                    'ini': 'INI configuration',
                    'env': 'Environment file',
                    // Web files
                    'html': 'HTML file',
                    'css': 'CSS stylesheet',
                    'php': 'PHP script',
                    // Images
                    'jpg': 'JPEG image',
                    'jpeg': 'JPEG image',
                    'png': 'PNG image',
                    'gif': 'GIF image',
                    'svg': 'SVG vector image',
                    // System files
                    'log': 'Log file',
                    'pid': 'Process ID file',
                    'sock': 'Socket file',
                    'lock': 'Lock file'
                };
                
                const extMatch = arg.match(/\.([a-zA-Z0-9]+)$/);
                if (extMatch && fileExtensions[extMatch[1].toLowerCase()]) {
                    return fileExtensions[extMatch[1].toLowerCase()];
                }
                
                return 'Argument';
            }

            findOptionByLongName(command, longName) {
                const options = this.commandOptions[command]?.options;
                if (!options) return null;
                
                for (const [key, value] of Object.entries(options)) {
                    if (value.long === longName) {
                        return value;
                    }
                }
                return null;
            }

            getOptionInfo(command, option) {
                const options = this.commandOptions[command]?.options;
                if (!options) return null;
                
                // Direct lookup
                if (options[option]) {
                    return options[option];
                }
                
                // Check if it's a long option
                for (const [key, value] of Object.entries(options)) {
                    if (value.long === option) {
                        return value;
                    }
                }
                
                return null;
            }
            
            getVariableDescription(varName) {
                const commonVariables = {
                    // Environment variables
                    '$HOME': 'Home directory of the current user',
                    '${HOME}': 'Home directory of the current user',
                    '$USER': 'Current username',
                    '${USER}': 'Current username',
                    '$PATH': 'Executable search path',
                    '${PATH}': 'Executable search path',
                    '$PWD': 'Current working directory',
                    '${PWD}': 'Current working directory',
                    '$OLDPWD': 'Previous working directory',
                    '${OLDPWD}': 'Previous working directory',
                    '$SHELL': 'Current shell path',
                    '${SHELL}': 'Current shell path',
                    '$TERM': 'Terminal type',
                    '${TERM}': 'Terminal type',
                    '$EDITOR': 'Default text editor',
                    '${EDITOR}': 'Default text editor',
                    '$LANG': 'System language/locale',
                    '${LANG}': 'System language/locale',
                    '$HOSTNAME': 'System hostname',
                    '${HOSTNAME}': 'System hostname',
                    '$LOGNAME': 'Login name',
                    '${LOGNAME}': 'Login name',
                    
                    // Special shell variables
                    '$?': 'Exit status of last command',
                    '${?}': 'Exit status of last command',
                    '$$': 'Process ID of current shell',
                    '${$}': 'Process ID of current shell',
                    '$!': 'Process ID of last background command',
                    '${!}': 'Process ID of last background command',
                    '$0': 'Name of the shell or script',
                    '${0}': 'Name of the shell or script',
                    '$#': 'Number of positional parameters',
                    '${#}': 'Number of positional parameters',
                    '$@': 'All positional parameters (as separate words)',
                    '${@}': 'All positional parameters (as separate words)',
                    '$*': 'All positional parameters (as single word)',
                    '${*}': 'All positional parameters (as single word)',
                    '$-': 'Current shell options',
                    '${-}': 'Current shell options',
                    
                    // Positional parameters
                    '$1': 'First positional parameter',
                    '${1}': 'First positional parameter',
                    '$2': 'Second positional parameter',
                    '${2}': 'Second positional parameter',
                    '$3': 'Third positional parameter',
                    '${3}': 'Third positional parameter',
                    '$4': 'Fourth positional parameter',
                    '${4}': 'Fourth positional parameter',
                    '$5': 'Fifth positional parameter',
                    '${5}': 'Fifth positional parameter',
                    '$6': 'Sixth positional parameter',
                    '${6}': 'Sixth positional parameter',
                    '$7': 'Seventh positional parameter',
                    '${7}': 'Seventh positional parameter',
                    '$8': 'Eighth positional parameter',
                    '${8}': 'Eighth positional parameter',
                    '$9': 'Ninth positional parameter',
                    '${9}': 'Ninth positional parameter'
                };
                
                // Check for exact match
                if (commonVariables[varName]) {
                    return commonVariables[varName];
                }
                
                // Check for array syntax ${var[@]} or ${#var}
                if (varName.match(/^\$\{[A-Za-z_][A-Za-z0-9_]*\[@\]\}$/)) {
                    return 'Array variable (all elements)';
                }
                if (varName.match(/^\$\{#[A-Za-z_][A-Za-z0-9_]*\}$/)) {
                    return 'Length of variable';
                }
                if (varName.match(/^\$\{[A-Za-z_][A-Za-z0-9_]*\[[0-9]+\]\}$/)) {
                    return 'Array element';
                }
                
                // Check for parameter expansion ${var:-default} etc
                if (varName.match(/^\$\{[A-Za-z_][A-Za-z0-9_]*[:#%\/\-\+\?=].+\}$/)) {
                    return 'Parameter expansion';
                }
                
                // Generic environment variable
                if (varName.match(/^\$[A-Za-z_][A-Za-z0-9_]*$/)) {
                    const name = varName.substring(1);
                    // Common patterns
                    if (name.endsWith('_HOME') || name.endsWith('_ROOT')) {
                        return 'Installation directory variable';
                    }
                    if (name.endsWith('_PATH')) {
                        return 'Path variable';
                    }
                    if (name.endsWith('_DIR') || name.endsWith('_DIRECTORY')) {
                        return 'Directory variable';
                    }
                    if (name.endsWith('_FILE') || name.endsWith('_FILENAME')) {
                        return 'File path variable';
                    }
                    if (name.endsWith('_URL') || name.endsWith('_URI')) {
                        return 'URL variable';
                    }
                    if (name.endsWith('_PORT')) {
                        return 'Port number variable';
                    }
                    if (name.endsWith('_HOST') || name.endsWith('_HOSTNAME')) {
                        return 'Hostname variable';
                    }
                    if (name.endsWith('_USER') || name.endsWith('_USERNAME')) {
                        return 'Username variable';
                    }
                    if (name.endsWith('_PASS') || name.endsWith('_PASSWORD')) {
                        return 'Password variable (careful!)';
                    }
                    if (name.endsWith('_KEY') || name.endsWith('_TOKEN')) {
                        return 'Authentication key/token (careful!)';
                    }
                    return 'Environment variable';
                }
                
                // Fallback
                return 'Shell variable';
            }
        }

        const commandParser = new CommandParser();

        // Display parsed command
        function displayParsedCommand(tokens) {
            // Clean up existing tooltips
            const existingTokens = commandBreakdown.querySelectorAll('.command-token');
            existingTokens.forEach(token => {
                if (token.tooltipElement && token.tooltipElement.parentNode) {
                    token.tooltipElement.parentNode.removeChild(token.tooltipElement);
                }
            });
            
            commandBreakdown.innerHTML = '';
            
            if (tokens.length === 0) {
                commandBreakdown.innerHTML = '<div class="no-explanation">Enter a command above to see its breakdown</div>';
                return;
            }
            
            tokens.forEach((token, index) => {
                const tokenEl = document.createElement('div');
                tokenEl.className = `command-token ${token.type}`;
                
                // Create text span for the token value
                const tokenText = document.createElement('span');
                tokenText.textContent = token.value;
                tokenEl.appendChild(tokenText);
                
                // Create tooltip only if there's a description
                if (token.description) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'token-tooltip';
                    tooltip.textContent = token.description;
                    tooltip.style.position = 'fixed';
                    tooltip.style.display = 'none';
                    document.body.appendChild(tooltip); // Append to body to avoid clipping
                    
                    // Position tooltip on hover
                    let tooltipTimeout;
                    
                    tokenEl.addEventListener('mouseenter', function() {
                        // Clear any existing timeout
                        clearTimeout(tooltipTimeout);
                        
                        // Show tooltip with delay
                        tooltipTimeout = setTimeout(() => {
                            tooltip.style.display = 'block';
                            const tokenRect = tokenEl.getBoundingClientRect();
                            const viewportHeight = window.innerHeight;
                            const viewportWidth = window.innerWidth;
                            
                            // Force layout to get accurate dimensions
                            tooltip.style.opacity = '0';
                            tooltip.style.visibility = 'visible';
                            
                            // Force a reflow to ensure dimensions are calculated
                            void tooltip.offsetHeight;
                            
                            // Get tooltip dimensions after display
                            const tooltipRect = tooltip.getBoundingClientRect();
                            const tooltipHeight = Math.max(tooltipRect.height, 40); // Min height with padding
                            const tooltipWidth = Math.max(tooltipRect.width, 150); // Min width
                            
                            // Calculate position
                            let left = tokenRect.left + (tokenRect.width / 2);
                            let top = tokenRect.top;
                            
                            // Calculate safe positioning
                            const minDistanceFromEdge = 10; // Minimum pixels from viewport edge
                            const preferredGap = 10; // Gap between token and tooltip
                            
                            // Calculate available space
                            const spaceAbove = tokenRect.top - minDistanceFromEdge;
                            const spaceBelow = viewportHeight - tokenRect.bottom - minDistanceFromEdge;
                            const spaceLeft = tokenRect.left - minDistanceFromEdge;
                            const spaceRight = viewportWidth - tokenRect.right - minDistanceFromEdge;
                            
                            let positionBelow = false;
                            let positionSide = false;
                            
                            // First, try positioning above or below
                            // Calculate the actual position if placed above
                            const topIfAbove = tokenRect.top - tooltipHeight - preferredGap;
                            
                            if (topIfAbove >= minDistanceFromEdge) {
                                // Position above - we have enough space
                                top = topIfAbove;
                            } else if (spaceBelow >= tooltipHeight + preferredGap) {
                                // Position below
                                positionBelow = true;
                                top = tokenRect.bottom + preferredGap;
                            } else {
                                // Not enough space vertically, try positioning to the side
                                positionSide = true;
                                
                                // Center tooltip vertically with token
                                top = tokenRect.top + (tokenRect.height / 2) - (tooltipHeight / 2);
                                // Ensure it stays within viewport
                                top = Math.max(minDistanceFromEdge, Math.min(viewportHeight - tooltipHeight - minDistanceFromEdge, top));
                                
                                // Position to the right if space, otherwise left
                                if (spaceRight >= tooltipWidth + preferredGap) {
                                    left = tokenRect.right + preferredGap + (tooltipWidth / 2);
                                } else if (spaceLeft >= tooltipWidth + preferredGap) {
                                    left = tokenRect.left - preferredGap - (tooltipWidth / 2);
                                } else {
                                    // Last resort: center in viewport
                                    positionSide = false;
                                    left = viewportWidth / 2;
                                    top = viewportHeight / 2 - tooltipHeight / 2;
                                    tooltip.classList.add('tooltip-centered');
                                }
                            }
                            
                            // Ensure horizontal position keeps tooltip in viewport
                            const halfWidth = tooltipWidth / 2;
                            left = Math.max(halfWidth + 15, left); // Left boundary
                            left = Math.min(viewportWidth - halfWidth - 15, left); // Right boundary
                            
                            // Apply positioning
                            tooltip.style.left = left + 'px';
                            tooltip.style.top = top + 'px';
                            
                            // Update classes and transform based on position
                            tooltip.classList.remove('tooltip-below', 'tooltip-left', 'tooltip-right', 'tooltip-centered');
                            
                            if (positionSide) {
                                // Side positioning
                                tooltip.style.transform = 'translateX(-50%)';
                                if (left > tokenRect.left + tokenRect.width) {
                                    tooltip.classList.add('tooltip-right');
                                } else {
                                    tooltip.classList.add('tooltip-left');
                                }
                            } else {
                                // Top/bottom positioning
                                tooltip.style.transform = 'translateX(-50%)';
                                if (positionBelow) {
                                    tooltip.classList.add('tooltip-below');
                                }
                            }
                            
                            // Show tooltip
                            tooltip.style.opacity = '1';
                            tooltip.style.visibility = 'visible';
                        }, 100);
                    });
                    
                    tokenEl.addEventListener('mouseleave', function() {
                        clearTimeout(tooltipTimeout);
                        tooltip.style.display = 'none';
                        tooltip.style.opacity = '0';
                        tooltip.style.visibility = 'hidden';
                    });
                    
                    // Store reference for cleanup
                    tokenEl.tooltipElement = tooltip;
                }
                
                commandBreakdown.appendChild(tokenEl);
            });
        }

        // Display command explanations
        async function displayExplanations(tokens) {
            commandExplanations.innerHTML = '';
            
            // Get all unique commands
            const commandTokens = tokens.filter(t => t.type === 'command');
            if (commandTokens.length === 0) return;
            
            // Ensure command options are loaded
            await ensureOptions();
            const commandOptions = window.commandOptions || hardcodedCommandOptions();
            
            // Command overview section
            const overviewSection = document.createElement('div');
            overviewSection.className = 'explanation-section';
            let overviewHtml = '<div class="explanation-header">Command Overview</div><div class="explanation-content">';
            
            // Command flow visualization removed - not needed
            
            overviewHtml += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';
            
            commandTokens.forEach((commandToken, index) => {
                const commandName = commandToken.value;
                const commandInfo = commandOptions[commandName];
                const colorClass = `command-${index % 5}`;  // Cycle through 5 colors
                
                if (!commandInfo) {
                    overviewHtml += `
                        <button class="command-link-button ${colorClass}" onclick="searchInput.value='${commandName}'; searchInput.dispatchEvent(new Event('input')); commandExplainerModal.style.display='none'; overlay.style.display='none';" title="Search for ${commandName}">
                            ${commandName}
                        </button>
                    `;
                } else {
                    overviewHtml += `
                        <button class="command-link-button ${colorClass}" onclick="displayManPage('${commandName}', '1'); commandExplainerModal.style.display='none'; overlay.style.display='none';" title="View ${commandName} man page">
                            ${commandName}
                        </button>
                    `;
                }
            });
            
            overviewHtml += '</div>';
            
            overviewHtml += '</div>';
            overviewSection.innerHTML = overviewHtml;
            commandExplanations.appendChild(overviewSection);

            // Used options
            const usedOptions = tokens.filter(t => t.type === 'option');
            if (usedOptions.length > 0) {
                const usedSection = document.createElement('div');
                usedSection.className = 'explanation-section';
                
                // Group options by command
                const optionsByCommand = {};
                usedOptions.forEach(optionToken => {
                    const cmd = optionToken.command || commandName;
                    if (!optionsByCommand[cmd]) {
                        optionsByCommand[cmd] = [];
                    }
                    optionsByCommand[cmd].push(optionToken);
                });
                
                let optionsHtml = '<div class="explanation-header">Options Used</div><div class="explanation-content">';
                
                // Check if we have multiple commands
                const commandCount = Object.keys(optionsByCommand).length;
                
                // Create a mapping of command names to their index for color coding
                const commandIndexMap = {};
                commandTokens.forEach((token, index) => {
                    commandIndexMap[token.value] = index;
                });
                
                Object.entries(optionsByCommand).forEach(([cmd, options]) => {
                    // Get the color class for this command
                    const commandIndex = commandIndexMap[cmd] || 0;
                    const colorClass = `command-${commandIndex % 5}`;
                    
                    // Add command label with matching color
                    optionsHtml += `<div class="command-header ${colorClass}">${cmd} options:</div>`;
                    
                    const optionCommandInfo = commandOptions[cmd];
                    
                    options.forEach(optionToken => {
                        const optionValue = optionToken.value;
                        
                        if (optionValue.startsWith('--')) {
                            // Long option
                            const optionName = optionValue.split('=')[0];
                            const optionData = commandParser.findOptionByLongName(cmd, optionName);
                            if (optionData) {
                                optionsHtml += `
                                    <div class="option-item">
                                        <div class="option-name">${optionName}</div>
                                        <div class="option-description">${optionData.description}</div>
                                    </div>
                                `;
                            }
                        } else if (optionValue.startsWith('-')) {
                            // Short option(s)
                            const options = optionValue.substring(1).split('');
                            options.forEach(opt => {
                                const optionKey = '-' + opt;
                                const optionData = optionCommandInfo?.options?.[optionKey];
                                if (optionData) {
                                    optionsHtml += `
                                        <div class="option-item">
                                            <div class="option-name">${optionKey}${optionData.long ? ' / ' + optionData.long : ''}</div>
                                            <div class="option-description">${optionData.description}</div>
                                        </div>
                                    `;
                                }
                            });
                        }
                    });
                });
                
                optionsHtml += '</div>';
                usedSection.innerHTML = optionsHtml;
                commandExplanations.appendChild(usedSection);
            }

            // Example usage
            const exampleSection = document.createElement('div');
            exampleSection.className = 'explanation-section collapsed';
            exampleSection.innerHTML = `
                <div class="explanation-header">Common Examples</div>
                <div class="explanation-content">
                    <div class="loading">Loading examples...</div>
                </div>
            `;
            
            // Add click handler to toggle sections
            exampleSection.querySelector('.explanation-header').addEventListener('click', function() {
                exampleSection.classList.toggle('collapsed');
            });
            
            commandExplanations.appendChild(exampleSection);
            
            // Load examples for all commands asynchronously
            const commandNames = commandTokens.map(t => t.value);
            getAllCommandExamples(commandNames, commandTokens).then(examplesHtml => {
                // Check if element still exists before setting innerHTML (prevents null reference errors)
                const contentElement = exampleSection.querySelector('.explanation-content');
                if (contentElement) {
                    contentElement.innerHTML = examplesHtml;
                }
            });
        }

        // Get examples for multiple commands
        async function getAllCommandExamples(commandNames, commandTokens) {
            const examplePromises = commandNames.map(cmd => getCommandExamples(cmd));
            const allExamples = await Promise.all(examplePromises);
            
            let combinedHtml = '';
            commandNames.forEach((cmd, index) => {
                const colorClass = `command-${index % 5}`;
                
                combinedHtml += `<div class="command-header ${colorClass}">${cmd} examples:</div>`;
                combinedHtml += allExamples[index] || '<p style="color: #666;">No examples available</p>';
            });
            
            return combinedHtml;
        }

        // Get command examples (integrates with TLDR)
        async function getCommandExamples(command) {
            // Ensure TLDR index is loaded before trying to fetch
            await ensureTldrIndex();
            
            // First try to get TLDR examples
            const tldrContent = await fetchTLDR(command);
            if (tldrContent) {
                const tldr = parseTLDRMarkdown(tldrContent);
                if (tldr.examples && tldr.examples.length > 0) {
                    let html = '';
                    tldr.examples.forEach(example => {
                        html += `
                            <div class="example-command">${highlightTLDRCode(example.code)}</div>
                            <p>${example.description}</p>
                        `;
                    });
                    return html;
                }
            }
            
            // Fallback to hardcoded examples
            const examples = {
                'ls': `
                    <div class="example-command">ls -la</div>
                    <p>List all files (including hidden) in long format</p>
                    
                    <div class="example-command">ls -lh *.txt</div>
                    <p>List all .txt files with human-readable sizes</p>
                    
                    <div class="example-command">ls -lt | head -10</div>
                    <p>List 10 most recently modified files</p>
                `,
                'grep': `
                    <div class="example-command">grep -i "error" log.txt</div>
                    <p>Search for "error" case-insensitively in log.txt</p>
                    
                    <div class="example-command">grep -r "TODO" --include="*.js"</div>
                    <p>Recursively search for "TODO" in JavaScript files</p>
                    
                    <div class="example-command">grep -n "function" script.sh</div>
                    <p>Search with line numbers</p>
                `,
                'cat': `
                    <div class="example-command">cat file1.txt file2.txt > combined.txt</div>
                    <p>Concatenate files and save to new file</p>
                    
                    <div class="example-command">cat -n script.py</div>
                    <p>Display file with line numbers</p>
                `,
                'find': `
                    <div class="example-command">find . -name "*.log" -type f</div>
                    <p>Find all .log files in current directory</p>
                    
                    <div class="example-command">find /home -size +100M</div>
                    <p>Find files larger than 100MB</p>
                    
                    <div class="example-command">find . -mtime -7 -type f</div>
                    <p>Find files modified in last 7 days</p>
                `,
                'tar': `
                    <div class="example-command">tar -czf archive.tar.gz folder/</div>
                    <p>Create compressed archive of folder</p>
                    
                    <div class="example-command">tar -xzf archive.tar.gz</div>
                    <p>Extract compressed archive</p>
                    
                    <div class="example-command">tar -tzf archive.tar.gz</div>
                    <p>List contents of compressed archive</p>
                `
            };
            
            return examples[command] || '<p>No examples available for this command.</p>';
        }

        

        // Handle command input
        let parseTimeout;
        commandInput.addEventListener('input', (e) => {
            clearTimeout(parseTimeout);
            parseTimeout = setTimeout(async () => {
                const input = e.target.value.trim();
                if (input) {
                    // Update options in case they were loaded after parser was created
                    commandParser.updateOptions();
                    const tokens = commandParser.parse(input);
                    displayParsedCommand(tokens);
                    await displayExplanations(tokens);
                } else {
                    commandBreakdown.innerHTML = '<div class="no-explanation">Enter a command above to see its breakdown</div>';
                    commandExplanations.innerHTML = '';
                }
            }, 300);
        });

        // Open command explainer
        async function openCommandExplainer() {
            // Close other modals first
            closeAllModals();
            
            // Ensure options are loaded before opening
            await ensureOptions();
            
            commandExplainerModal.style.display = 'block';
            overlay.style.display = 'block';
            commandInput.focus();
        }

        // Close command explainer
        function closeCommandExplainer() {
            // Clean up tooltips
            const existingTokens = commandBreakdown.querySelectorAll('.command-token');
            existingTokens.forEach(token => {
                if (token.tooltipElement && token.tooltipElement.parentNode) {
                    token.tooltipElement.parentNode.removeChild(token.tooltipElement);
                }
            });
            
            commandExplainerModal.style.display = 'none';
            overlay.style.display = 'none';
        }

        explainerFab.addEventListener('click', openCommandExplainer);
        commandExplainerClose.addEventListener('click', closeCommandExplainer);

        // Note: keyboard shortcut for command explainer is already handled in the main keyboard handler
        
        // Close modals when clicking overlay
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                // Close theme modal if open
                if (themeModal.style.display === 'block') {
                    closeThemeModal();
                }
                // Close shortcuts help if open
                if (shortcutsHelp.style.display === 'block') {
                    shortcutsHelp.style.display = 'none';
                    overlay.style.display = 'none';
                }
                // Close command explainer if open
                if (commandExplainerModal.style.display === 'block') {
                    closeCommandExplainer();
                }
            }
        });

        // Flag to prevent recursive hash change handling
        let isSettingHash = false;
        
        // Handle direct linking via hash
        function handleHashChange() {
            const hash = window.location.hash.slice(1);
            if (hash) {
                // Check if we're already handling this hash change
                if (isSettingHash) {
                    isSettingHash = false;
                    return;
                }
                
                // Just command name in hash now
                const command = hash;
                const found = window.searchIndex.find(item => 
                    (item.command || item.name) === command
                );
                if (found) {
                    displayManPage(command, found.section);
                }
            }
        }

        // Lazy loading cache and state
        const dataCache = new Map();
        let searchIndexLoaded = false;
        let tldrIndexLoaded = false;
        let optionsLoaded = false;
        
        // Optimized search index structures
        let searchIndexMap = null; // Map for O(1) exact lookups
        let searchIndexByPrefix = null; // Map for prefix searches
        let tokenizedDescriptions = null; // Pre-processed descriptions

        // Lazy load data files on demand
        async function loadDataFile(filename, variableName) {
            if (dataCache.has(filename)) {
                return dataCache.get(filename);
            }

            try {
                showStatus(`Loading ${filename}...`);
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}: ${response.status}`);
                }
                
                const script = await response.text();
                
                // Execute the script to create global variables
                eval(script);
                
                dataCache.set(filename, true);
                showStatus(`${filename} loaded successfully`);
                return true;
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
                showStatus(`Error loading ${filename}`, 3000);
                return false;
            }
        }

        // Search index loading state management
        let searchIndexLoadingPromise = null;
        let searchIndexLoadingRequestId = 0;
        
        // Load search index with progressive loading support and race condition protection
        async function ensureSearchIndex(useProgressiveLoading = true) {
            // If already loaded, return immediately
            if (searchIndexLoaded && searchIndexMap && searchIndexMap.size > 0) {
                return true;
            }
            
            // If already loading, return the existing promise
            if (searchIndexLoadingPromise) {
                return await searchIndexLoadingPromise;
            }
            
            // Generate unique request ID to track this loading attempt
            const currentRequestId = ++searchIndexLoadingRequestId;
            
            // Create and store the loading promise
            searchIndexLoadingPromise = (async () => {
                try {
                    // Check if we were cancelled before starting
                    if (currentRequestId !== searchIndexLoadingRequestId) {
                        console.log('Search index loading cancelled (newer request started)');
                        return false;
                    }
                    
                    let success = false;
                    
                    // Determine loading strategy
                    if (useProgressiveLoading && !progressiveIndexLoader.isLoading) {
                        // Try progressive loading first
                        try {
                            await progressiveIndexLoader.startProgressiveLoading((progress, message) => {
                                // Check if we're still the current request
                                if (currentRequestId === searchIndexLoadingRequestId) {
                                    // Update loading state manager with progress
                                    if (loadingStateManager) {
                                        loadingStateManager.updateLoadingProgress(progress, message);
                                    }
                                }
                            });
                            
                            // Final check before setting loaded state
                            if (currentRequestId === searchIndexLoadingRequestId) {
                                searchIndexLoaded = true;
                                success = true;
                            }
                            
                        } catch (error) {
                            console.warn('Progressive loading failed, falling back to full load:', error);
                            // Fall through to traditional loading
                        }
                    }
                    
                    // Traditional loading (fallback or if progressive loading is disabled)
                    if (!success && currentRequestId === searchIndexLoadingRequestId) {
                        success = await loadDataFile('data/index.js', 'searchIndex');
                        
                        // Final check before setting state
                        if (currentRequestId === searchIndexLoadingRequestId) {
                            searchIndexLoaded = success;
                            
                            // Build optimized indexes after loading
                            if (success) {
                                buildOptimizedSearchIndex();
                            }
                        }
                    }
                    
                    return success;
                    
                } catch (error) {
                    console.error('Search index loading failed:', error);
                    return false;
                } finally {
                    // Clear the loading promise if we're still the current request
                    if (currentRequestId === searchIndexLoadingRequestId) {
                        searchIndexLoadingPromise = null;
                    }
                }
            })();
            
            return await searchIndexLoadingPromise;
        }
        
        // Load search index progressively on page load (background)
        async function startBackgroundIndexLoading() {
            // Use the synchronized ensureSearchIndex function
            try {
                console.log('Starting background progressive index loading...');
                
                const success = await ensureSearchIndex(true);
                
                if (success) {
                    console.log('Background progressive index loading completed');
                    // Update UI to indicate search is fully ready
                    showStatus('Search index fully loaded - Enhanced search ready', 2000);
                } else {
                    console.warn('Background progressive loading failed');
                }
                
            } catch (error) {
                console.warn('Background progressive loading failed:', error);
            }
        }
        
        // Enhanced search index check with priority command support
        function isSearchReady(commandName = null) {
            if (searchIndexLoaded && searchIndexMap && searchIndexMap.size > 0) {
                return true;
            }
            
            // If we're looking for a specific command and it's a priority command
            if (commandName && progressiveIndexLoader.isPriorityLoaded()) {
                const cmd = commandName.toLowerCase();
                return searchIndexMap && searchIndexMap.has(cmd);
            }
            
            return false;
        }

        // Load TLDR index only when needed
        async function ensureTldrIndex() {
            if (tldrIndexLoaded && typeof window.tldrIndex !== 'undefined') {
                return true;
            }

            const success = await loadDataFile('data/tldr_index.js', 'tldrIndex');
            tldrIndexLoaded = success;
            return success;
        }

        // Load command options only when needed
        async function ensureOptions() {
            if (optionsLoaded && typeof window.commandOptions !== 'undefined') {
                return true;
            }

            const success = await loadDataFile('data/options.js', 'commandOptions');
            optionsLoaded = success;
            return success;
        }

        // Build optimized search index structures
        function buildOptimizedSearchIndex() {
            if (!window.searchIndex || searchIndexMap) {
                return; // Already built or no data
            }

            console.log('Building optimized search index...');
            const startTime = performance.now();

            // Initialize structures
            searchIndexMap = new Map();
            searchIndexByPrefix = new Map();
            tokenizedDescriptions = new Map();

            // Build indexes
            for (const entry of window.searchIndex) {
                const commandLower = entry.command.toLowerCase();
                
                // Exact command lookup map
                if (!searchIndexMap.has(commandLower)) {
                    searchIndexMap.set(commandLower, []);
                }
                searchIndexMap.get(commandLower).push(entry);

                // Prefix index (first 2-4 characters)
                for (let len = 2; len <= Math.min(4, commandLower.length); len++) {
                    const prefix = commandLower.substring(0, len);
                    if (!searchIndexByPrefix.has(prefix)) {
                        searchIndexByPrefix.set(prefix, new Set());
                    }
                    searchIndexByPrefix.get(prefix).add(entry);
                }

                // Tokenize and index description
                if (entry.description) {
                    const descLower = entry.description.toLowerCase();
                    const tokens = descLower.split(/\s+/).filter(t => t.length > 2);
                    tokenizedDescriptions.set(entry, { descLower, tokens });
                }
            }

            const buildTime = performance.now() - startTime;
            console.log(`Optimized search index built in ${buildTime.toFixed(2)}ms`);
            console.log(`- Exact lookup map: ${searchIndexMap.size} unique commands`);
            console.log(`- Prefix index: ${searchIndexByPrefix.size} prefixes`);
        }

        // Initialize
        window.addEventListener('load', async () => {
            loadSavedData();
            
            // Show initial ready state without loading data
            showStatus('Ready - Search to load man pages');
            
            // Check for direct link - load search index if needed
            if (window.location.hash) {
                await ensureSearchIndex();
                handleHashChange();
            } else {
                // Start background progressive loading for better UX
                setTimeout(() => {
                    startBackgroundIndexLoading();
                }, 1000); // Small delay to not interfere with page load
            }
            
            // Start background theme preloading for popular themes
            setTimeout(() => {
                if (window.themes) {
                    themePerformanceManager.preloadThemes();
                    console.log('Background theme preloading started');
                }
            }, 2000); // Delay to not interfere with index loading
            
            searchInput.focus();
        });
        
        window.addEventListener('hashchange', handleHashChange);
        
        // Expose cache utilities for debugging
        window.searchCacheDebug = {
            getStats: getSearchCacheStats,
            clear: clearSearchCache,
            view: () => {
                const stats = getSearchCacheStats();
                console.log('Search Cache Statistics:', stats);
                console.log(`Cache entries: ${stats.size}/${stats.maxSize}`);
                console.log(`Average age: ${stats.avgAge}s`);
                console.log(`Expired entries: ${stats.expiredCount}`);
                console.log(`TTL: ${stats.ttl}s`);
                return stats;
            },
            inspect: (query, section) => {
                const cacheKey = `${query.toLowerCase()}_${section || 'all'}`;
                const entry = searchResultCache.get(cacheKey);
                if (entry) {
                    const age = Math.round((Date.now() - entry.timestamp) / 1000);
                    console.log(`Cache entry for "${query}" (section: ${section || 'all'}):`);
                    console.log(`- Results: ${entry.results.length} items`);
                    console.log(`- Age: ${age}s`);
                    console.log(`- Expires in: ${Math.round(SEARCH_CACHE_TTL / 1000 - age)}s`);
                    return entry;
                } else {
                    console.log(`No cache entry found for "${query}" (section: ${section || 'all'})`);
                    return null;
                }
            }
        };
    </script><div id="theme-transition-overlay" style="position: fixed; top: 0px; left: 0px; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.1); backdrop-filter: blur(2px); z-index: 9999; opacity: 0; pointer-events: none; transition: opacity 120ms;"></div>

</body></html>